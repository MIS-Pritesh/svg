var Ah = Object.defineProperty;
var gh = (r, e, t) => e in r ? Ah(r, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : r[e] = t;
var mt = (r, e, t) => gh(r, typeof e != "symbol" ? e + "" : e, t);
import "../modulepreload-polyfill-B5Qt9EMX.js";
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const Wa = "177"
  , vh = 0
  , wc = 1
  , xh = 2
  , ja = 1
  , yh = 2
  , Nn = 3
  , Hn = 0
  , Vt = 1
  , $t = 2
  , ei = 0
  , Bi = 1
  , Sc = 2
  , Tc = 3
  , Ec = 4
  , bh = 5
  , fi = 100
  , Mh = 101
  , wh = 102
  , Sh = 103
  , Th = 104
  , Eh = 200
  , Ph = 201
  , Lh = 202
  , Ch = 203
  , jo = 204
  , ko = 205
  , Rh = 206
  , Dh = 207
  , Nh = 208
  , Oh = 209
  , zh = 210
  , Ih = 211
  , Uh = 212
  , Bh = 213
  , Fh = 214
  , Yo = 0
  , qo = 1
  , Zo = 2
  , Vi = 3
  , Ko = 4
  , Qo = 5
  , Jo = 6
  , $o = 7
  , ka = 0
  , _h = 1
  , Hh = 2
  , ti = 0
  , Xh = 1
  , Gh = 2
  , Vh = 3
  , Wh = 4
  , jh = 5
  , kh = 6
  , Yh = 7
  , Pc = "attached"
  , qh = "detached"
  , pu = 300
  , Wi = 301
  , ji = 302
  , ea = 303
  , ta = 304
  , Wr = 306
  , ki = 1e3
  , Kn = 1001
  , Fr = 1002
  , _t = 1003
  , mu = 1004
  , As = 1005
  , Yt = 1006
  , Cr = 1007
  , In = 1008
  , Mn = 1009
  , Au = 1010
  , gu = 1011
  , Es = 1012
  , Ya = 1013
  , Ai = 1014
  , dn = 1015
  , Fs = 1016
  , qa = 1017
  , Za = 1018
  , Ps = 1020
  , vu = 35902
  , xu = 1021
  , yu = 1022
  , tn = 1023
  , Ls = 1026
  , Cs = 1027
  , Ka = 1028
  , Qa = 1029
  , bu = 1030
  , Ja = 1031
  , $a = 1033
  , Rr = 33776
  , Dr = 33777
  , Nr = 33778
  , Or = 33779
  , na = 35840
  , ia = 35841
  , sa = 35842
  , ra = 35843
  , oa = 36196
  , aa = 37492
  , ca = 37496
  , la = 37808
  , ua = 37809
  , ha = 37810
  , da = 37811
  , fa = 37812
  , pa = 37813
  , ma = 37814
  , Aa = 37815
  , ga = 37816
  , va = 37817
  , xa = 37818
  , ya = 37819
  , ba = 37820
  , Ma = 37821
  , zr = 36492
  , wa = 36494
  , Sa = 36495
  , Mu = 36283
  , Ta = 36284
  , Ea = 36285
  , Pa = 36286
  , Rs = 2300
  , Ds = 2301
  , Jr = 2302
  , Lc = 2400
  , Cc = 2401
  , Rc = 2402
  , Zh = 2500
  , Kh = 0
  , wu = 1
  , La = 2
  , Qh = 3200
  , Jh = 3201
  , ec = 0
  , $h = 1
  , Zn = ""
  , Rt = "srgb"
  , Ht = "srgb-linear"
  , _r = "linear"
  , at = "srgb"
  , bi = 7680
  , Dc = 519
  , ed = 512
  , td = 513
  , nd = 514
  , Su = 515
  , id = 516
  , sd = 517
  , rd = 518
  , od = 519
  , Ca = 35044
  , Nc = "300 es"
  , Un = 2e3
  , Hr = 2001;
class es {
    addEventListener(e, t) {
        this._listeners === void 0 && (this._listeners = {});
        const n = this._listeners;
        n[e] === void 0 && (n[e] = []),
        n[e].indexOf(t) === -1 && n[e].push(t)
    }
    hasEventListener(e, t) {
        const n = this._listeners;
        return n === void 0 ? !1 : n[e] !== void 0 && n[e].indexOf(t) !== -1
    }
    removeEventListener(e, t) {
        const n = this._listeners;
        if (n === void 0)
            return;
        const i = n[e];
        if (i !== void 0) {
            const s = i.indexOf(t);
            s !== -1 && i.splice(s, 1)
        }
    }
    dispatchEvent(e) {
        const t = this._listeners;
        if (t === void 0)
            return;
        const n = t[e.type];
        if (n !== void 0) {
            e.target = this;
            const i = n.slice(0);
            for (let s = 0, o = i.length; s < o; s++)
                i[s].call(this, e);
            e.target = null
        }
    }
}
const Nt = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let Oc = 1234567;
const Fi = Math.PI / 180
  , Yi = 180 / Math.PI;
function nn() {
    const r = Math.random() * 4294967295 | 0
      , e = Math.random() * 4294967295 | 0
      , t = Math.random() * 4294967295 | 0
      , n = Math.random() * 4294967295 | 0;
    return (Nt[r & 255] + Nt[r >> 8 & 255] + Nt[r >> 16 & 255] + Nt[r >> 24 & 255] + "-" + Nt[e & 255] + Nt[e >> 8 & 255] + "-" + Nt[e >> 16 & 15 | 64] + Nt[e >> 24 & 255] + "-" + Nt[t & 63 | 128] + Nt[t >> 8 & 255] + "-" + Nt[t >> 16 & 255] + Nt[t >> 24 & 255] + Nt[n & 255] + Nt[n >> 8 & 255] + Nt[n >> 16 & 255] + Nt[n >> 24 & 255]).toLowerCase()
}
function Ke(r, e, t) {
    return Math.max(e, Math.min(t, r))
}
function tc(r, e) {
    return (r % e + e) % e
}
function ad(r, e, t, n, i) {
    return n + (r - e) * (i - n) / (t - e)
}
function cd(r, e, t) {
    return r !== e ? (t - r) / (e - r) : 0
}
function bs(r, e, t) {
    return (1 - t) * r + t * e
}
function ld(r, e, t, n) {
    return bs(r, e, 1 - Math.exp(-t * n))
}
function ud(r, e=1) {
    return e - Math.abs(tc(r, e * 2) - e)
}
function hd(r, e, t) {
    return r <= e ? 0 : r >= t ? 1 : (r = (r - e) / (t - e),
    r * r * (3 - 2 * r))
}
function dd(r, e, t) {
    return r <= e ? 0 : r >= t ? 1 : (r = (r - e) / (t - e),
    r * r * r * (r * (r * 6 - 15) + 10))
}
function fd(r, e) {
    return r + Math.floor(Math.random() * (e - r + 1))
}
function pd(r, e) {
    return r + Math.random() * (e - r)
}
function md(r) {
    return r * (.5 - Math.random())
}
function Ad(r) {
    r !== void 0 && (Oc = r);
    let e = Oc += 1831565813;
    return e = Math.imul(e ^ e >>> 15, e | 1),
    e ^= e + Math.imul(e ^ e >>> 7, e | 61),
    ((e ^ e >>> 14) >>> 0) / 4294967296
}
function gd(r) {
    return r * Fi
}
function vd(r) {
    return r * Yi
}
function xd(r) {
    return (r & r - 1) === 0 && r !== 0
}
function yd(r) {
    return Math.pow(2, Math.ceil(Math.log(r) / Math.LN2))
}
function bd(r) {
    return Math.pow(2, Math.floor(Math.log(r) / Math.LN2))
}
function Md(r, e, t, n, i) {
    const s = Math.cos
      , o = Math.sin
      , a = s(t / 2)
      , c = o(t / 2)
      , l = s((e + n) / 2)
      , u = o((e + n) / 2)
      , h = s((e - n) / 2)
      , d = o((e - n) / 2)
      , f = s((n - e) / 2)
      , m = o((n - e) / 2);
    switch (i) {
    case "XYX":
        r.set(a * u, c * h, c * d, a * l);
        break;
    case "YZY":
        r.set(c * d, a * u, c * h, a * l);
        break;
    case "ZXZ":
        r.set(c * h, c * d, a * u, a * l);
        break;
    case "XZX":
        r.set(a * u, c * m, c * f, a * l);
        break;
    case "YXY":
        r.set(c * f, a * u, c * m, a * l);
        break;
    case "ZYZ":
        r.set(c * m, c * f, a * u, a * l);
        break;
    default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i)
    }
}
function hn(r, e) {
    switch (e.constructor) {
    case Float32Array:
        return r;
    case Uint32Array:
        return r / 4294967295;
    case Uint16Array:
        return r / 65535;
    case Uint8Array:
        return r / 255;
    case Int32Array:
        return Math.max(r / 2147483647, -1);
    case Int16Array:
        return Math.max(r / 32767, -1);
    case Int8Array:
        return Math.max(r / 127, -1);
    default:
        throw new Error("Invalid component type.")
    }
}
function rt(r, e) {
    switch (e.constructor) {
    case Float32Array:
        return r;
    case Uint32Array:
        return Math.round(r * 4294967295);
    case Uint16Array:
        return Math.round(r * 65535);
    case Uint8Array:
        return Math.round(r * 255);
    case Int32Array:
        return Math.round(r * 2147483647);
    case Int16Array:
        return Math.round(r * 32767);
    case Int8Array:
        return Math.round(r * 127);
    default:
        throw new Error("Invalid component type.")
    }
}
const Dt = {
    DEG2RAD: Fi,
    RAD2DEG: Yi,
    generateUUID: nn,
    clamp: Ke,
    euclideanModulo: tc,
    mapLinear: ad,
    inverseLerp: cd,
    lerp: bs,
    damp: ld,
    pingpong: ud,
    smoothstep: hd,
    smootherstep: dd,
    randInt: fd,
    randFloat: pd,
    randFloatSpread: md,
    seededRandom: Ad,
    degToRad: gd,
    radToDeg: vd,
    isPowerOfTwo: xd,
    ceilPowerOfTwo: yd,
    floorPowerOfTwo: bd,
    setQuaternionFromProperEuler: Md,
    normalize: rt,
    denormalize: hn
};
class Ae {
    constructor(e=0, t=0) {
        Ae.prototype.isVector2 = !0,
        this.x = e,
        this.y = t
    }
    get width() {
        return this.x
    }
    set width(e) {
        this.x = e
    }
    get height() {
        return this.y
    }
    set height(e) {
        this.y = e
    }
    set(e, t) {
        return this.x = e,
        this.y = t,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    applyMatrix3(e) {
        const t = this.x
          , n = this.y
          , i = e.elements;
        return this.x = i[0] * t + i[3] * n + i[6],
        this.y = i[1] * t + i[4] * n + i[7],
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this
    }
    clamp(e, t) {
        return this.x = Ke(this.x, e.x, t.x),
        this.y = Ke(this.y, e.y, t.y),
        this
    }
    clampScalar(e, t) {
        return this.x = Ke(this.x, e, t),
        this.y = Ke(this.y, e, t),
        this
    }
    clampLength(e, t) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(Ke(n, e, t))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y
    }
    cross(e) {
        return this.x * e.y - this.y * e.x
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0)
            return Math.PI / 2;
        const n = this.dot(e) / t;
        return Math.acos(Ke(n, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , n = this.y - e.y;
        return t * t + n * n
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this
    }
    lerpVectors(e, t, n) {
        return this.x = e.x + (t.x - e.x) * n,
        this.y = e.y + (t.y - e.y) * n,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this
    }
    rotateAround(e, t) {
        const n = Math.cos(t)
          , i = Math.sin(t)
          , s = this.x - e.x
          , o = this.y - e.y;
        return this.x = s * n - o * i + e.x,
        this.y = s * i + o * n + e.y,
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y
    }
}
class sn {
    constructor(e=0, t=0, n=0, i=1) {
        this.isQuaternion = !0,
        this._x = e,
        this._y = t,
        this._z = n,
        this._w = i
    }
    static slerpFlat(e, t, n, i, s, o, a) {
        let c = n[i + 0]
          , l = n[i + 1]
          , u = n[i + 2]
          , h = n[i + 3];
        const d = s[o + 0]
          , f = s[o + 1]
          , m = s[o + 2]
          , g = s[o + 3];
        if (a === 0) {
            e[t + 0] = c,
            e[t + 1] = l,
            e[t + 2] = u,
            e[t + 3] = h;
            return
        }
        if (a === 1) {
            e[t + 0] = d,
            e[t + 1] = f,
            e[t + 2] = m,
            e[t + 3] = g;
            return
        }
        if (h !== g || c !== d || l !== f || u !== m) {
            let A = 1 - a;
            const p = c * d + l * f + u * m + h * g
              , S = p >= 0 ? 1 : -1
              , w = 1 - p * p;
            if (w > Number.EPSILON) {
                const B = Math.sqrt(w)
                  , z = Math.atan2(B, p * S);
                A = Math.sin(A * z) / B,
                a = Math.sin(a * z) / B
            }
            const b = a * S;
            if (c = c * A + d * b,
            l = l * A + f * b,
            u = u * A + m * b,
            h = h * A + g * b,
            A === 1 - a) {
                const B = 1 / Math.sqrt(c * c + l * l + u * u + h * h);
                c *= B,
                l *= B,
                u *= B,
                h *= B
            }
        }
        e[t] = c,
        e[t + 1] = l,
        e[t + 2] = u,
        e[t + 3] = h
    }
    static multiplyQuaternionsFlat(e, t, n, i, s, o) {
        const a = n[i]
          , c = n[i + 1]
          , l = n[i + 2]
          , u = n[i + 3]
          , h = s[o]
          , d = s[o + 1]
          , f = s[o + 2]
          , m = s[o + 3];
        return e[t] = a * m + u * h + c * f - l * d,
        e[t + 1] = c * m + u * d + l * h - a * f,
        e[t + 2] = l * m + u * f + a * d - c * h,
        e[t + 3] = u * m - a * h - c * d - l * f,
        e
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get w() {
        return this._w
    }
    set w(e) {
        this._w = e,
        this._onChangeCallback()
    }
    set(e, t, n, i) {
        return this._x = e,
        this._y = t,
        this._z = n,
        this._w = i,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._w)
    }
    copy(e) {
        return this._x = e.x,
        this._y = e.y,
        this._z = e.z,
        this._w = e.w,
        this._onChangeCallback(),
        this
    }
    setFromEuler(e, t=!0) {
        const n = e._x
          , i = e._y
          , s = e._z
          , o = e._order
          , a = Math.cos
          , c = Math.sin
          , l = a(n / 2)
          , u = a(i / 2)
          , h = a(s / 2)
          , d = c(n / 2)
          , f = c(i / 2)
          , m = c(s / 2);
        switch (o) {
        case "XYZ":
            this._x = d * u * h + l * f * m,
            this._y = l * f * h - d * u * m,
            this._z = l * u * m + d * f * h,
            this._w = l * u * h - d * f * m;
            break;
        case "YXZ":
            this._x = d * u * h + l * f * m,
            this._y = l * f * h - d * u * m,
            this._z = l * u * m - d * f * h,
            this._w = l * u * h + d * f * m;
            break;
        case "ZXY":
            this._x = d * u * h - l * f * m,
            this._y = l * f * h + d * u * m,
            this._z = l * u * m + d * f * h,
            this._w = l * u * h - d * f * m;
            break;
        case "ZYX":
            this._x = d * u * h - l * f * m,
            this._y = l * f * h + d * u * m,
            this._z = l * u * m - d * f * h,
            this._w = l * u * h + d * f * m;
            break;
        case "YZX":
            this._x = d * u * h + l * f * m,
            this._y = l * f * h + d * u * m,
            this._z = l * u * m - d * f * h,
            this._w = l * u * h - d * f * m;
            break;
        case "XZY":
            this._x = d * u * h - l * f * m,
            this._y = l * f * h - d * u * m,
            this._z = l * u * m + d * f * h,
            this._w = l * u * h + d * f * m;
            break;
        default:
            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
        }
        return t === !0 && this._onChangeCallback(),
        this
    }
    setFromAxisAngle(e, t) {
        const n = t / 2
          , i = Math.sin(n);
        return this._x = e.x * i,
        this._y = e.y * i,
        this._z = e.z * i,
        this._w = Math.cos(n),
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e) {
        const t = e.elements
          , n = t[0]
          , i = t[4]
          , s = t[8]
          , o = t[1]
          , a = t[5]
          , c = t[9]
          , l = t[2]
          , u = t[6]
          , h = t[10]
          , d = n + a + h;
        if (d > 0) {
            const f = .5 / Math.sqrt(d + 1);
            this._w = .25 / f,
            this._x = (u - c) * f,
            this._y = (s - l) * f,
            this._z = (o - i) * f
        } else if (n > a && n > h) {
            const f = 2 * Math.sqrt(1 + n - a - h);
            this._w = (u - c) / f,
            this._x = .25 * f,
            this._y = (i + o) / f,
            this._z = (s + l) / f
        } else if (a > h) {
            const f = 2 * Math.sqrt(1 + a - n - h);
            this._w = (s - l) / f,
            this._x = (i + o) / f,
            this._y = .25 * f,
            this._z = (c + u) / f
        } else {
            const f = 2 * Math.sqrt(1 + h - n - a);
            this._w = (o - i) / f,
            this._x = (s + l) / f,
            this._y = (c + u) / f,
            this._z = .25 * f
        }
        return this._onChangeCallback(),
        this
    }
    setFromUnitVectors(e, t) {
        let n = e.dot(t) + 1;
        return n < Number.EPSILON ? (n = 0,
        Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
        this._y = e.x,
        this._z = 0,
        this._w = n) : (this._x = 0,
        this._y = -e.z,
        this._z = e.y,
        this._w = n)) : (this._x = e.y * t.z - e.z * t.y,
        this._y = e.z * t.x - e.x * t.z,
        this._z = e.x * t.y - e.y * t.x,
        this._w = n),
        this.normalize()
    }
    angleTo(e) {
        return 2 * Math.acos(Math.abs(Ke(this.dot(e), -1, 1)))
    }
    rotateTowards(e, t) {
        const n = this.angleTo(e);
        if (n === 0)
            return this;
        const i = Math.min(1, t / n);
        return this.slerp(e, i),
        this
    }
    identity() {
        return this.set(0, 0, 0, 1)
    }
    invert() {
        return this.conjugate()
    }
    conjugate() {
        return this._x *= -1,
        this._y *= -1,
        this._z *= -1,
        this._onChangeCallback(),
        this
    }
    dot(e) {
        return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }
    normalize() {
        let e = this.length();
        return e === 0 ? (this._x = 0,
        this._y = 0,
        this._z = 0,
        this._w = 1) : (e = 1 / e,
        this._x = this._x * e,
        this._y = this._y * e,
        this._z = this._z * e,
        this._w = this._w * e),
        this._onChangeCallback(),
        this
    }
    multiply(e) {
        return this.multiplyQuaternions(this, e)
    }
    premultiply(e) {
        return this.multiplyQuaternions(e, this)
    }
    multiplyQuaternions(e, t) {
        const n = e._x
          , i = e._y
          , s = e._z
          , o = e._w
          , a = t._x
          , c = t._y
          , l = t._z
          , u = t._w;
        return this._x = n * u + o * a + i * l - s * c,
        this._y = i * u + o * c + s * a - n * l,
        this._z = s * u + o * l + n * c - i * a,
        this._w = o * u - n * a - i * c - s * l,
        this._onChangeCallback(),
        this
    }
    slerp(e, t) {
        if (t === 0)
            return this;
        if (t === 1)
            return this.copy(e);
        const n = this._x
          , i = this._y
          , s = this._z
          , o = this._w;
        let a = o * e._w + n * e._x + i * e._y + s * e._z;
        if (a < 0 ? (this._w = -e._w,
        this._x = -e._x,
        this._y = -e._y,
        this._z = -e._z,
        a = -a) : this.copy(e),
        a >= 1)
            return this._w = o,
            this._x = n,
            this._y = i,
            this._z = s,
            this;
        const c = 1 - a * a;
        if (c <= Number.EPSILON) {
            const f = 1 - t;
            return this._w = f * o + t * this._w,
            this._x = f * n + t * this._x,
            this._y = f * i + t * this._y,
            this._z = f * s + t * this._z,
            this.normalize(),
            this
        }
        const l = Math.sqrt(c)
          , u = Math.atan2(l, a)
          , h = Math.sin((1 - t) * u) / l
          , d = Math.sin(t * u) / l;
        return this._w = o * h + this._w * d,
        this._x = n * h + this._x * d,
        this._y = i * h + this._y * d,
        this._z = s * h + this._z * d,
        this._onChangeCallback(),
        this
    }
    slerpQuaternions(e, t, n) {
        return this.copy(e).slerp(t, n)
    }
    random() {
        const e = 2 * Math.PI * Math.random()
          , t = 2 * Math.PI * Math.random()
          , n = Math.random()
          , i = Math.sqrt(1 - n)
          , s = Math.sqrt(n);
        return this.set(i * Math.sin(e), i * Math.cos(e), s * Math.sin(t), s * Math.cos(t))
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
    }
    fromArray(e, t=0) {
        return this._x = e[t],
        this._y = e[t + 1],
        this._z = e[t + 2],
        this._w = e[t + 3],
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._w,
        e
    }
    fromBufferAttribute(e, t) {
        return this._x = e.getX(t),
        this._y = e.getY(t),
        this._z = e.getZ(t),
        this._w = e.getW(t),
        this._onChangeCallback(),
        this
    }
    toJSON() {
        return this.toArray()
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._w
    }
}
class D {
    constructor(e=0, t=0, n=0) {
        D.prototype.isVector3 = !0,
        this.x = e,
        this.y = t,
        this.z = n
    }
    set(e, t, n) {
        return n === void 0 && (n = this.z),
        this.x = e,
        this.y = t,
        this.z = n,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this
    }
    multiplyVectors(e, t) {
        return this.x = e.x * t.x,
        this.y = e.y * t.y,
        this.z = e.z * t.z,
        this
    }
    applyEuler(e) {
        return this.applyQuaternion(zc.setFromEuler(e))
    }
    applyAxisAngle(e, t) {
        return this.applyQuaternion(zc.setFromAxisAngle(e, t))
    }
    applyMatrix3(e) {
        const t = this.x
          , n = this.y
          , i = this.z
          , s = e.elements;
        return this.x = s[0] * t + s[3] * n + s[6] * i,
        this.y = s[1] * t + s[4] * n + s[7] * i,
        this.z = s[2] * t + s[5] * n + s[8] * i,
        this
    }
    applyNormalMatrix(e) {
        return this.applyMatrix3(e).normalize()
    }
    applyMatrix4(e) {
        const t = this.x
          , n = this.y
          , i = this.z
          , s = e.elements
          , o = 1 / (s[3] * t + s[7] * n + s[11] * i + s[15]);
        return this.x = (s[0] * t + s[4] * n + s[8] * i + s[12]) * o,
        this.y = (s[1] * t + s[5] * n + s[9] * i + s[13]) * o,
        this.z = (s[2] * t + s[6] * n + s[10] * i + s[14]) * o,
        this
    }
    applyQuaternion(e) {
        const t = this.x
          , n = this.y
          , i = this.z
          , s = e.x
          , o = e.y
          , a = e.z
          , c = e.w
          , l = 2 * (o * i - a * n)
          , u = 2 * (a * t - s * i)
          , h = 2 * (s * n - o * t);
        return this.x = t + c * l + o * h - a * u,
        this.y = n + c * u + a * l - s * h,
        this.z = i + c * h + s * u - o * l,
        this
    }
    project(e) {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
    }
    unproject(e) {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
    }
    transformDirection(e) {
        const t = this.x
          , n = this.y
          , i = this.z
          , s = e.elements;
        return this.x = s[0] * t + s[4] * n + s[8] * i,
        this.y = s[1] * t + s[5] * n + s[9] * i,
        this.z = s[2] * t + s[6] * n + s[10] * i,
        this.normalize()
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this.z /= e.z,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this
    }
    clamp(e, t) {
        return this.x = Ke(this.x, e.x, t.x),
        this.y = Ke(this.y, e.y, t.y),
        this.z = Ke(this.z, e.z, t.z),
        this
    }
    clampScalar(e, t) {
        return this.x = Ke(this.x, e, t),
        this.y = Ke(this.y, e, t),
        this.z = Ke(this.z, e, t),
        this
    }
    clampLength(e, t) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(Ke(n, e, t))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this.z = Math.trunc(this.z),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this
    }
    lerpVectors(e, t, n) {
        return this.x = e.x + (t.x - e.x) * n,
        this.y = e.y + (t.y - e.y) * n,
        this.z = e.z + (t.z - e.z) * n,
        this
    }
    cross(e) {
        return this.crossVectors(this, e)
    }
    crossVectors(e, t) {
        const n = e.x
          , i = e.y
          , s = e.z
          , o = t.x
          , a = t.y
          , c = t.z;
        return this.x = i * c - s * a,
        this.y = s * o - n * c,
        this.z = n * a - i * o,
        this
    }
    projectOnVector(e) {
        const t = e.lengthSq();
        if (t === 0)
            return this.set(0, 0, 0);
        const n = e.dot(this) / t;
        return this.copy(e).multiplyScalar(n)
    }
    projectOnPlane(e) {
        return $r.copy(this).projectOnVector(e),
        this.sub($r)
    }
    reflect(e) {
        return this.sub($r.copy(e).multiplyScalar(2 * this.dot(e)))
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0)
            return Math.PI / 2;
        const n = this.dot(e) / t;
        return Math.acos(Ke(n, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , n = this.y - e.y
          , i = this.z - e.z;
        return t * t + n * n + i * i
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    }
    setFromSpherical(e) {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
    }
    setFromSphericalCoords(e, t, n) {
        const i = Math.sin(t) * e;
        return this.x = i * Math.sin(n),
        this.y = Math.cos(t) * e,
        this.z = i * Math.cos(n),
        this
    }
    setFromCylindrical(e) {
        return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
    }
    setFromCylindricalCoords(e, t, n) {
        return this.x = e * Math.sin(t),
        this.y = n,
        this.z = e * Math.cos(t),
        this
    }
    setFromMatrixPosition(e) {
        const t = e.elements;
        return this.x = t[12],
        this.y = t[13],
        this.z = t[14],
        this
    }
    setFromMatrixScale(e) {
        const t = this.setFromMatrixColumn(e, 0).length()
          , n = this.setFromMatrixColumn(e, 1).length()
          , i = this.setFromMatrixColumn(e, 2).length();
        return this.x = t,
        this.y = n,
        this.z = i,
        this
    }
    setFromMatrixColumn(e, t) {
        return this.fromArray(e.elements, t * 4)
    }
    setFromMatrix3Column(e, t) {
        return this.fromArray(e.elements, t * 3)
    }
    setFromEuler(e) {
        return this.x = e._x,
        this.y = e._y,
        this.z = e._z,
        this
    }
    setFromColor(e) {
        return this.x = e.r,
        this.y = e.g,
        this.z = e.b,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this
    }
    randomDirection() {
        const e = Math.random() * Math.PI * 2
          , t = Math.random() * 2 - 1
          , n = Math.sqrt(1 - t * t);
        return this.x = n * Math.cos(e),
        this.y = t,
        this.z = n * Math.sin(e),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z
    }
}
const $r = new D
  , zc = new sn;
class qe {
    constructor(e, t, n, i, s, o, a, c, l) {
        qe.prototype.isMatrix3 = !0,
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        e !== void 0 && this.set(e, t, n, i, s, o, a, c, l)
    }
    set(e, t, n, i, s, o, a, c, l) {
        const u = this.elements;
        return u[0] = e,
        u[1] = i,
        u[2] = a,
        u[3] = t,
        u[4] = s,
        u[5] = c,
        u[6] = n,
        u[7] = o,
        u[8] = l,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
        this
    }
    copy(e) {
        const t = this.elements
          , n = e.elements;
        return t[0] = n[0],
        t[1] = n[1],
        t[2] = n[2],
        t[3] = n[3],
        t[4] = n[4],
        t[5] = n[5],
        t[6] = n[6],
        t[7] = n[7],
        t[8] = n[8],
        this
    }
    extractBasis(e, t, n) {
        return e.setFromMatrix3Column(this, 0),
        t.setFromMatrix3Column(this, 1),
        n.setFromMatrix3Column(this, 2),
        this
    }
    setFromMatrix4(e) {
        const t = e.elements;
        return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const n = e.elements
          , i = t.elements
          , s = this.elements
          , o = n[0]
          , a = n[3]
          , c = n[6]
          , l = n[1]
          , u = n[4]
          , h = n[7]
          , d = n[2]
          , f = n[5]
          , m = n[8]
          , g = i[0]
          , A = i[3]
          , p = i[6]
          , S = i[1]
          , w = i[4]
          , b = i[7]
          , B = i[2]
          , z = i[5]
          , I = i[8];
        return s[0] = o * g + a * S + c * B,
        s[3] = o * A + a * w + c * z,
        s[6] = o * p + a * b + c * I,
        s[1] = l * g + u * S + h * B,
        s[4] = l * A + u * w + h * z,
        s[7] = l * p + u * b + h * I,
        s[2] = d * g + f * S + m * B,
        s[5] = d * A + f * w + m * z,
        s[8] = d * p + f * b + m * I,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[3] *= e,
        t[6] *= e,
        t[1] *= e,
        t[4] *= e,
        t[7] *= e,
        t[2] *= e,
        t[5] *= e,
        t[8] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , n = e[1]
          , i = e[2]
          , s = e[3]
          , o = e[4]
          , a = e[5]
          , c = e[6]
          , l = e[7]
          , u = e[8];
        return t * o * u - t * a * l - n * s * u + n * a * c + i * s * l - i * o * c
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , n = e[1]
          , i = e[2]
          , s = e[3]
          , o = e[4]
          , a = e[5]
          , c = e[6]
          , l = e[7]
          , u = e[8]
          , h = u * o - a * l
          , d = a * c - u * s
          , f = l * s - o * c
          , m = t * h + n * d + i * f;
        if (m === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const g = 1 / m;
        return e[0] = h * g,
        e[1] = (i * l - u * n) * g,
        e[2] = (a * n - i * o) * g,
        e[3] = d * g,
        e[4] = (u * t - i * c) * g,
        e[5] = (i * s - a * t) * g,
        e[6] = f * g,
        e[7] = (n * c - l * t) * g,
        e[8] = (o * t - n * s) * g,
        this
    }
    transpose() {
        let e;
        const t = this.elements;
        return e = t[1],
        t[1] = t[3],
        t[3] = e,
        e = t[2],
        t[2] = t[6],
        t[6] = e,
        e = t[5],
        t[5] = t[7],
        t[7] = e,
        this
    }
    getNormalMatrix(e) {
        return this.setFromMatrix4(e).invert().transpose()
    }
    transposeIntoArray(e) {
        const t = this.elements;
        return e[0] = t[0],
        e[1] = t[3],
        e[2] = t[6],
        e[3] = t[1],
        e[4] = t[4],
        e[5] = t[7],
        e[6] = t[2],
        e[7] = t[5],
        e[8] = t[8],
        this
    }
    setUvTransform(e, t, n, i, s, o, a) {
        const c = Math.cos(s)
          , l = Math.sin(s);
        return this.set(n * c, n * l, -n * (c * o + l * a) + o + e, -i * l, i * c, -i * (-l * o + c * a) + a + t, 0, 0, 1),
        this
    }
    scale(e, t) {
        return this.premultiply(eo.makeScale(e, t)),
        this
    }
    rotate(e) {
        return this.premultiply(eo.makeRotation(-e)),
        this
    }
    translate(e, t) {
        return this.premultiply(eo.makeTranslation(e, t)),
        this
    }
    makeTranslation(e, t) {
        return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
        this
    }
    makeRotation(e) {
        const t = Math.cos(e)
          , n = Math.sin(e);
        return this.set(t, -n, 0, n, t, 0, 0, 0, 1),
        this
    }
    makeScale(e, t) {
        return this.set(e, 0, 0, 0, t, 0, 0, 0, 1),
        this
    }
    equals(e) {
        const t = this.elements
          , n = e.elements;
        for (let i = 0; i < 9; i++)
            if (t[i] !== n[i])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let n = 0; n < 9; n++)
            this.elements[n] = e[n + t];
        return this
    }
    toArray(e=[], t=0) {
        const n = this.elements;
        return e[t] = n[0],
        e[t + 1] = n[1],
        e[t + 2] = n[2],
        e[t + 3] = n[3],
        e[t + 4] = n[4],
        e[t + 5] = n[5],
        e[t + 6] = n[6],
        e[t + 7] = n[7],
        e[t + 8] = n[8],
        e
    }
    clone() {
        return new this.constructor().fromArray(this.elements)
    }
}
const eo = new qe;
function Tu(r) {
    for (let e = r.length - 1; e >= 0; --e)
        if (r[e] >= 65535)
            return !0;
    return !1
}
function Ns(r) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", r)
}
function wd() {
    const r = Ns("canvas");
    return r.style.display = "block",
    r
}
const Ic = {};
function _i(r) {
    r in Ic || (Ic[r] = !0,
    console.warn(r))
}
function Sd(r, e, t) {
    return new Promise(function(n, i) {
        function s() {
            switch (r.clientWaitSync(e, r.SYNC_FLUSH_COMMANDS_BIT, 0)) {
            case r.WAIT_FAILED:
                i();
                break;
            case r.TIMEOUT_EXPIRED:
                setTimeout(s, t);
                break;
            default:
                n()
            }
        }
        setTimeout(s, t)
    }
    )
}
function Td(r) {
    const e = r.elements;
    e[2] = .5 * e[2] + .5 * e[3],
    e[6] = .5 * e[6] + .5 * e[7],
    e[10] = .5 * e[10] + .5 * e[11],
    e[14] = .5 * e[14] + .5 * e[15]
}
function Ed(r) {
    const e = r.elements;
    e[11] === -1 ? (e[10] = -e[10] - 1,
    e[14] = -e[14]) : (e[10] = -e[10],
    e[14] = -e[14] + 1)
}
const Uc = new qe().set(.4123908, .3575843, .1804808, .212639, .7151687, .0721923, .0193308, .1191948, .9505322)
  , Bc = new qe().set(3.2409699, -1.5373832, -.4986108, -.9692436, 1.8759675, .0415551, .0556301, -.203977, 1.0569715);
function Pd() {
    const r = {
        enabled: !0,
        workingColorSpace: Ht,
        spaces: {},
        convert: function(i, s, o) {
            return this.enabled === !1 || s === o || !s || !o || (this.spaces[s].transfer === at && (i.r = Fn(i.r),
            i.g = Fn(i.g),
            i.b = Fn(i.b)),
            this.spaces[s].primaries !== this.spaces[o].primaries && (i.applyMatrix3(this.spaces[s].toXYZ),
            i.applyMatrix3(this.spaces[o].fromXYZ)),
            this.spaces[o].transfer === at && (i.r = Hi(i.r),
            i.g = Hi(i.g),
            i.b = Hi(i.b))),
            i
        },
        workingToColorSpace: function(i, s) {
            return this.convert(i, this.workingColorSpace, s)
        },
        colorSpaceToWorking: function(i, s) {
            return this.convert(i, s, this.workingColorSpace)
        },
        getPrimaries: function(i) {
            return this.spaces[i].primaries
        },
        getTransfer: function(i) {
            return i === Zn ? _r : this.spaces[i].transfer
        },
        getLuminanceCoefficients: function(i, s=this.workingColorSpace) {
            return i.fromArray(this.spaces[s].luminanceCoefficients)
        },
        define: function(i) {
            Object.assign(this.spaces, i)
        },
        _getMatrix: function(i, s, o) {
            return i.copy(this.spaces[s].toXYZ).multiply(this.spaces[o].fromXYZ)
        },
        _getDrawingBufferColorSpace: function(i) {
            return this.spaces[i].outputColorSpaceConfig.drawingBufferColorSpace
        },
        _getUnpackColorSpace: function(i=this.workingColorSpace) {
            return this.spaces[i].workingColorSpaceConfig.unpackColorSpace
        },
        fromWorkingColorSpace: function(i, s) {
            return _i("THREE.ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."),
            r.workingToColorSpace(i, s)
        },
        toWorkingColorSpace: function(i, s) {
            return _i("THREE.ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."),
            r.colorSpaceToWorking(i, s)
        }
    }
      , e = [.64, .33, .3, .6, .15, .06]
      , t = [.2126, .7152, .0722]
      , n = [.3127, .329];
    return r.define({
        [Ht]: {
            primaries: e,
            whitePoint: n,
            transfer: _r,
            toXYZ: Uc,
            fromXYZ: Bc,
            luminanceCoefficients: t,
            workingColorSpaceConfig: {
                unpackColorSpace: Rt
            },
            outputColorSpaceConfig: {
                drawingBufferColorSpace: Rt
            }
        },
        [Rt]: {
            primaries: e,
            whitePoint: n,
            transfer: at,
            toXYZ: Uc,
            fromXYZ: Bc,
            luminanceCoefficients: t,
            outputColorSpaceConfig: {
                drawingBufferColorSpace: Rt
            }
        }
    }),
    r
}
const et = Pd();
function Fn(r) {
    return r < .04045 ? r * .0773993808 : Math.pow(r * .9478672986 + .0521327014, 2.4)
}
function Hi(r) {
    return r < .0031308 ? r * 12.92 : 1.055 * Math.pow(r, .41666) - .055
}
let Mi;
class Ld {
    static getDataURL(e, t="image/png") {
        if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
            return e.src;
        let n;
        if (e instanceof HTMLCanvasElement)
            n = e;
        else {
            Mi === void 0 && (Mi = Ns("canvas")),
            Mi.width = e.width,
            Mi.height = e.height;
            const i = Mi.getContext("2d");
            e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height),
            n = Mi
        }
        return n.toDataURL(t)
    }
    static sRGBToLinear(e) {
        if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
            const t = Ns("canvas");
            t.width = e.width,
            t.height = e.height;
            const n = t.getContext("2d");
            n.drawImage(e, 0, 0, e.width, e.height);
            const i = n.getImageData(0, 0, e.width, e.height)
              , s = i.data;
            for (let o = 0; o < s.length; o++)
                s[o] = Fn(s[o] / 255) * 255;
            return n.putImageData(i, 0, 0),
            t
        } else if (e.data) {
            const t = e.data.slice(0);
            for (let n = 0; n < t.length; n++)
                t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[n] = Math.floor(Fn(t[n] / 255) * 255) : t[n] = Fn(t[n]);
            return {
                data: t,
                width: e.width,
                height: e.height
            }
        } else
            return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
            e
    }
}
let Cd = 0;
class nc {
    constructor(e=null) {
        this.isSource = !0,
        Object.defineProperty(this, "id", {
            value: Cd++
        }),
        this.uuid = nn(),
        this.data = e,
        this.dataReady = !0,
        this.version = 0
    }
    getSize(e) {
        const t = this.data;
        return t instanceof HTMLVideoElement ? e.set(t.videoWidth, t.videoHeight) : t !== null ? e.set(t.width, t.height, t.depth || 0) : e.set(0, 0, 0),
        e
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.images[this.uuid] !== void 0)
            return e.images[this.uuid];
        const n = {
            uuid: this.uuid,
            url: ""
        }
          , i = this.data;
        if (i !== null) {
            let s;
            if (Array.isArray(i)) {
                s = [];
                for (let o = 0, a = i.length; o < a; o++)
                    i[o].isDataTexture ? s.push(to(i[o].image)) : s.push(to(i[o]))
            } else
                s = to(i);
            n.url = s
        }
        return t || (e.images[this.uuid] = n),
        n
    }
}
function to(r) {
    return typeof HTMLImageElement < "u" && r instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && r instanceof ImageBitmap ? Ld.getDataURL(r) : r.data ? {
        data: Array.from(r.data),
        width: r.width,
        height: r.height,
        type: r.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."),
    {})
}
let Rd = 0;
const no = new D;
class Tt extends es {
    constructor(e=Tt.DEFAULT_IMAGE, t=Tt.DEFAULT_MAPPING, n=Kn, i=Kn, s=Yt, o=In, a=tn, c=Mn, l=Tt.DEFAULT_ANISOTROPY, u=Zn) {
        super(),
        this.isTexture = !0,
        Object.defineProperty(this, "id", {
            value: Rd++
        }),
        this.uuid = nn(),
        this.name = "",
        this.source = new nc(e),
        this.mipmaps = [],
        this.mapping = t,
        this.channel = 0,
        this.wrapS = n,
        this.wrapT = i,
        this.magFilter = s,
        this.minFilter = o,
        this.anisotropy = l,
        this.format = a,
        this.internalFormat = null,
        this.type = c,
        this.offset = new Ae(0,0),
        this.repeat = new Ae(1,1),
        this.center = new Ae(0,0),
        this.rotation = 0,
        this.matrixAutoUpdate = !0,
        this.matrix = new qe,
        this.generateMipmaps = !0,
        this.premultiplyAlpha = !1,
        this.flipY = !0,
        this.unpackAlignment = 4,
        this.colorSpace = u,
        this.userData = {},
        this.updateRanges = [],
        this.version = 0,
        this.onUpdate = null,
        this.renderTarget = null,
        this.isRenderTargetTexture = !1,
        this.isArrayTexture = !!(e && e.depth && e.depth > 1),
        this.pmremVersion = 0
    }
    get width() {
        return this.source.getSize(no).x
    }
    get height() {
        return this.source.getSize(no).y
    }
    get depth() {
        return this.source.getSize(no).z
    }
    get image() {
        return this.source.data
    }
    set image(e=null) {
        this.source.data = e
    }
    updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
    }
    addUpdateRange(e, t) {
        this.updateRanges.push({
            start: e,
            count: t
        })
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.name = e.name,
        this.source = e.source,
        this.mipmaps = e.mipmaps.slice(0),
        this.mapping = e.mapping,
        this.channel = e.channel,
        this.wrapS = e.wrapS,
        this.wrapT = e.wrapT,
        this.magFilter = e.magFilter,
        this.minFilter = e.minFilter,
        this.anisotropy = e.anisotropy,
        this.format = e.format,
        this.internalFormat = e.internalFormat,
        this.type = e.type,
        this.offset.copy(e.offset),
        this.repeat.copy(e.repeat),
        this.center.copy(e.center),
        this.rotation = e.rotation,
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrix.copy(e.matrix),
        this.generateMipmaps = e.generateMipmaps,
        this.premultiplyAlpha = e.premultiplyAlpha,
        this.flipY = e.flipY,
        this.unpackAlignment = e.unpackAlignment,
        this.colorSpace = e.colorSpace,
        this.renderTarget = e.renderTarget,
        this.isRenderTargetTexture = e.isRenderTargetTexture,
        this.isArrayTexture = e.isArrayTexture,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this.needsUpdate = !0,
        this
    }
    setValues(e) {
        for (const t in e) {
            const n = e[t];
            if (n === void 0) {
                console.warn(`THREE.Texture.setValues(): parameter '${t}' has value of undefined.`);
                continue
            }
            const i = this[t];
            if (i === void 0) {
                console.warn(`THREE.Texture.setValues(): property '${t}' does not exist.`);
                continue
            }
            i && n && i.isVector2 && n.isVector2 || i && n && i.isVector3 && n.isVector3 || i && n && i.isMatrix3 && n.isMatrix3 ? i.copy(n) : this[t] = n
        }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.textures[this.uuid] !== void 0)
            return e.textures[this.uuid];
        const n = {
            metadata: {
                version: 4.7,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            channel: this.channel,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            colorSpace: this.colorSpace,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        return Object.keys(this.userData).length > 0 && (n.userData = this.userData),
        t || (e.textures[this.uuid] = n),
        n
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    transformUv(e) {
        if (this.mapping !== pu)
            return e;
        if (e.applyMatrix3(this.matrix),
        e.x < 0 || e.x > 1)
            switch (this.wrapS) {
            case ki:
                e.x = e.x - Math.floor(e.x);
                break;
            case Kn:
                e.x = e.x < 0 ? 0 : 1;
                break;
            case Fr:
                Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
                break
            }
        if (e.y < 0 || e.y > 1)
            switch (this.wrapT) {
            case ki:
                e.y = e.y - Math.floor(e.y);
                break;
            case Kn:
                e.y = e.y < 0 ? 0 : 1;
                break;
            case Fr:
                Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
                break
            }
        return this.flipY && (e.y = 1 - e.y),
        e
    }
    set needsUpdate(e) {
        e === !0 && (this.version++,
        this.source.needsUpdate = !0)
    }
    set needsPMREMUpdate(e) {
        e === !0 && this.pmremVersion++
    }
}
Tt.DEFAULT_IMAGE = null;
Tt.DEFAULT_MAPPING = pu;
Tt.DEFAULT_ANISOTROPY = 1;
class Je {
    constructor(e=0, t=0, n=0, i=1) {
        Je.prototype.isVector4 = !0,
        this.x = e,
        this.y = t,
        this.z = n,
        this.w = i
    }
    get width() {
        return this.z
    }
    set width(e) {
        this.z = e
    }
    get height() {
        return this.w
    }
    set height(e) {
        this.w = e
    }
    set(e, t, n, i) {
        return this.x = e,
        this.y = t,
        this.z = n,
        this.w = i,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this.w = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setW(e) {
        return this.w = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        case 3:
            this.w = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        case 3:
            return this.w;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z,this.w)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this.w = e.w !== void 0 ? e.w : 1,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this.w += e.w,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this.w += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this.w = e.w + t.w,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this.w += e.w * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this.w -= e.w,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this.w -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this.w = e.w - t.w,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this.w *= e.w,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this.w *= e,
        this
    }
    applyMatrix4(e) {
        const t = this.x
          , n = this.y
          , i = this.z
          , s = this.w
          , o = e.elements;
        return this.x = o[0] * t + o[4] * n + o[8] * i + o[12] * s,
        this.y = o[1] * t + o[5] * n + o[9] * i + o[13] * s,
        this.z = o[2] * t + o[6] * n + o[10] * i + o[14] * s,
        this.w = o[3] * t + o[7] * n + o[11] * i + o[15] * s,
        this
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this.z /= e.z,
        this.w /= e.w,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    setAxisAngleFromQuaternion(e) {
        this.w = 2 * Math.acos(e.w);
        const t = Math.sqrt(1 - e.w * e.w);
        return t < 1e-4 ? (this.x = 1,
        this.y = 0,
        this.z = 0) : (this.x = e.x / t,
        this.y = e.y / t,
        this.z = e.z / t),
        this
    }
    setAxisAngleFromRotationMatrix(e) {
        let t, n, i, s;
        const c = e.elements
          , l = c[0]
          , u = c[4]
          , h = c[8]
          , d = c[1]
          , f = c[5]
          , m = c[9]
          , g = c[2]
          , A = c[6]
          , p = c[10];
        if (Math.abs(u - d) < .01 && Math.abs(h - g) < .01 && Math.abs(m - A) < .01) {
            if (Math.abs(u + d) < .1 && Math.abs(h + g) < .1 && Math.abs(m + A) < .1 && Math.abs(l + f + p - 3) < .1)
                return this.set(1, 0, 0, 0),
                this;
            t = Math.PI;
            const w = (l + 1) / 2
              , b = (f + 1) / 2
              , B = (p + 1) / 2
              , z = (u + d) / 4
              , I = (h + g) / 4
              , H = (m + A) / 4;
            return w > b && w > B ? w < .01 ? (n = 0,
            i = .707106781,
            s = .707106781) : (n = Math.sqrt(w),
            i = z / n,
            s = I / n) : b > B ? b < .01 ? (n = .707106781,
            i = 0,
            s = .707106781) : (i = Math.sqrt(b),
            n = z / i,
            s = H / i) : B < .01 ? (n = .707106781,
            i = .707106781,
            s = 0) : (s = Math.sqrt(B),
            n = I / s,
            i = H / s),
            this.set(n, i, s, t),
            this
        }
        let S = Math.sqrt((A - m) * (A - m) + (h - g) * (h - g) + (d - u) * (d - u));
        return Math.abs(S) < .001 && (S = 1),
        this.x = (A - m) / S,
        this.y = (h - g) / S,
        this.z = (d - u) / S,
        this.w = Math.acos((l + f + p - 1) / 2),
        this
    }
    setFromMatrixPosition(e) {
        const t = e.elements;
        return this.x = t[12],
        this.y = t[13],
        this.z = t[14],
        this.w = t[15],
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this.w = Math.min(this.w, e.w),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this.w = Math.max(this.w, e.w),
        this
    }
    clamp(e, t) {
        return this.x = Ke(this.x, e.x, t.x),
        this.y = Ke(this.y, e.y, t.y),
        this.z = Ke(this.z, e.z, t.z),
        this.w = Ke(this.w, e.w, t.w),
        this
    }
    clampScalar(e, t) {
        return this.x = Ke(this.x, e, t),
        this.y = Ke(this.y, e, t),
        this.z = Ke(this.z, e, t),
        this.w = Ke(this.w, e, t),
        this
    }
    clampLength(e, t) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(Ke(n, e, t))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this.w = Math.floor(this.w),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this.w = Math.ceil(this.w),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this.w = Math.round(this.w),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this.z = Math.trunc(this.z),
        this.w = Math.trunc(this.w),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this.w = -this.w,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this.w += (e.w - this.w) * t,
        this
    }
    lerpVectors(e, t, n) {
        return this.x = e.x + (t.x - e.x) * n,
        this.y = e.y + (t.y - e.y) * n,
        this.z = e.z + (t.z - e.z) * n,
        this.w = e.w + (t.w - e.w) * n,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this.w = e[t + 3],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e[t + 3] = this.w,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this.w = e.getW(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this.w = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z,
        yield this.w
    }
}
class Dd extends es {
    constructor(e=1, t=1, n={}) {
        super(),
        n = Object.assign({
            generateMipmaps: !1,
            internalFormat: null,
            minFilter: Yt,
            depthBuffer: !0,
            stencilBuffer: !1,
            resolveDepthBuffer: !0,
            resolveStencilBuffer: !0,
            depthTexture: null,
            samples: 0,
            count: 1,
            depth: 1,
            multiview: !1
        }, n),
        this.isRenderTarget = !0,
        this.width = e,
        this.height = t,
        this.depth = n.depth,
        this.scissor = new Je(0,0,e,t),
        this.scissorTest = !1,
        this.viewport = new Je(0,0,e,t);
        const i = {
            width: e,
            height: t,
            depth: n.depth
        }
          , s = new Tt(i);
        this.textures = [];
        const o = n.count;
        for (let a = 0; a < o; a++)
            this.textures[a] = s.clone(),
            this.textures[a].isRenderTargetTexture = !0,
            this.textures[a].renderTarget = this;
        this._setTextureOptions(n),
        this.depthBuffer = n.depthBuffer,
        this.stencilBuffer = n.stencilBuffer,
        this.resolveDepthBuffer = n.resolveDepthBuffer,
        this.resolveStencilBuffer = n.resolveStencilBuffer,
        this._depthTexture = null,
        this.depthTexture = n.depthTexture,
        this.samples = n.samples,
        this.multiview = n.multiview
    }
    _setTextureOptions(e={}) {
        const t = {
            minFilter: Yt,
            generateMipmaps: !1,
            flipY: !1,
            internalFormat: null
        };
        e.mapping !== void 0 && (t.mapping = e.mapping),
        e.wrapS !== void 0 && (t.wrapS = e.wrapS),
        e.wrapT !== void 0 && (t.wrapT = e.wrapT),
        e.wrapR !== void 0 && (t.wrapR = e.wrapR),
        e.magFilter !== void 0 && (t.magFilter = e.magFilter),
        e.minFilter !== void 0 && (t.minFilter = e.minFilter),
        e.format !== void 0 && (t.format = e.format),
        e.type !== void 0 && (t.type = e.type),
        e.anisotropy !== void 0 && (t.anisotropy = e.anisotropy),
        e.colorSpace !== void 0 && (t.colorSpace = e.colorSpace),
        e.flipY !== void 0 && (t.flipY = e.flipY),
        e.generateMipmaps !== void 0 && (t.generateMipmaps = e.generateMipmaps),
        e.internalFormat !== void 0 && (t.internalFormat = e.internalFormat);
        for (let n = 0; n < this.textures.length; n++)
            this.textures[n].setValues(t)
    }
    get texture() {
        return this.textures[0]
    }
    set texture(e) {
        this.textures[0] = e
    }
    set depthTexture(e) {
        this._depthTexture !== null && (this._depthTexture.renderTarget = null),
        e !== null && (e.renderTarget = this),
        this._depthTexture = e
    }
    get depthTexture() {
        return this._depthTexture
    }
    setSize(e, t, n=1) {
        if (this.width !== e || this.height !== t || this.depth !== n) {
            this.width = e,
            this.height = t,
            this.depth = n;
            for (let i = 0, s = this.textures.length; i < s; i++)
                this.textures[i].image.width = e,
                this.textures[i].image.height = t,
                this.textures[i].image.depth = n,
                this.textures[i].isArrayTexture = this.textures[i].image.depth > 1;
            this.dispose()
        }
        this.viewport.set(0, 0, e, t),
        this.scissor.set(0, 0, e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.width = e.width,
        this.height = e.height,
        this.depth = e.depth,
        this.scissor.copy(e.scissor),
        this.scissorTest = e.scissorTest,
        this.viewport.copy(e.viewport),
        this.textures.length = 0;
        for (let t = 0, n = e.textures.length; t < n; t++) {
            this.textures[t] = e.textures[t].clone(),
            this.textures[t].isRenderTargetTexture = !0,
            this.textures[t].renderTarget = this;
            const i = Object.assign({}, e.textures[t].image);
            this.textures[t].source = new nc(i)
        }
        return this.depthBuffer = e.depthBuffer,
        this.stencilBuffer = e.stencilBuffer,
        this.resolveDepthBuffer = e.resolveDepthBuffer,
        this.resolveStencilBuffer = e.resolveStencilBuffer,
        e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
        this.samples = e.samples,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
class gi extends Dd {
    constructor(e=1, t=1, n={}) {
        super(e, t, n),
        this.isWebGLRenderTarget = !0
    }
}
class Eu extends Tt {
    constructor(e=null, t=1, n=1, i=1) {
        super(null),
        this.isDataArrayTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: n,
            depth: i
        },
        this.magFilter = _t,
        this.minFilter = _t,
        this.wrapR = Kn,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1,
        this.layerUpdates = new Set
    }
    addLayerUpdate(e) {
        this.layerUpdates.add(e)
    }
    clearLayerUpdates() {
        this.layerUpdates.clear()
    }
}
class Nd extends Tt {
    constructor(e=null, t=1, n=1, i=1) {
        super(null),
        this.isData3DTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: n,
            depth: i
        },
        this.magFilter = _t,
        this.minFilter = _t,
        this.wrapR = Kn,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
class xt {
    constructor(e=new D(1 / 0,1 / 0,1 / 0), t=new D(-1 / 0,-1 / 0,-1 / 0)) {
        this.isBox3 = !0,
        this.min = e,
        this.max = t
    }
    set(e, t) {
        return this.min.copy(e),
        this.max.copy(t),
        this
    }
    setFromArray(e) {
        this.makeEmpty();
        for (let t = 0, n = e.length; t < n; t += 3)
            this.expandByPoint(cn.fromArray(e, t));
        return this
    }
    setFromBufferAttribute(e) {
        this.makeEmpty();
        for (let t = 0, n = e.count; t < n; t++)
            this.expandByPoint(cn.fromBufferAttribute(e, t));
        return this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, n = e.length; t < n; t++)
            this.expandByPoint(e[t]);
        return this
    }
    setFromCenterAndSize(e, t) {
        const n = cn.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(n),
        this.max.copy(e).add(n),
        this
    }
    setFromObject(e, t=!1) {
        return this.makeEmpty(),
        this.expandByObject(e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min),
        this.max.copy(e.max),
        this
    }
    makeEmpty() {
        return this.min.x = this.min.y = this.min.z = 1 / 0,
        this.max.x = this.max.y = this.max.z = -1 / 0,
        this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e),
        this.max.max(e),
        this
    }
    expandByVector(e) {
        return this.min.sub(e),
        this.max.add(e),
        this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e),
        this.max.addScalar(e),
        this
    }
    expandByObject(e, t=!1) {
        e.updateWorldMatrix(!1, !1);
        const n = e.geometry;
        if (n !== void 0) {
            const s = n.getAttribute("position");
            if (t === !0 && s !== void 0 && e.isInstancedMesh !== !0)
                for (let o = 0, a = s.count; o < a; o++)
                    e.isMesh === !0 ? e.getVertexPosition(o, cn) : cn.fromBufferAttribute(s, o),
                    cn.applyMatrix4(e.matrixWorld),
                    this.expandByPoint(cn);
            else
                e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(),
                js.copy(e.boundingBox)) : (n.boundingBox === null && n.computeBoundingBox(),
                js.copy(n.boundingBox)),
                js.applyMatrix4(e.matrixWorld),
                this.union(js)
        }
        const i = e.children;
        for (let s = 0, o = i.length; s < o; s++)
            this.expandByObject(i[s], t);
        return this
    }
    containsPoint(e) {
        return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
    }
    getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
    }
    intersectsBox(e) {
        return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z
    }
    intersectsSphere(e) {
        return this.clampPoint(e.center, cn),
        cn.distanceToSquared(e.center) <= e.radius * e.radius
    }
    intersectsPlane(e) {
        let t, n;
        return e.normal.x > 0 ? (t = e.normal.x * this.min.x,
        n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
        n = e.normal.x * this.min.x),
        e.normal.y > 0 ? (t += e.normal.y * this.min.y,
        n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
        n += e.normal.y * this.min.y),
        e.normal.z > 0 ? (t += e.normal.z * this.min.z,
        n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
        n += e.normal.z * this.min.z),
        t <= -e.constant && n >= -e.constant
    }
    intersectsTriangle(e) {
        if (this.isEmpty())
            return !1;
        this.getCenter(rs),
        ks.subVectors(this.max, rs),
        wi.subVectors(e.a, rs),
        Si.subVectors(e.b, rs),
        Ti.subVectors(e.c, rs),
        Xn.subVectors(Si, wi),
        Gn.subVectors(Ti, Si),
        si.subVectors(wi, Ti);
        let t = [0, -Xn.z, Xn.y, 0, -Gn.z, Gn.y, 0, -si.z, si.y, Xn.z, 0, -Xn.x, Gn.z, 0, -Gn.x, si.z, 0, -si.x, -Xn.y, Xn.x, 0, -Gn.y, Gn.x, 0, -si.y, si.x, 0];
        return !io(t, wi, Si, Ti, ks) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        !io(t, wi, Si, Ti, ks)) ? !1 : (Ys.crossVectors(Xn, Gn),
        t = [Ys.x, Ys.y, Ys.z],
        io(t, wi, Si, Ti, ks))
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return this.clampPoint(e, cn).distanceTo(e)
    }
    getBoundingSphere(e) {
        return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center),
        e.radius = this.getSize(cn).length() * .5),
        e
    }
    intersect(e) {
        return this.min.max(e.min),
        this.max.min(e.max),
        this.isEmpty() && this.makeEmpty(),
        this
    }
    union(e) {
        return this.min.min(e.min),
        this.max.max(e.max),
        this
    }
    applyMatrix4(e) {
        return this.isEmpty() ? this : (En[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        En[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        En[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        En[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        En[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        En[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        En[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        En[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(En),
        this)
    }
    translate(e) {
        return this.min.add(e),
        this.max.add(e),
        this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
    toJSON() {
        return {
            min: this.min.toArray(),
            max: this.max.toArray()
        }
    }
    fromJSON(e) {
        return this.min.fromArray(e.min),
        this.max.fromArray(e.max),
        this
    }
}
const En = [new D, new D, new D, new D, new D, new D, new D, new D]
  , cn = new D
  , js = new xt
  , wi = new D
  , Si = new D
  , Ti = new D
  , Xn = new D
  , Gn = new D
  , si = new D
  , rs = new D
  , ks = new D
  , Ys = new D
  , ri = new D;
function io(r, e, t, n, i) {
    for (let s = 0, o = r.length - 3; s <= o; s += 3) {
        ri.fromArray(r, s);
        const a = i.x * Math.abs(ri.x) + i.y * Math.abs(ri.y) + i.z * Math.abs(ri.z)
          , c = e.dot(ri)
          , l = t.dot(ri)
          , u = n.dot(ri);
        if (Math.max(-Math.max(c, l, u), Math.min(c, l, u)) > a)
            return !1
    }
    return !0
}
const Od = new xt
  , os = new D
  , so = new D;
class rn {
    constructor(e=new D, t=-1) {
        this.isSphere = !0,
        this.center = e,
        this.radius = t
    }
    set(e, t) {
        return this.center.copy(e),
        this.radius = t,
        this
    }
    setFromPoints(e, t) {
        const n = this.center;
        t !== void 0 ? n.copy(t) : Od.setFromPoints(e).getCenter(n);
        let i = 0;
        for (let s = 0, o = e.length; s < o; s++)
            i = Math.max(i, n.distanceToSquared(e[s]));
        return this.radius = Math.sqrt(i),
        this
    }
    copy(e) {
        return this.center.copy(e.center),
        this.radius = e.radius,
        this
    }
    isEmpty() {
        return this.radius < 0
    }
    makeEmpty() {
        return this.center.set(0, 0, 0),
        this.radius = -1,
        this
    }
    containsPoint(e) {
        return e.distanceToSquared(this.center) <= this.radius * this.radius
    }
    distanceToPoint(e) {
        return e.distanceTo(this.center) - this.radius
    }
    intersectsSphere(e) {
        const t = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= t * t
    }
    intersectsBox(e) {
        return e.intersectsSphere(this)
    }
    intersectsPlane(e) {
        return Math.abs(e.distanceToPoint(this.center)) <= this.radius
    }
    clampPoint(e, t) {
        const n = this.center.distanceToSquared(e);
        return t.copy(e),
        n > this.radius * this.radius && (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
        t
    }
    getBoundingBox(e) {
        return this.isEmpty() ? (e.makeEmpty(),
        e) : (e.set(this.center, this.center),
        e.expandByScalar(this.radius),
        e)
    }
    applyMatrix4(e) {
        return this.center.applyMatrix4(e),
        this.radius = this.radius * e.getMaxScaleOnAxis(),
        this
    }
    translate(e) {
        return this.center.add(e),
        this
    }
    expandByPoint(e) {
        if (this.isEmpty())
            return this.center.copy(e),
            this.radius = 0,
            this;
        os.subVectors(e, this.center);
        const t = os.lengthSq();
        if (t > this.radius * this.radius) {
            const n = Math.sqrt(t)
              , i = (n - this.radius) * .5;
            this.center.addScaledVector(os, i / n),
            this.radius += i
        }
        return this
    }
    union(e) {
        return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e),
        this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (so.subVectors(e.center, this.center).setLength(e.radius),
        this.expandByPoint(os.copy(e.center).add(so)),
        this.expandByPoint(os.copy(e.center).sub(so))),
        this)
    }
    equals(e) {
        return e.center.equals(this.center) && e.radius === this.radius
    }
    clone() {
        return new this.constructor().copy(this)
    }
    toJSON() {
        return {
            radius: this.radius,
            center: this.center.toArray()
        }
    }
    fromJSON(e) {
        return this.radius = e.radius,
        this.center.fromArray(e.center),
        this
    }
}
const Pn = new D
  , ro = new D
  , qs = new D
  , Vn = new D
  , oo = new D
  , Zs = new D
  , ao = new D;
class _s {
    constructor(e=new D, t=new D(0,0,-1)) {
        this.origin = e,
        this.direction = t
    }
    set(e, t) {
        return this.origin.copy(e),
        this.direction.copy(t),
        this
    }
    copy(e) {
        return this.origin.copy(e.origin),
        this.direction.copy(e.direction),
        this
    }
    at(e, t) {
        return t.copy(this.origin).addScaledVector(this.direction, e)
    }
    lookAt(e) {
        return this.direction.copy(e).sub(this.origin).normalize(),
        this
    }
    recast(e) {
        return this.origin.copy(this.at(e, Pn)),
        this
    }
    closestPointToPoint(e, t) {
        t.subVectors(e, this.origin);
        const n = t.dot(this.direction);
        return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n)
    }
    distanceToPoint(e) {
        return Math.sqrt(this.distanceSqToPoint(e))
    }
    distanceSqToPoint(e) {
        const t = Pn.subVectors(e, this.origin).dot(this.direction);
        return t < 0 ? this.origin.distanceToSquared(e) : (Pn.copy(this.origin).addScaledVector(this.direction, t),
        Pn.distanceToSquared(e))
    }
    distanceSqToSegment(e, t, n, i) {
        ro.copy(e).add(t).multiplyScalar(.5),
        qs.copy(t).sub(e).normalize(),
        Vn.copy(this.origin).sub(ro);
        const s = e.distanceTo(t) * .5
          , o = -this.direction.dot(qs)
          , a = Vn.dot(this.direction)
          , c = -Vn.dot(qs)
          , l = Vn.lengthSq()
          , u = Math.abs(1 - o * o);
        let h, d, f, m;
        if (u > 0)
            if (h = o * c - a,
            d = o * a - c,
            m = s * u,
            h >= 0)
                if (d >= -m)
                    if (d <= m) {
                        const g = 1 / u;
                        h *= g,
                        d *= g,
                        f = h * (h + o * d + 2 * a) + d * (o * h + d + 2 * c) + l
                    } else
                        d = s,
                        h = Math.max(0, -(o * d + a)),
                        f = -h * h + d * (d + 2 * c) + l;
                else
                    d = -s,
                    h = Math.max(0, -(o * d + a)),
                    f = -h * h + d * (d + 2 * c) + l;
            else
                d <= -m ? (h = Math.max(0, -(-o * s + a)),
                d = h > 0 ? -s : Math.min(Math.max(-s, -c), s),
                f = -h * h + d * (d + 2 * c) + l) : d <= m ? (h = 0,
                d = Math.min(Math.max(-s, -c), s),
                f = d * (d + 2 * c) + l) : (h = Math.max(0, -(o * s + a)),
                d = h > 0 ? s : Math.min(Math.max(-s, -c), s),
                f = -h * h + d * (d + 2 * c) + l);
        else
            d = o > 0 ? -s : s,
            h = Math.max(0, -(o * d + a)),
            f = -h * h + d * (d + 2 * c) + l;
        return n && n.copy(this.origin).addScaledVector(this.direction, h),
        i && i.copy(ro).addScaledVector(qs, d),
        f
    }
    intersectSphere(e, t) {
        Pn.subVectors(e.center, this.origin);
        const n = Pn.dot(this.direction)
          , i = Pn.dot(Pn) - n * n
          , s = e.radius * e.radius;
        if (i > s)
            return null;
        const o = Math.sqrt(s - i)
          , a = n - o
          , c = n + o;
        return c < 0 ? null : a < 0 ? this.at(c, t) : this.at(a, t)
    }
    intersectsSphere(e) {
        return e.radius < 0 ? !1 : this.distanceSqToPoint(e.center) <= e.radius * e.radius
    }
    distanceToPlane(e) {
        const t = e.normal.dot(this.direction);
        if (t === 0)
            return e.distanceToPoint(this.origin) === 0 ? 0 : null;
        const n = -(this.origin.dot(e.normal) + e.constant) / t;
        return n >= 0 ? n : null
    }
    intersectPlane(e, t) {
        const n = this.distanceToPlane(e);
        return n === null ? null : this.at(n, t)
    }
    intersectsPlane(e) {
        const t = e.distanceToPoint(this.origin);
        return t === 0 || e.normal.dot(this.direction) * t < 0
    }
    intersectBox(e, t) {
        let n, i, s, o, a, c;
        const l = 1 / this.direction.x
          , u = 1 / this.direction.y
          , h = 1 / this.direction.z
          , d = this.origin;
        return l >= 0 ? (n = (e.min.x - d.x) * l,
        i = (e.max.x - d.x) * l) : (n = (e.max.x - d.x) * l,
        i = (e.min.x - d.x) * l),
        u >= 0 ? (s = (e.min.y - d.y) * u,
        o = (e.max.y - d.y) * u) : (s = (e.max.y - d.y) * u,
        o = (e.min.y - d.y) * u),
        n > o || s > i || ((s > n || isNaN(n)) && (n = s),
        (o < i || isNaN(i)) && (i = o),
        h >= 0 ? (a = (e.min.z - d.z) * h,
        c = (e.max.z - d.z) * h) : (a = (e.max.z - d.z) * h,
        c = (e.min.z - d.z) * h),
        n > c || a > i) || ((a > n || n !== n) && (n = a),
        (c < i || i !== i) && (i = c),
        i < 0) ? null : this.at(n >= 0 ? n : i, t)
    }
    intersectsBox(e) {
        return this.intersectBox(e, Pn) !== null
    }
    intersectTriangle(e, t, n, i, s) {
        oo.subVectors(t, e),
        Zs.subVectors(n, e),
        ao.crossVectors(oo, Zs);
        let o = this.direction.dot(ao), a;
        if (o > 0) {
            if (i)
                return null;
            a = 1
        } else if (o < 0)
            a = -1,
            o = -o;
        else
            return null;
        Vn.subVectors(this.origin, e);
        const c = a * this.direction.dot(Zs.crossVectors(Vn, Zs));
        if (c < 0)
            return null;
        const l = a * this.direction.dot(oo.cross(Vn));
        if (l < 0 || c + l > o)
            return null;
        const u = -a * Vn.dot(ao);
        return u < 0 ? null : this.at(u / o, s)
    }
    applyMatrix4(e) {
        return this.origin.applyMatrix4(e),
        this.direction.transformDirection(e),
        this
    }
    equals(e) {
        return e.origin.equals(this.origin) && e.direction.equals(this.direction)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class We {
    constructor(e, t, n, i, s, o, a, c, l, u, h, d, f, m, g, A) {
        We.prototype.isMatrix4 = !0,
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        e !== void 0 && this.set(e, t, n, i, s, o, a, c, l, u, h, d, f, m, g, A)
    }
    set(e, t, n, i, s, o, a, c, l, u, h, d, f, m, g, A) {
        const p = this.elements;
        return p[0] = e,
        p[4] = t,
        p[8] = n,
        p[12] = i,
        p[1] = s,
        p[5] = o,
        p[9] = a,
        p[13] = c,
        p[2] = l,
        p[6] = u,
        p[10] = h,
        p[14] = d,
        p[3] = f,
        p[7] = m,
        p[11] = g,
        p[15] = A,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    clone() {
        return new We().fromArray(this.elements)
    }
    copy(e) {
        const t = this.elements
          , n = e.elements;
        return t[0] = n[0],
        t[1] = n[1],
        t[2] = n[2],
        t[3] = n[3],
        t[4] = n[4],
        t[5] = n[5],
        t[6] = n[6],
        t[7] = n[7],
        t[8] = n[8],
        t[9] = n[9],
        t[10] = n[10],
        t[11] = n[11],
        t[12] = n[12],
        t[13] = n[13],
        t[14] = n[14],
        t[15] = n[15],
        this
    }
    copyPosition(e) {
        const t = this.elements
          , n = e.elements;
        return t[12] = n[12],
        t[13] = n[13],
        t[14] = n[14],
        this
    }
    setFromMatrix3(e) {
        const t = e.elements;
        return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1),
        this
    }
    extractBasis(e, t, n) {
        return e.setFromMatrixColumn(this, 0),
        t.setFromMatrixColumn(this, 1),
        n.setFromMatrixColumn(this, 2),
        this
    }
    makeBasis(e, t, n) {
        return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1),
        this
    }
    extractRotation(e) {
        const t = this.elements
          , n = e.elements
          , i = 1 / Ei.setFromMatrixColumn(e, 0).length()
          , s = 1 / Ei.setFromMatrixColumn(e, 1).length()
          , o = 1 / Ei.setFromMatrixColumn(e, 2).length();
        return t[0] = n[0] * i,
        t[1] = n[1] * i,
        t[2] = n[2] * i,
        t[3] = 0,
        t[4] = n[4] * s,
        t[5] = n[5] * s,
        t[6] = n[6] * s,
        t[7] = 0,
        t[8] = n[8] * o,
        t[9] = n[9] * o,
        t[10] = n[10] * o,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromEuler(e) {
        const t = this.elements
          , n = e.x
          , i = e.y
          , s = e.z
          , o = Math.cos(n)
          , a = Math.sin(n)
          , c = Math.cos(i)
          , l = Math.sin(i)
          , u = Math.cos(s)
          , h = Math.sin(s);
        if (e.order === "XYZ") {
            const d = o * u
              , f = o * h
              , m = a * u
              , g = a * h;
            t[0] = c * u,
            t[4] = -c * h,
            t[8] = l,
            t[1] = f + m * l,
            t[5] = d - g * l,
            t[9] = -a * c,
            t[2] = g - d * l,
            t[6] = m + f * l,
            t[10] = o * c
        } else if (e.order === "YXZ") {
            const d = c * u
              , f = c * h
              , m = l * u
              , g = l * h;
            t[0] = d + g * a,
            t[4] = m * a - f,
            t[8] = o * l,
            t[1] = o * h,
            t[5] = o * u,
            t[9] = -a,
            t[2] = f * a - m,
            t[6] = g + d * a,
            t[10] = o * c
        } else if (e.order === "ZXY") {
            const d = c * u
              , f = c * h
              , m = l * u
              , g = l * h;
            t[0] = d - g * a,
            t[4] = -o * h,
            t[8] = m + f * a,
            t[1] = f + m * a,
            t[5] = o * u,
            t[9] = g - d * a,
            t[2] = -o * l,
            t[6] = a,
            t[10] = o * c
        } else if (e.order === "ZYX") {
            const d = o * u
              , f = o * h
              , m = a * u
              , g = a * h;
            t[0] = c * u,
            t[4] = m * l - f,
            t[8] = d * l + g,
            t[1] = c * h,
            t[5] = g * l + d,
            t[9] = f * l - m,
            t[2] = -l,
            t[6] = a * c,
            t[10] = o * c
        } else if (e.order === "YZX") {
            const d = o * c
              , f = o * l
              , m = a * c
              , g = a * l;
            t[0] = c * u,
            t[4] = g - d * h,
            t[8] = m * h + f,
            t[1] = h,
            t[5] = o * u,
            t[9] = -a * u,
            t[2] = -l * u,
            t[6] = f * h + m,
            t[10] = d - g * h
        } else if (e.order === "XZY") {
            const d = o * c
              , f = o * l
              , m = a * c
              , g = a * l;
            t[0] = c * u,
            t[4] = -h,
            t[8] = l * u,
            t[1] = d * h + g,
            t[5] = o * u,
            t[9] = f * h - m,
            t[2] = m * h - f,
            t[6] = a * u,
            t[10] = g * h + d
        }
        return t[3] = 0,
        t[7] = 0,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromQuaternion(e) {
        return this.compose(zd, e, Id)
    }
    lookAt(e, t, n) {
        const i = this.elements;
        return jt.subVectors(e, t),
        jt.lengthSq() === 0 && (jt.z = 1),
        jt.normalize(),
        Wn.crossVectors(n, jt),
        Wn.lengthSq() === 0 && (Math.abs(n.z) === 1 ? jt.x += 1e-4 : jt.z += 1e-4,
        jt.normalize(),
        Wn.crossVectors(n, jt)),
        Wn.normalize(),
        Ks.crossVectors(jt, Wn),
        i[0] = Wn.x,
        i[4] = Ks.x,
        i[8] = jt.x,
        i[1] = Wn.y,
        i[5] = Ks.y,
        i[9] = jt.y,
        i[2] = Wn.z,
        i[6] = Ks.z,
        i[10] = jt.z,
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const n = e.elements
          , i = t.elements
          , s = this.elements
          , o = n[0]
          , a = n[4]
          , c = n[8]
          , l = n[12]
          , u = n[1]
          , h = n[5]
          , d = n[9]
          , f = n[13]
          , m = n[2]
          , g = n[6]
          , A = n[10]
          , p = n[14]
          , S = n[3]
          , w = n[7]
          , b = n[11]
          , B = n[15]
          , z = i[0]
          , I = i[4]
          , H = i[8]
          , P = i[12]
          , T = i[1]
          , _ = i[5]
          , re = i[9]
          , k = i[13]
          , U = i[2]
          , F = i[6]
          , O = i[10]
          , y = i[14]
          , v = i[3]
          , L = i[7]
          , R = i[11]
          , C = i[15];
        return s[0] = o * z + a * T + c * U + l * v,
        s[4] = o * I + a * _ + c * F + l * L,
        s[8] = o * H + a * re + c * O + l * R,
        s[12] = o * P + a * k + c * y + l * C,
        s[1] = u * z + h * T + d * U + f * v,
        s[5] = u * I + h * _ + d * F + f * L,
        s[9] = u * H + h * re + d * O + f * R,
        s[13] = u * P + h * k + d * y + f * C,
        s[2] = m * z + g * T + A * U + p * v,
        s[6] = m * I + g * _ + A * F + p * L,
        s[10] = m * H + g * re + A * O + p * R,
        s[14] = m * P + g * k + A * y + p * C,
        s[3] = S * z + w * T + b * U + B * v,
        s[7] = S * I + w * _ + b * F + B * L,
        s[11] = S * H + w * re + b * O + B * R,
        s[15] = S * P + w * k + b * y + B * C,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[4] *= e,
        t[8] *= e,
        t[12] *= e,
        t[1] *= e,
        t[5] *= e,
        t[9] *= e,
        t[13] *= e,
        t[2] *= e,
        t[6] *= e,
        t[10] *= e,
        t[14] *= e,
        t[3] *= e,
        t[7] *= e,
        t[11] *= e,
        t[15] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , n = e[4]
          , i = e[8]
          , s = e[12]
          , o = e[1]
          , a = e[5]
          , c = e[9]
          , l = e[13]
          , u = e[2]
          , h = e[6]
          , d = e[10]
          , f = e[14]
          , m = e[3]
          , g = e[7]
          , A = e[11]
          , p = e[15];
        return m * (+s * c * h - i * l * h - s * a * d + n * l * d + i * a * f - n * c * f) + g * (+t * c * f - t * l * d + s * o * d - i * o * f + i * l * u - s * c * u) + A * (+t * l * h - t * a * f - s * o * h + n * o * f + s * a * u - n * l * u) + p * (-i * a * u - t * c * h + t * a * d + i * o * h - n * o * d + n * c * u)
    }
    transpose() {
        const e = this.elements;
        let t;
        return t = e[1],
        e[1] = e[4],
        e[4] = t,
        t = e[2],
        e[2] = e[8],
        e[8] = t,
        t = e[6],
        e[6] = e[9],
        e[9] = t,
        t = e[3],
        e[3] = e[12],
        e[12] = t,
        t = e[7],
        e[7] = e[13],
        e[13] = t,
        t = e[11],
        e[11] = e[14],
        e[14] = t,
        this
    }
    setPosition(e, t, n) {
        const i = this.elements;
        return e.isVector3 ? (i[12] = e.x,
        i[13] = e.y,
        i[14] = e.z) : (i[12] = e,
        i[13] = t,
        i[14] = n),
        this
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , n = e[1]
          , i = e[2]
          , s = e[3]
          , o = e[4]
          , a = e[5]
          , c = e[6]
          , l = e[7]
          , u = e[8]
          , h = e[9]
          , d = e[10]
          , f = e[11]
          , m = e[12]
          , g = e[13]
          , A = e[14]
          , p = e[15]
          , S = h * A * l - g * d * l + g * c * f - a * A * f - h * c * p + a * d * p
          , w = m * d * l - u * A * l - m * c * f + o * A * f + u * c * p - o * d * p
          , b = u * g * l - m * h * l + m * a * f - o * g * f - u * a * p + o * h * p
          , B = m * h * c - u * g * c - m * a * d + o * g * d + u * a * A - o * h * A
          , z = t * S + n * w + i * b + s * B;
        if (z === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const I = 1 / z;
        return e[0] = S * I,
        e[1] = (g * d * s - h * A * s - g * i * f + n * A * f + h * i * p - n * d * p) * I,
        e[2] = (a * A * s - g * c * s + g * i * l - n * A * l - a * i * p + n * c * p) * I,
        e[3] = (h * c * s - a * d * s - h * i * l + n * d * l + a * i * f - n * c * f) * I,
        e[4] = w * I,
        e[5] = (u * A * s - m * d * s + m * i * f - t * A * f - u * i * p + t * d * p) * I,
        e[6] = (m * c * s - o * A * s - m * i * l + t * A * l + o * i * p - t * c * p) * I,
        e[7] = (o * d * s - u * c * s + u * i * l - t * d * l - o * i * f + t * c * f) * I,
        e[8] = b * I,
        e[9] = (m * h * s - u * g * s - m * n * f + t * g * f + u * n * p - t * h * p) * I,
        e[10] = (o * g * s - m * a * s + m * n * l - t * g * l - o * n * p + t * a * p) * I,
        e[11] = (u * a * s - o * h * s - u * n * l + t * h * l + o * n * f - t * a * f) * I,
        e[12] = B * I,
        e[13] = (u * g * i - m * h * i + m * n * d - t * g * d - u * n * A + t * h * A) * I,
        e[14] = (m * a * i - o * g * i - m * n * c + t * g * c + o * n * A - t * a * A) * I,
        e[15] = (o * h * i - u * a * i + u * n * c - t * h * c - o * n * d + t * a * d) * I,
        this
    }
    scale(e) {
        const t = this.elements
          , n = e.x
          , i = e.y
          , s = e.z;
        return t[0] *= n,
        t[4] *= i,
        t[8] *= s,
        t[1] *= n,
        t[5] *= i,
        t[9] *= s,
        t[2] *= n,
        t[6] *= i,
        t[10] *= s,
        t[3] *= n,
        t[7] *= i,
        t[11] *= s,
        this
    }
    getMaxScaleOnAxis() {
        const e = this.elements
          , t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
          , n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
          , i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(t, n, i))
    }
    makeTranslation(e, t, n) {
        return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1),
        this
    }
    makeRotationX(e) {
        const t = Math.cos(e)
          , n = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationY(e) {
        const t = Math.cos(e)
          , n = Math.sin(e);
        return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationZ(e) {
        const t = Math.cos(e)
          , n = Math.sin(e);
        return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    makeRotationAxis(e, t) {
        const n = Math.cos(t)
          , i = Math.sin(t)
          , s = 1 - n
          , o = e.x
          , a = e.y
          , c = e.z
          , l = s * o
          , u = s * a;
        return this.set(l * o + n, l * a - i * c, l * c + i * a, 0, l * a + i * c, u * a + n, u * c - i * o, 0, l * c - i * a, u * c + i * o, s * c * c + n, 0, 0, 0, 0, 1),
        this
    }
    makeScale(e, t, n) {
        return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1),
        this
    }
    makeShear(e, t, n, i, s, o) {
        return this.set(1, n, s, 0, e, 1, o, 0, t, i, 1, 0, 0, 0, 0, 1),
        this
    }
    compose(e, t, n) {
        const i = this.elements
          , s = t._x
          , o = t._y
          , a = t._z
          , c = t._w
          , l = s + s
          , u = o + o
          , h = a + a
          , d = s * l
          , f = s * u
          , m = s * h
          , g = o * u
          , A = o * h
          , p = a * h
          , S = c * l
          , w = c * u
          , b = c * h
          , B = n.x
          , z = n.y
          , I = n.z;
        return i[0] = (1 - (g + p)) * B,
        i[1] = (f + b) * B,
        i[2] = (m - w) * B,
        i[3] = 0,
        i[4] = (f - b) * z,
        i[5] = (1 - (d + p)) * z,
        i[6] = (A + S) * z,
        i[7] = 0,
        i[8] = (m + w) * I,
        i[9] = (A - S) * I,
        i[10] = (1 - (d + g)) * I,
        i[11] = 0,
        i[12] = e.x,
        i[13] = e.y,
        i[14] = e.z,
        i[15] = 1,
        this
    }
    decompose(e, t, n) {
        const i = this.elements;
        let s = Ei.set(i[0], i[1], i[2]).length();
        const o = Ei.set(i[4], i[5], i[6]).length()
          , a = Ei.set(i[8], i[9], i[10]).length();
        this.determinant() < 0 && (s = -s),
        e.x = i[12],
        e.y = i[13],
        e.z = i[14],
        ln.copy(this);
        const l = 1 / s
          , u = 1 / o
          , h = 1 / a;
        return ln.elements[0] *= l,
        ln.elements[1] *= l,
        ln.elements[2] *= l,
        ln.elements[4] *= u,
        ln.elements[5] *= u,
        ln.elements[6] *= u,
        ln.elements[8] *= h,
        ln.elements[9] *= h,
        ln.elements[10] *= h,
        t.setFromRotationMatrix(ln),
        n.x = s,
        n.y = o,
        n.z = a,
        this
    }
    makePerspective(e, t, n, i, s, o, a=Un) {
        const c = this.elements
          , l = 2 * s / (t - e)
          , u = 2 * s / (n - i)
          , h = (t + e) / (t - e)
          , d = (n + i) / (n - i);
        let f, m;
        if (a === Un)
            f = -(o + s) / (o - s),
            m = -2 * o * s / (o - s);
        else if (a === Hr)
            f = -o / (o - s),
            m = -o * s / (o - s);
        else
            throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
        return c[0] = l,
        c[4] = 0,
        c[8] = h,
        c[12] = 0,
        c[1] = 0,
        c[5] = u,
        c[9] = d,
        c[13] = 0,
        c[2] = 0,
        c[6] = 0,
        c[10] = f,
        c[14] = m,
        c[3] = 0,
        c[7] = 0,
        c[11] = -1,
        c[15] = 0,
        this
    }
    makeOrthographic(e, t, n, i, s, o, a=Un) {
        const c = this.elements
          , l = 1 / (t - e)
          , u = 1 / (n - i)
          , h = 1 / (o - s)
          , d = (t + e) * l
          , f = (n + i) * u;
        let m, g;
        if (a === Un)
            m = (o + s) * h,
            g = -2 * h;
        else if (a === Hr)
            m = s * h,
            g = -1 * h;
        else
            throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
        return c[0] = 2 * l,
        c[4] = 0,
        c[8] = 0,
        c[12] = -d,
        c[1] = 0,
        c[5] = 2 * u,
        c[9] = 0,
        c[13] = -f,
        c[2] = 0,
        c[6] = 0,
        c[10] = g,
        c[14] = -m,
        c[3] = 0,
        c[7] = 0,
        c[11] = 0,
        c[15] = 1,
        this
    }
    equals(e) {
        const t = this.elements
          , n = e.elements;
        for (let i = 0; i < 16; i++)
            if (t[i] !== n[i])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let n = 0; n < 16; n++)
            this.elements[n] = e[n + t];
        return this
    }
    toArray(e=[], t=0) {
        const n = this.elements;
        return e[t] = n[0],
        e[t + 1] = n[1],
        e[t + 2] = n[2],
        e[t + 3] = n[3],
        e[t + 4] = n[4],
        e[t + 5] = n[5],
        e[t + 6] = n[6],
        e[t + 7] = n[7],
        e[t + 8] = n[8],
        e[t + 9] = n[9],
        e[t + 10] = n[10],
        e[t + 11] = n[11],
        e[t + 12] = n[12],
        e[t + 13] = n[13],
        e[t + 14] = n[14],
        e[t + 15] = n[15],
        e
    }
}
const Ei = new D
  , ln = new We
  , zd = new D(0,0,0)
  , Id = new D(1,1,1)
  , Wn = new D
  , Ks = new D
  , jt = new D
  , Fc = new We
  , _c = new sn;
class Ft {
    constructor(e=0, t=0, n=0, i=Ft.DEFAULT_ORDER) {
        this.isEuler = !0,
        this._x = e,
        this._y = t,
        this._z = n,
        this._order = i
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get order() {
        return this._order
    }
    set order(e) {
        this._order = e,
        this._onChangeCallback()
    }
    set(e, t, n, i=this._order) {
        return this._x = e,
        this._y = t,
        this._z = n,
        this._order = i,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._order)
    }
    copy(e) {
        return this._x = e._x,
        this._y = e._y,
        this._z = e._z,
        this._order = e._order,
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e, t=this._order, n=!0) {
        const i = e.elements
          , s = i[0]
          , o = i[4]
          , a = i[8]
          , c = i[1]
          , l = i[5]
          , u = i[9]
          , h = i[2]
          , d = i[6]
          , f = i[10];
        switch (t) {
        case "XYZ":
            this._y = Math.asin(Ke(a, -1, 1)),
            Math.abs(a) < .9999999 ? (this._x = Math.atan2(-u, f),
            this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(d, l),
            this._z = 0);
            break;
        case "YXZ":
            this._x = Math.asin(-Ke(u, -1, 1)),
            Math.abs(u) < .9999999 ? (this._y = Math.atan2(a, f),
            this._z = Math.atan2(c, l)) : (this._y = Math.atan2(-h, s),
            this._z = 0);
            break;
        case "ZXY":
            this._x = Math.asin(Ke(d, -1, 1)),
            Math.abs(d) < .9999999 ? (this._y = Math.atan2(-h, f),
            this._z = Math.atan2(-o, l)) : (this._y = 0,
            this._z = Math.atan2(c, s));
            break;
        case "ZYX":
            this._y = Math.asin(-Ke(h, -1, 1)),
            Math.abs(h) < .9999999 ? (this._x = Math.atan2(d, f),
            this._z = Math.atan2(c, s)) : (this._x = 0,
            this._z = Math.atan2(-o, l));
            break;
        case "YZX":
            this._z = Math.asin(Ke(c, -1, 1)),
            Math.abs(c) < .9999999 ? (this._x = Math.atan2(-u, l),
            this._y = Math.atan2(-h, s)) : (this._x = 0,
            this._y = Math.atan2(a, f));
            break;
        case "XZY":
            this._z = Math.asin(-Ke(o, -1, 1)),
            Math.abs(o) < .9999999 ? (this._x = Math.atan2(d, l),
            this._y = Math.atan2(a, s)) : (this._x = Math.atan2(-u, f),
            this._y = 0);
            break;
        default:
            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
        }
        return this._order = t,
        n === !0 && this._onChangeCallback(),
        this
    }
    setFromQuaternion(e, t, n) {
        return Fc.makeRotationFromQuaternion(e),
        this.setFromRotationMatrix(Fc, t, n)
    }
    setFromVector3(e, t=this._order) {
        return this.set(e.x, e.y, e.z, t)
    }
    reorder(e) {
        return _c.setFromEuler(this),
        this.setFromQuaternion(_c, e)
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
    }
    fromArray(e) {
        return this._x = e[0],
        this._y = e[1],
        this._z = e[2],
        e[3] !== void 0 && (this._order = e[3]),
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._order,
        e
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._order
    }
}
Ft.DEFAULT_ORDER = "XYZ";
class ic {
    constructor() {
        this.mask = 1
    }
    set(e) {
        this.mask = (1 << e | 0) >>> 0
    }
    enable(e) {
        this.mask |= 1 << e | 0
    }
    enableAll() {
        this.mask = -1
    }
    toggle(e) {
        this.mask ^= 1 << e | 0
    }
    disable(e) {
        this.mask &= ~(1 << e | 0)
    }
    disableAll() {
        this.mask = 0
    }
    test(e) {
        return (this.mask & e.mask) !== 0
    }
    isEnabled(e) {
        return (this.mask & (1 << e | 0)) !== 0
    }
}
let Ud = 0;
const Hc = new D
  , Pi = new sn
  , Ln = new We
  , Qs = new D
  , as = new D
  , Bd = new D
  , Fd = new sn
  , Xc = new D(1,0,0)
  , Gc = new D(0,1,0)
  , Vc = new D(0,0,1)
  , Wc = {
    type: "added"
}
  , _d = {
    type: "removed"
}
  , Li = {
    type: "childadded",
    child: null
}
  , co = {
    type: "childremoved",
    child: null
};
class lt extends es {
    constructor() {
        super(),
        this.isObject3D = !0,
        Object.defineProperty(this, "id", {
            value: Ud++
        }),
        this.uuid = nn(),
        this.name = "",
        this.type = "Object3D",
        this.parent = null,
        this.children = [],
        this.up = lt.DEFAULT_UP.clone();
        const e = new D
          , t = new Ft
          , n = new sn
          , i = new D(1,1,1);
        function s() {
            n.setFromEuler(t, !1)
        }
        function o() {
            t.setFromQuaternion(n, void 0, !1)
        }
        t._onChange(s),
        n._onChange(o),
        Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: n
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: i
            },
            modelViewMatrix: {
                value: new We
            },
            normalMatrix: {
                value: new qe
            }
        }),
        this.matrix = new We,
        this.matrixWorld = new We,
        this.matrixAutoUpdate = lt.DEFAULT_MATRIX_AUTO_UPDATE,
        this.matrixWorldAutoUpdate = lt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
        this.matrixWorldNeedsUpdate = !1,
        this.layers = new ic,
        this.visible = !0,
        this.castShadow = !1,
        this.receiveShadow = !1,
        this.frustumCulled = !0,
        this.renderOrder = 0,
        this.animations = [],
        this.customDepthMaterial = void 0,
        this.customDistanceMaterial = void 0,
        this.userData = {}
    }
    onBeforeShadow() {}
    onAfterShadow() {}
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        this.matrix.premultiply(e),
        this.matrix.decompose(this.position, this.quaternion, this.scale)
    }
    applyQuaternion(e) {
        return this.quaternion.premultiply(e),
        this
    }
    setRotationFromAxisAngle(e, t) {
        this.quaternion.setFromAxisAngle(e, t)
    }
    setRotationFromEuler(e) {
        this.quaternion.setFromEuler(e, !0)
    }
    setRotationFromMatrix(e) {
        this.quaternion.setFromRotationMatrix(e)
    }
    setRotationFromQuaternion(e) {
        this.quaternion.copy(e)
    }
    rotateOnAxis(e, t) {
        return Pi.setFromAxisAngle(e, t),
        this.quaternion.multiply(Pi),
        this
    }
    rotateOnWorldAxis(e, t) {
        return Pi.setFromAxisAngle(e, t),
        this.quaternion.premultiply(Pi),
        this
    }
    rotateX(e) {
        return this.rotateOnAxis(Xc, e)
    }
    rotateY(e) {
        return this.rotateOnAxis(Gc, e)
    }
    rotateZ(e) {
        return this.rotateOnAxis(Vc, e)
    }
    translateOnAxis(e, t) {
        return Hc.copy(e).applyQuaternion(this.quaternion),
        this.position.add(Hc.multiplyScalar(t)),
        this
    }
    translateX(e) {
        return this.translateOnAxis(Xc, e)
    }
    translateY(e) {
        return this.translateOnAxis(Gc, e)
    }
    translateZ(e) {
        return this.translateOnAxis(Vc, e)
    }
    localToWorld(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(this.matrixWorld)
    }
    worldToLocal(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(Ln.copy(this.matrixWorld).invert())
    }
    lookAt(e, t, n) {
        e.isVector3 ? Qs.copy(e) : Qs.set(e, t, n);
        const i = this.parent;
        this.updateWorldMatrix(!0, !1),
        as.setFromMatrixPosition(this.matrixWorld),
        this.isCamera || this.isLight ? Ln.lookAt(as, Qs, this.up) : Ln.lookAt(Qs, as, this.up),
        this.quaternion.setFromRotationMatrix(Ln),
        i && (Ln.extractRotation(i.matrixWorld),
        Pi.setFromRotationMatrix(Ln),
        this.quaternion.premultiply(Pi.invert()))
    }
    add(e) {
        if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++)
                this.add(arguments[t]);
            return this
        }
        return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e),
        this) : (e && e.isObject3D ? (e.removeFromParent(),
        e.parent = this,
        this.children.push(e),
        e.dispatchEvent(Wc),
        Li.child = e,
        this.dispatchEvent(Li),
        Li.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
        this)
    }
    remove(e) {
        if (arguments.length > 1) {
            for (let n = 0; n < arguments.length; n++)
                this.remove(arguments[n]);
            return this
        }
        const t = this.children.indexOf(e);
        return t !== -1 && (e.parent = null,
        this.children.splice(t, 1),
        e.dispatchEvent(_d),
        co.child = e,
        this.dispatchEvent(co),
        co.child = null),
        this
    }
    removeFromParent() {
        const e = this.parent;
        return e !== null && e.remove(this),
        this
    }
    clear() {
        return this.remove(...this.children)
    }
    attach(e) {
        return this.updateWorldMatrix(!0, !1),
        Ln.copy(this.matrixWorld).invert(),
        e.parent !== null && (e.parent.updateWorldMatrix(!0, !1),
        Ln.multiply(e.parent.matrixWorld)),
        e.applyMatrix4(Ln),
        e.removeFromParent(),
        e.parent = this,
        this.children.push(e),
        e.updateWorldMatrix(!1, !0),
        e.dispatchEvent(Wc),
        Li.child = e,
        this.dispatchEvent(Li),
        Li.child = null,
        this
    }
    getObjectById(e) {
        return this.getObjectByProperty("id", e)
    }
    getObjectByName(e) {
        return this.getObjectByProperty("name", e)
    }
    getObjectByProperty(e, t) {
        if (this[e] === t)
            return this;
        for (let n = 0, i = this.children.length; n < i; n++) {
            const o = this.children[n].getObjectByProperty(e, t);
            if (o !== void 0)
                return o
        }
    }
    getObjectsByProperty(e, t, n=[]) {
        this[e] === t && n.push(this);
        const i = this.children;
        for (let s = 0, o = i.length; s < o; s++)
            i[s].getObjectsByProperty(e, t, n);
        return n
    }
    getWorldPosition(e) {
        return this.updateWorldMatrix(!0, !1),
        e.setFromMatrixPosition(this.matrixWorld)
    }
    getWorldQuaternion(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(as, e, Bd),
        e
    }
    getWorldScale(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(as, Fd, e),
        e
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(t[8], t[9], t[10]).normalize()
    }
    raycast() {}
    traverse(e) {
        e(this);
        const t = this.children;
        for (let n = 0, i = t.length; n < i; n++)
            t[n].traverse(e)
    }
    traverseVisible(e) {
        if (this.visible === !1)
            return;
        e(this);
        const t = this.children;
        for (let n = 0, i = t.length; n < i; n++)
            t[n].traverseVisible(e)
    }
    traverseAncestors(e) {
        const t = this.parent;
        t !== null && (e(t),
        t.traverseAncestors(e))
    }
    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale),
        this.matrixWorldNeedsUpdate = !0
    }
    updateMatrixWorld(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
        this.matrixWorldNeedsUpdate = !1,
        e = !0);
        const t = this.children;
        for (let n = 0, i = t.length; n < i; n++)
            t[n].updateMatrixWorld(e)
    }
    updateWorldMatrix(e, t) {
        const n = this.parent;
        if (e === !0 && n !== null && n.updateWorldMatrix(!0, !1),
        this.matrixAutoUpdate && this.updateMatrix(),
        this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
        t === !0) {
            const i = this.children;
            for (let s = 0, o = i.length; s < o; s++)
                i[s].updateWorldMatrix(!1, !0)
        }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string"
          , n = {};
        t && (e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
        },
        n.metadata = {
            version: 4.7,
            type: "Object",
            generator: "Object3D.toJSON"
        });
        const i = {};
        i.uuid = this.uuid,
        i.type = this.type,
        this.name !== "" && (i.name = this.name),
        this.castShadow === !0 && (i.castShadow = !0),
        this.receiveShadow === !0 && (i.receiveShadow = !0),
        this.visible === !1 && (i.visible = !1),
        this.frustumCulled === !1 && (i.frustumCulled = !1),
        this.renderOrder !== 0 && (i.renderOrder = this.renderOrder),
        Object.keys(this.userData).length > 0 && (i.userData = this.userData),
        i.layers = this.layers.mask,
        i.matrix = this.matrix.toArray(),
        i.up = this.up.toArray(),
        this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1),
        this.isInstancedMesh && (i.type = "InstancedMesh",
        i.count = this.count,
        i.instanceMatrix = this.instanceMatrix.toJSON(),
        this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON())),
        this.isBatchedMesh && (i.type = "BatchedMesh",
        i.perObjectFrustumCulled = this.perObjectFrustumCulled,
        i.sortObjects = this.sortObjects,
        i.drawRanges = this._drawRanges,
        i.reservedRanges = this._reservedRanges,
        i.geometryInfo = this._geometryInfo.map(a => ({
            ...a,
            boundingBox: a.boundingBox ? a.boundingBox.toJSON() : void 0,
            boundingSphere: a.boundingSphere ? a.boundingSphere.toJSON() : void 0
        })),
        i.instanceInfo = this._instanceInfo.map(a => ({
            ...a
        })),
        i.availableInstanceIds = this._availableInstanceIds.slice(),
        i.availableGeometryIds = this._availableGeometryIds.slice(),
        i.nextIndexStart = this._nextIndexStart,
        i.nextVertexStart = this._nextVertexStart,
        i.geometryCount = this._geometryCount,
        i.maxInstanceCount = this._maxInstanceCount,
        i.maxVertexCount = this._maxVertexCount,
        i.maxIndexCount = this._maxIndexCount,
        i.geometryInitialized = this._geometryInitialized,
        i.matricesTexture = this._matricesTexture.toJSON(e),
        i.indirectTexture = this._indirectTexture.toJSON(e),
        this._colorsTexture !== null && (i.colorsTexture = this._colorsTexture.toJSON(e)),
        this.boundingSphere !== null && (i.boundingSphere = this.boundingSphere.toJSON()),
        this.boundingBox !== null && (i.boundingBox = this.boundingBox.toJSON()));
        function s(a, c) {
            return a[c.uuid] === void 0 && (a[c.uuid] = c.toJSON(e)),
            c.uuid
        }
        if (this.isScene)
            this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)),
            this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (i.environment = this.environment.toJSON(e).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
            i.geometry = s(e.geometries, this.geometry);
            const a = this.geometry.parameters;
            if (a !== void 0 && a.shapes !== void 0) {
                const c = a.shapes;
                if (Array.isArray(c))
                    for (let l = 0, u = c.length; l < u; l++) {
                        const h = c[l];
                        s(e.shapes, h)
                    }
                else
                    s(e.shapes, c)
            }
        }
        if (this.isSkinnedMesh && (i.bindMode = this.bindMode,
        i.bindMatrix = this.bindMatrix.toArray(),
        this.skeleton !== void 0 && (s(e.skeletons, this.skeleton),
        i.skeleton = this.skeleton.uuid)),
        this.material !== void 0)
            if (Array.isArray(this.material)) {
                const a = [];
                for (let c = 0, l = this.material.length; c < l; c++)
                    a.push(s(e.materials, this.material[c]));
                i.material = a
            } else
                i.material = s(e.materials, this.material);
        if (this.children.length > 0) {
            i.children = [];
            for (let a = 0; a < this.children.length; a++)
                i.children.push(this.children[a].toJSON(e).object)
        }
        if (this.animations.length > 0) {
            i.animations = [];
            for (let a = 0; a < this.animations.length; a++) {
                const c = this.animations[a];
                i.animations.push(s(e.animations, c))
            }
        }
        if (t) {
            const a = o(e.geometries)
              , c = o(e.materials)
              , l = o(e.textures)
              , u = o(e.images)
              , h = o(e.shapes)
              , d = o(e.skeletons)
              , f = o(e.animations)
              , m = o(e.nodes);
            a.length > 0 && (n.geometries = a),
            c.length > 0 && (n.materials = c),
            l.length > 0 && (n.textures = l),
            u.length > 0 && (n.images = u),
            h.length > 0 && (n.shapes = h),
            d.length > 0 && (n.skeletons = d),
            f.length > 0 && (n.animations = f),
            m.length > 0 && (n.nodes = m)
        }
        return n.object = i,
        n;
        function o(a) {
            const c = [];
            for (const l in a) {
                const u = a[l];
                delete u.metadata,
                c.push(u)
            }
            return c
        }
    }
    clone(e) {
        return new this.constructor().copy(this, e)
    }
    copy(e, t=!0) {
        if (this.name = e.name,
        this.up.copy(e.up),
        this.position.copy(e.position),
        this.rotation.order = e.rotation.order,
        this.quaternion.copy(e.quaternion),
        this.scale.copy(e.scale),
        this.matrix.copy(e.matrix),
        this.matrixWorld.copy(e.matrixWorld),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate,
        this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
        this.layers.mask = e.layers.mask,
        this.visible = e.visible,
        this.castShadow = e.castShadow,
        this.receiveShadow = e.receiveShadow,
        this.frustumCulled = e.frustumCulled,
        this.renderOrder = e.renderOrder,
        this.animations = e.animations.slice(),
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        t === !0)
            for (let n = 0; n < e.children.length; n++) {
                const i = e.children[n];
                this.add(i.clone())
            }
        return this
    }
}
lt.DEFAULT_UP = new D(0,1,0);
lt.DEFAULT_MATRIX_AUTO_UPDATE = !0;
lt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const un = new D
  , Cn = new D
  , lo = new D
  , Rn = new D
  , Ci = new D
  , Ri = new D
  , jc = new D
  , uo = new D
  , ho = new D
  , fo = new D
  , po = new Je
  , mo = new Je
  , Ao = new Je;
class en {
    constructor(e=new D, t=new D, n=new D) {
        this.a = e,
        this.b = t,
        this.c = n
    }
    static getNormal(e, t, n, i) {
        i.subVectors(n, t),
        un.subVectors(e, t),
        i.cross(un);
        const s = i.lengthSq();
        return s > 0 ? i.multiplyScalar(1 / Math.sqrt(s)) : i.set(0, 0, 0)
    }
    static getBarycoord(e, t, n, i, s) {
        un.subVectors(i, t),
        Cn.subVectors(n, t),
        lo.subVectors(e, t);
        const o = un.dot(un)
          , a = un.dot(Cn)
          , c = un.dot(lo)
          , l = Cn.dot(Cn)
          , u = Cn.dot(lo)
          , h = o * l - a * a;
        if (h === 0)
            return s.set(0, 0, 0),
            null;
        const d = 1 / h
          , f = (l * c - a * u) * d
          , m = (o * u - a * c) * d;
        return s.set(1 - f - m, m, f)
    }
    static containsPoint(e, t, n, i) {
        return this.getBarycoord(e, t, n, i, Rn) === null ? !1 : Rn.x >= 0 && Rn.y >= 0 && Rn.x + Rn.y <= 1
    }
    static getInterpolation(e, t, n, i, s, o, a, c) {
        return this.getBarycoord(e, t, n, i, Rn) === null ? (c.x = 0,
        c.y = 0,
        "z"in c && (c.z = 0),
        "w"in c && (c.w = 0),
        null) : (c.setScalar(0),
        c.addScaledVector(s, Rn.x),
        c.addScaledVector(o, Rn.y),
        c.addScaledVector(a, Rn.z),
        c)
    }
    static getInterpolatedAttribute(e, t, n, i, s, o) {
        return po.setScalar(0),
        mo.setScalar(0),
        Ao.setScalar(0),
        po.fromBufferAttribute(e, t),
        mo.fromBufferAttribute(e, n),
        Ao.fromBufferAttribute(e, i),
        o.setScalar(0),
        o.addScaledVector(po, s.x),
        o.addScaledVector(mo, s.y),
        o.addScaledVector(Ao, s.z),
        o
    }
    static isFrontFacing(e, t, n, i) {
        return un.subVectors(n, t),
        Cn.subVectors(e, t),
        un.cross(Cn).dot(i) < 0
    }
    set(e, t, n) {
        return this.a.copy(e),
        this.b.copy(t),
        this.c.copy(n),
        this
    }
    setFromPointsAndIndices(e, t, n, i) {
        return this.a.copy(e[t]),
        this.b.copy(e[n]),
        this.c.copy(e[i]),
        this
    }
    setFromAttributeAndIndices(e, t, n, i) {
        return this.a.fromBufferAttribute(e, t),
        this.b.fromBufferAttribute(e, n),
        this.c.fromBufferAttribute(e, i),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.a.copy(e.a),
        this.b.copy(e.b),
        this.c.copy(e.c),
        this
    }
    getArea() {
        return un.subVectors(this.c, this.b),
        Cn.subVectors(this.a, this.b),
        un.cross(Cn).length() * .5
    }
    getMidpoint(e) {
        return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    }
    getNormal(e) {
        return en.getNormal(this.a, this.b, this.c, e)
    }
    getPlane(e) {
        return e.setFromCoplanarPoints(this.a, this.b, this.c)
    }
    getBarycoord(e, t) {
        return en.getBarycoord(e, this.a, this.b, this.c, t)
    }
    getInterpolation(e, t, n, i, s) {
        return en.getInterpolation(e, this.a, this.b, this.c, t, n, i, s)
    }
    containsPoint(e) {
        return en.containsPoint(e, this.a, this.b, this.c)
    }
    isFrontFacing(e) {
        return en.isFrontFacing(this.a, this.b, this.c, e)
    }
    intersectsBox(e) {
        return e.intersectsTriangle(this)
    }
    closestPointToPoint(e, t) {
        const n = this.a
          , i = this.b
          , s = this.c;
        let o, a;
        Ci.subVectors(i, n),
        Ri.subVectors(s, n),
        uo.subVectors(e, n);
        const c = Ci.dot(uo)
          , l = Ri.dot(uo);
        if (c <= 0 && l <= 0)
            return t.copy(n);
        ho.subVectors(e, i);
        const u = Ci.dot(ho)
          , h = Ri.dot(ho);
        if (u >= 0 && h <= u)
            return t.copy(i);
        const d = c * h - u * l;
        if (d <= 0 && c >= 0 && u <= 0)
            return o = c / (c - u),
            t.copy(n).addScaledVector(Ci, o);
        fo.subVectors(e, s);
        const f = Ci.dot(fo)
          , m = Ri.dot(fo);
        if (m >= 0 && f <= m)
            return t.copy(s);
        const g = f * l - c * m;
        if (g <= 0 && l >= 0 && m <= 0)
            return a = l / (l - m),
            t.copy(n).addScaledVector(Ri, a);
        const A = u * m - f * h;
        if (A <= 0 && h - u >= 0 && f - m >= 0)
            return jc.subVectors(s, i),
            a = (h - u) / (h - u + (f - m)),
            t.copy(i).addScaledVector(jc, a);
        const p = 1 / (A + g + d);
        return o = g * p,
        a = d * p,
        t.copy(n).addScaledVector(Ci, o).addScaledVector(Ri, a)
    }
    equals(e) {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
    }
}
const Pu = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
}
  , jn = {
    h: 0,
    s: 0,
    l: 0
}
  , Js = {
    h: 0,
    s: 0,
    l: 0
};
function go(r, e, t) {
    return t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6 ? r + (e - r) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? r + (e - r) * 6 * (2 / 3 - t) : r
}
class Ge {
    constructor(e, t, n) {
        return this.isColor = !0,
        this.r = 1,
        this.g = 1,
        this.b = 1,
        this.set(e, t, n)
    }
    set(e, t, n) {
        if (t === void 0 && n === void 0) {
            const i = e;
            i && i.isColor ? this.copy(i) : typeof i == "number" ? this.setHex(i) : typeof i == "string" && this.setStyle(i)
        } else
            this.setRGB(e, t, n);
        return this
    }
    setScalar(e) {
        return this.r = e,
        this.g = e,
        this.b = e,
        this
    }
    setHex(e, t=Rt) {
        return e = Math.floor(e),
        this.r = (e >> 16 & 255) / 255,
        this.g = (e >> 8 & 255) / 255,
        this.b = (e & 255) / 255,
        et.colorSpaceToWorking(this, t),
        this
    }
    setRGB(e, t, n, i=et.workingColorSpace) {
        return this.r = e,
        this.g = t,
        this.b = n,
        et.colorSpaceToWorking(this, i),
        this
    }
    setHSL(e, t, n, i=et.workingColorSpace) {
        if (e = tc(e, 1),
        t = Ke(t, 0, 1),
        n = Ke(n, 0, 1),
        t === 0)
            this.r = this.g = this.b = n;
        else {
            const s = n <= .5 ? n * (1 + t) : n + t - n * t
              , o = 2 * n - s;
            this.r = go(o, s, e + 1 / 3),
            this.g = go(o, s, e),
            this.b = go(o, s, e - 1 / 3)
        }
        return et.colorSpaceToWorking(this, i),
        this
    }
    setStyle(e, t=Rt) {
        function n(s) {
            s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
        }
        let i;
        if (i = /^(\w+)\(([^\)]*)\)/.exec(e)) {
            let s;
            const o = i[1]
              , a = i[2];
            switch (o) {
            case "rgb":
            case "rgba":
                if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return n(s[4]),
                    this.setRGB(Math.min(255, parseInt(s[1], 10)) / 255, Math.min(255, parseInt(s[2], 10)) / 255, Math.min(255, parseInt(s[3], 10)) / 255, t);
                if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return n(s[4]),
                    this.setRGB(Math.min(100, parseInt(s[1], 10)) / 100, Math.min(100, parseInt(s[2], 10)) / 100, Math.min(100, parseInt(s[3], 10)) / 100, t);
                break;
            case "hsl":
            case "hsla":
                if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return n(s[4]),
                    this.setHSL(parseFloat(s[1]) / 360, parseFloat(s[2]) / 100, parseFloat(s[3]) / 100, t);
                break;
            default:
                console.warn("THREE.Color: Unknown color model " + e)
            }
        } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
            const s = i[1]
              , o = s.length;
            if (o === 3)
                return this.setRGB(parseInt(s.charAt(0), 16) / 15, parseInt(s.charAt(1), 16) / 15, parseInt(s.charAt(2), 16) / 15, t);
            if (o === 6)
                return this.setHex(parseInt(s, 16), t);
            console.warn("THREE.Color: Invalid hex color " + e)
        } else if (e && e.length > 0)
            return this.setColorName(e, t);
        return this
    }
    setColorName(e, t=Rt) {
        const n = Pu[e.toLowerCase()];
        return n !== void 0 ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e),
        this
    }
    clone() {
        return new this.constructor(this.r,this.g,this.b)
    }
    copy(e) {
        return this.r = e.r,
        this.g = e.g,
        this.b = e.b,
        this
    }
    copySRGBToLinear(e) {
        return this.r = Fn(e.r),
        this.g = Fn(e.g),
        this.b = Fn(e.b),
        this
    }
    copyLinearToSRGB(e) {
        return this.r = Hi(e.r),
        this.g = Hi(e.g),
        this.b = Hi(e.b),
        this
    }
    convertSRGBToLinear() {
        return this.copySRGBToLinear(this),
        this
    }
    convertLinearToSRGB() {
        return this.copyLinearToSRGB(this),
        this
    }
    getHex(e=Rt) {
        return et.workingToColorSpace(Ot.copy(this), e),
        Math.round(Ke(Ot.r * 255, 0, 255)) * 65536 + Math.round(Ke(Ot.g * 255, 0, 255)) * 256 + Math.round(Ke(Ot.b * 255, 0, 255))
    }
    getHexString(e=Rt) {
        return ("000000" + this.getHex(e).toString(16)).slice(-6)
    }
    getHSL(e, t=et.workingColorSpace) {
        et.workingToColorSpace(Ot.copy(this), t);
        const n = Ot.r
          , i = Ot.g
          , s = Ot.b
          , o = Math.max(n, i, s)
          , a = Math.min(n, i, s);
        let c, l;
        const u = (a + o) / 2;
        if (a === o)
            c = 0,
            l = 0;
        else {
            const h = o - a;
            switch (l = u <= .5 ? h / (o + a) : h / (2 - o - a),
            o) {
            case n:
                c = (i - s) / h + (i < s ? 6 : 0);
                break;
            case i:
                c = (s - n) / h + 2;
                break;
            case s:
                c = (n - i) / h + 4;
                break
            }
            c /= 6
        }
        return e.h = c,
        e.s = l,
        e.l = u,
        e
    }
    getRGB(e, t=et.workingColorSpace) {
        return et.workingToColorSpace(Ot.copy(this), t),
        e.r = Ot.r,
        e.g = Ot.g,
        e.b = Ot.b,
        e
    }
    getStyle(e=Rt) {
        et.workingToColorSpace(Ot.copy(this), e);
        const t = Ot.r
          , n = Ot.g
          , i = Ot.b;
        return e !== Rt ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(i * 255)})`
    }
    offsetHSL(e, t, n) {
        return this.getHSL(jn),
        this.setHSL(jn.h + e, jn.s + t, jn.l + n)
    }
    add(e) {
        return this.r += e.r,
        this.g += e.g,
        this.b += e.b,
        this
    }
    addColors(e, t) {
        return this.r = e.r + t.r,
        this.g = e.g + t.g,
        this.b = e.b + t.b,
        this
    }
    addScalar(e) {
        return this.r += e,
        this.g += e,
        this.b += e,
        this
    }
    sub(e) {
        return this.r = Math.max(0, this.r - e.r),
        this.g = Math.max(0, this.g - e.g),
        this.b = Math.max(0, this.b - e.b),
        this
    }
    multiply(e) {
        return this.r *= e.r,
        this.g *= e.g,
        this.b *= e.b,
        this
    }
    multiplyScalar(e) {
        return this.r *= e,
        this.g *= e,
        this.b *= e,
        this
    }
    lerp(e, t) {
        return this.r += (e.r - this.r) * t,
        this.g += (e.g - this.g) * t,
        this.b += (e.b - this.b) * t,
        this
    }
    lerpColors(e, t, n) {
        return this.r = e.r + (t.r - e.r) * n,
        this.g = e.g + (t.g - e.g) * n,
        this.b = e.b + (t.b - e.b) * n,
        this
    }
    lerpHSL(e, t) {
        this.getHSL(jn),
        e.getHSL(Js);
        const n = bs(jn.h, Js.h, t)
          , i = bs(jn.s, Js.s, t)
          , s = bs(jn.l, Js.l, t);
        return this.setHSL(n, i, s),
        this
    }
    setFromVector3(e) {
        return this.r = e.x,
        this.g = e.y,
        this.b = e.z,
        this
    }
    applyMatrix3(e) {
        const t = this.r
          , n = this.g
          , i = this.b
          , s = e.elements;
        return this.r = s[0] * t + s[3] * n + s[6] * i,
        this.g = s[1] * t + s[4] * n + s[7] * i,
        this.b = s[2] * t + s[5] * n + s[8] * i,
        this
    }
    equals(e) {
        return e.r === this.r && e.g === this.g && e.b === this.b
    }
    fromArray(e, t=0) {
        return this.r = e[t],
        this.g = e[t + 1],
        this.b = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.r,
        e[t + 1] = this.g,
        e[t + 2] = this.b,
        e
    }
    fromBufferAttribute(e, t) {
        return this.r = e.getX(t),
        this.g = e.getY(t),
        this.b = e.getZ(t),
        this
    }
    toJSON() {
        return this.getHex()
    }
    *[Symbol.iterator]() {
        yield this.r,
        yield this.g,
        yield this.b
    }
}
const Ot = new Ge;
Ge.NAMES = Pu;
let Hd = 0;
class fn extends es {
    constructor() {
        super(),
        this.isMaterial = !0,
        Object.defineProperty(this, "id", {
            value: Hd++
        }),
        this.uuid = nn(),
        this.name = "",
        this.type = "Material",
        this.blending = Bi,
        this.side = Hn,
        this.vertexColors = !1,
        this.opacity = 1,
        this.transparent = !1,
        this.alphaHash = !1,
        this.blendSrc = jo,
        this.blendDst = ko,
        this.blendEquation = fi,
        this.blendSrcAlpha = null,
        this.blendDstAlpha = null,
        this.blendEquationAlpha = null,
        this.blendColor = new Ge(0,0,0),
        this.blendAlpha = 0,
        this.depthFunc = Vi,
        this.depthTest = !0,
        this.depthWrite = !0,
        this.stencilWriteMask = 255,
        this.stencilFunc = Dc,
        this.stencilRef = 0,
        this.stencilFuncMask = 255,
        this.stencilFail = bi,
        this.stencilZFail = bi,
        this.stencilZPass = bi,
        this.stencilWrite = !1,
        this.clippingPlanes = null,
        this.clipIntersection = !1,
        this.clipShadows = !1,
        this.shadowSide = null,
        this.colorWrite = !0,
        this.precision = null,
        this.polygonOffset = !1,
        this.polygonOffsetFactor = 0,
        this.polygonOffsetUnits = 0,
        this.dithering = !1,
        this.alphaToCoverage = !1,
        this.premultipliedAlpha = !1,
        this.forceSinglePass = !1,
        this.allowOverride = !0,
        this.visible = !0,
        this.toneMapped = !0,
        this.userData = {},
        this.version = 0,
        this._alphaTest = 0
    }
    get alphaTest() {
        return this._alphaTest
    }
    set alphaTest(e) {
        this._alphaTest > 0 != e > 0 && this.version++,
        this._alphaTest = e
    }
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
        return this.onBeforeCompile.toString()
    }
    setValues(e) {
        if (e !== void 0)
            for (const t in e) {
                const n = e[t];
                if (n === void 0) {
                    console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
                    continue
                }
                const i = this[t];
                if (i === void 0) {
                    console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
                    continue
                }
                i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n
            }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        t && (e = {
            textures: {},
            images: {}
        });
        const n = {
            metadata: {
                version: 4.7,
                type: "Material",
                generator: "Material.toJSON"
            }
        };
        n.uuid = this.uuid,
        n.type = this.type,
        this.name !== "" && (n.name = this.name),
        this.color && this.color.isColor && (n.color = this.color.getHex()),
        this.roughness !== void 0 && (n.roughness = this.roughness),
        this.metalness !== void 0 && (n.metalness = this.metalness),
        this.sheen !== void 0 && (n.sheen = this.sheen),
        this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()),
        this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness),
        this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
        this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity),
        this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
        this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity),
        this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()),
        this.shininess !== void 0 && (n.shininess = this.shininess),
        this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat),
        this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness),
        this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
        this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
        this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
        n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
        this.dispersion !== void 0 && (n.dispersion = this.dispersion),
        this.iridescence !== void 0 && (n.iridescence = this.iridescence),
        this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR),
        this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
        this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
        this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
        this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy),
        this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation),
        this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
        this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
        this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid),
        this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid),
        this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid,
        n.lightMapIntensity = this.lightMapIntensity),
        this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid,
        n.aoMapIntensity = this.aoMapIntensity),
        this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid,
        n.bumpScale = this.bumpScale),
        this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid,
        n.normalMapType = this.normalMapType,
        n.normalScale = this.normalScale.toArray()),
        this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid,
        n.displacementScale = this.displacementScale,
        n.displacementBias = this.displacementBias),
        this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
        this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
        this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
        this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid),
        this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
        this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid),
        this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid,
        this.combine !== void 0 && (n.combine = this.combine)),
        this.envMapRotation !== void 0 && (n.envMapRotation = this.envMapRotation.toArray()),
        this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity),
        this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity),
        this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio),
        this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid),
        this.transmission !== void 0 && (n.transmission = this.transmission),
        this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
        this.thickness !== void 0 && (n.thickness = this.thickness),
        this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
        this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance),
        this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()),
        this.size !== void 0 && (n.size = this.size),
        this.shadowSide !== null && (n.shadowSide = this.shadowSide),
        this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation),
        this.blending !== Bi && (n.blending = this.blending),
        this.side !== Hn && (n.side = this.side),
        this.vertexColors === !0 && (n.vertexColors = !0),
        this.opacity < 1 && (n.opacity = this.opacity),
        this.transparent === !0 && (n.transparent = !0),
        this.blendSrc !== jo && (n.blendSrc = this.blendSrc),
        this.blendDst !== ko && (n.blendDst = this.blendDst),
        this.blendEquation !== fi && (n.blendEquation = this.blendEquation),
        this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha),
        this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha),
        this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha),
        this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()),
        this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha),
        this.depthFunc !== Vi && (n.depthFunc = this.depthFunc),
        this.depthTest === !1 && (n.depthTest = this.depthTest),
        this.depthWrite === !1 && (n.depthWrite = this.depthWrite),
        this.colorWrite === !1 && (n.colorWrite = this.colorWrite),
        this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask),
        this.stencilFunc !== Dc && (n.stencilFunc = this.stencilFunc),
        this.stencilRef !== 0 && (n.stencilRef = this.stencilRef),
        this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask),
        this.stencilFail !== bi && (n.stencilFail = this.stencilFail),
        this.stencilZFail !== bi && (n.stencilZFail = this.stencilZFail),
        this.stencilZPass !== bi && (n.stencilZPass = this.stencilZPass),
        this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite),
        this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation),
        this.polygonOffset === !0 && (n.polygonOffset = !0),
        this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor),
        this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits),
        this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth),
        this.dashSize !== void 0 && (n.dashSize = this.dashSize),
        this.gapSize !== void 0 && (n.gapSize = this.gapSize),
        this.scale !== void 0 && (n.scale = this.scale),
        this.dithering === !0 && (n.dithering = !0),
        this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
        this.alphaHash === !0 && (n.alphaHash = !0),
        this.alphaToCoverage === !0 && (n.alphaToCoverage = !0),
        this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0),
        this.forceSinglePass === !0 && (n.forceSinglePass = !0),
        this.wireframe === !0 && (n.wireframe = !0),
        this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
        this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap),
        this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin),
        this.flatShading === !0 && (n.flatShading = !0),
        this.visible === !1 && (n.visible = !1),
        this.toneMapped === !1 && (n.toneMapped = !1),
        this.fog === !1 && (n.fog = !1),
        Object.keys(this.userData).length > 0 && (n.userData = this.userData);
        function i(s) {
            const o = [];
            for (const a in s) {
                const c = s[a];
                delete c.metadata,
                o.push(c)
            }
            return o
        }
        if (t) {
            const s = i(e.textures)
              , o = i(e.images);
            s.length > 0 && (n.textures = s),
            o.length > 0 && (n.images = o)
        }
        return n
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.name = e.name,
        this.blending = e.blending,
        this.side = e.side,
        this.vertexColors = e.vertexColors,
        this.opacity = e.opacity,
        this.transparent = e.transparent,
        this.blendSrc = e.blendSrc,
        this.blendDst = e.blendDst,
        this.blendEquation = e.blendEquation,
        this.blendSrcAlpha = e.blendSrcAlpha,
        this.blendDstAlpha = e.blendDstAlpha,
        this.blendEquationAlpha = e.blendEquationAlpha,
        this.blendColor.copy(e.blendColor),
        this.blendAlpha = e.blendAlpha,
        this.depthFunc = e.depthFunc,
        this.depthTest = e.depthTest,
        this.depthWrite = e.depthWrite,
        this.stencilWriteMask = e.stencilWriteMask,
        this.stencilFunc = e.stencilFunc,
        this.stencilRef = e.stencilRef,
        this.stencilFuncMask = e.stencilFuncMask,
        this.stencilFail = e.stencilFail,
        this.stencilZFail = e.stencilZFail,
        this.stencilZPass = e.stencilZPass,
        this.stencilWrite = e.stencilWrite;
        const t = e.clippingPlanes;
        let n = null;
        if (t !== null) {
            const i = t.length;
            n = new Array(i);
            for (let s = 0; s !== i; ++s)
                n[s] = t[s].clone()
        }
        return this.clippingPlanes = n,
        this.clipIntersection = e.clipIntersection,
        this.clipShadows = e.clipShadows,
        this.shadowSide = e.shadowSide,
        this.colorWrite = e.colorWrite,
        this.precision = e.precision,
        this.polygonOffset = e.polygonOffset,
        this.polygonOffsetFactor = e.polygonOffsetFactor,
        this.polygonOffsetUnits = e.polygonOffsetUnits,
        this.dithering = e.dithering,
        this.alphaTest = e.alphaTest,
        this.alphaHash = e.alphaHash,
        this.alphaToCoverage = e.alphaToCoverage,
        this.premultipliedAlpha = e.premultipliedAlpha,
        this.forceSinglePass = e.forceSinglePass,
        this.visible = e.visible,
        this.toneMapped = e.toneMapped,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
}
class Qn extends fn {
    constructor(e) {
        super(),
        this.isMeshBasicMaterial = !0,
        this.type = "MeshBasicMaterial",
        this.color = new Ge(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapRotation = new Ft,
        this.combine = ka,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapRotation.copy(e.envMapRotation),
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.fog = e.fog,
        this
    }
}
const gt = new D
  , $s = new Ae;
let Xd = 0;
class vt {
    constructor(e, t, n=!1) {
        if (Array.isArray(e))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.isBufferAttribute = !0,
        Object.defineProperty(this, "id", {
            value: Xd++
        }),
        this.name = "",
        this.array = e,
        this.itemSize = t,
        this.count = e !== void 0 ? e.length / t : 0,
        this.normalized = n,
        this.usage = Ca,
        this.updateRanges = [],
        this.gpuType = dn,
        this.version = 0
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    addUpdateRange(e, t) {
        this.updateRanges.push({
            start: e,
            count: t
        })
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0
    }
    copy(e) {
        return this.name = e.name,
        this.array = new e.array.constructor(e.array),
        this.itemSize = e.itemSize,
        this.count = e.count,
        this.normalized = e.normalized,
        this.usage = e.usage,
        this.gpuType = e.gpuType,
        this
    }
    copyAt(e, t, n) {
        e *= this.itemSize,
        n *= t.itemSize;
        for (let i = 0, s = this.itemSize; i < s; i++)
            this.array[e + i] = t.array[n + i];
        return this
    }
    copyArray(e) {
        return this.array.set(e),
        this
    }
    applyMatrix3(e) {
        if (this.itemSize === 2)
            for (let t = 0, n = this.count; t < n; t++)
                $s.fromBufferAttribute(this, t),
                $s.applyMatrix3(e),
                this.setXY(t, $s.x, $s.y);
        else if (this.itemSize === 3)
            for (let t = 0, n = this.count; t < n; t++)
                gt.fromBufferAttribute(this, t),
                gt.applyMatrix3(e),
                this.setXYZ(t, gt.x, gt.y, gt.z);
        return this
    }
    applyMatrix4(e) {
        for (let t = 0, n = this.count; t < n; t++)
            gt.fromBufferAttribute(this, t),
            gt.applyMatrix4(e),
            this.setXYZ(t, gt.x, gt.y, gt.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, n = this.count; t < n; t++)
            gt.fromBufferAttribute(this, t),
            gt.applyNormalMatrix(e),
            this.setXYZ(t, gt.x, gt.y, gt.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, n = this.count; t < n; t++)
            gt.fromBufferAttribute(this, t),
            gt.transformDirection(e),
            this.setXYZ(t, gt.x, gt.y, gt.z);
        return this
    }
    set(e, t=0) {
        return this.array.set(e, t),
        this
    }
    getComponent(e, t) {
        let n = this.array[e * this.itemSize + t];
        return this.normalized && (n = hn(n, this.array)),
        n
    }
    setComponent(e, t, n) {
        return this.normalized && (n = rt(n, this.array)),
        this.array[e * this.itemSize + t] = n,
        this
    }
    getX(e) {
        let t = this.array[e * this.itemSize];
        return this.normalized && (t = hn(t, this.array)),
        t
    }
    setX(e, t) {
        return this.normalized && (t = rt(t, this.array)),
        this.array[e * this.itemSize] = t,
        this
    }
    getY(e) {
        let t = this.array[e * this.itemSize + 1];
        return this.normalized && (t = hn(t, this.array)),
        t
    }
    setY(e, t) {
        return this.normalized && (t = rt(t, this.array)),
        this.array[e * this.itemSize + 1] = t,
        this
    }
    getZ(e) {
        let t = this.array[e * this.itemSize + 2];
        return this.normalized && (t = hn(t, this.array)),
        t
    }
    setZ(e, t) {
        return this.normalized && (t = rt(t, this.array)),
        this.array[e * this.itemSize + 2] = t,
        this
    }
    getW(e) {
        let t = this.array[e * this.itemSize + 3];
        return this.normalized && (t = hn(t, this.array)),
        t
    }
    setW(e, t) {
        return this.normalized && (t = rt(t, this.array)),
        this.array[e * this.itemSize + 3] = t,
        this
    }
    setXY(e, t, n) {
        return e *= this.itemSize,
        this.normalized && (t = rt(t, this.array),
        n = rt(n, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = n,
        this
    }
    setXYZ(e, t, n, i) {
        return e *= this.itemSize,
        this.normalized && (t = rt(t, this.array),
        n = rt(n, this.array),
        i = rt(i, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = n,
        this.array[e + 2] = i,
        this
    }
    setXYZW(e, t, n, i, s) {
        return e *= this.itemSize,
        this.normalized && (t = rt(t, this.array),
        n = rt(n, this.array),
        i = rt(i, this.array),
        s = rt(s, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = n,
        this.array[e + 2] = i,
        this.array[e + 3] = s,
        this
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    clone() {
        return new this.constructor(this.array,this.itemSize).copy(this)
    }
    toJSON() {
        const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
        };
        return this.name !== "" && (e.name = this.name),
        this.usage !== Ca && (e.usage = this.usage),
        e
    }
}
class Lu extends vt {
    constructor(e, t, n) {
        super(new Uint16Array(e), t, n)
    }
}
class Cu extends vt {
    constructor(e, t, n) {
        super(new Uint32Array(e), t, n)
    }
}
class yt extends vt {
    constructor(e, t, n) {
        super(new Float32Array(e), t, n)
    }
}
let Gd = 0;
const Kt = new We
  , vo = new lt
  , Di = new D
  , kt = new xt
  , cs = new xt
  , wt = new D;
class At extends es {
    constructor() {
        super(),
        this.isBufferGeometry = !0,
        Object.defineProperty(this, "id", {
            value: Gd++
        }),
        this.uuid = nn(),
        this.name = "",
        this.type = "BufferGeometry",
        this.index = null,
        this.indirect = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.morphTargetsRelative = !1,
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.drawRange = {
            start: 0,
            count: 1 / 0
        },
        this.userData = {}
    }
    getIndex() {
        return this.index
    }
    setIndex(e) {
        return Array.isArray(e) ? this.index = new (Tu(e) ? Cu : Lu)(e,1) : this.index = e,
        this
    }
    setIndirect(e) {
        return this.indirect = e,
        this
    }
    getIndirect() {
        return this.indirect
    }
    getAttribute(e) {
        return this.attributes[e]
    }
    setAttribute(e, t) {
        return this.attributes[e] = t,
        this
    }
    deleteAttribute(e) {
        return delete this.attributes[e],
        this
    }
    hasAttribute(e) {
        return this.attributes[e] !== void 0
    }
    addGroup(e, t, n=0) {
        this.groups.push({
            start: e,
            count: t,
            materialIndex: n
        })
    }
    clearGroups() {
        this.groups = []
    }
    setDrawRange(e, t) {
        this.drawRange.start = e,
        this.drawRange.count = t
    }
    applyMatrix4(e) {
        const t = this.attributes.position;
        t !== void 0 && (t.applyMatrix4(e),
        t.needsUpdate = !0);
        const n = this.attributes.normal;
        if (n !== void 0) {
            const s = new qe().getNormalMatrix(e);
            n.applyNormalMatrix(s),
            n.needsUpdate = !0
        }
        const i = this.attributes.tangent;
        return i !== void 0 && (i.transformDirection(e),
        i.needsUpdate = !0),
        this.boundingBox !== null && this.computeBoundingBox(),
        this.boundingSphere !== null && this.computeBoundingSphere(),
        this
    }
    applyQuaternion(e) {
        return Kt.makeRotationFromQuaternion(e),
        this.applyMatrix4(Kt),
        this
    }
    rotateX(e) {
        return Kt.makeRotationX(e),
        this.applyMatrix4(Kt),
        this
    }
    rotateY(e) {
        return Kt.makeRotationY(e),
        this.applyMatrix4(Kt),
        this
    }
    rotateZ(e) {
        return Kt.makeRotationZ(e),
        this.applyMatrix4(Kt),
        this
    }
    translate(e, t, n) {
        return Kt.makeTranslation(e, t, n),
        this.applyMatrix4(Kt),
        this
    }
    scale(e, t, n) {
        return Kt.makeScale(e, t, n),
        this.applyMatrix4(Kt),
        this
    }
    lookAt(e) {
        return vo.lookAt(e),
        vo.updateMatrix(),
        this.applyMatrix4(vo.matrix),
        this
    }
    center() {
        return this.computeBoundingBox(),
        this.boundingBox.getCenter(Di).negate(),
        this.translate(Di.x, Di.y, Di.z),
        this
    }
    setFromPoints(e) {
        const t = this.getAttribute("position");
        if (t === void 0) {
            const n = [];
            for (let i = 0, s = e.length; i < s; i++) {
                const o = e[i];
                n.push(o.x, o.y, o.z || 0)
            }
            this.setAttribute("position", new yt(n,3))
        } else {
            const n = Math.min(e.length, t.count);
            for (let i = 0; i < n; i++) {
                const s = e[i];
                t.setXYZ(i, s.x, s.y, s.z || 0)
            }
            e.length > t.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),
            t.needsUpdate = !0
        }
        return this
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new xt);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this),
            this.boundingBox.set(new D(-1 / 0,-1 / 0,-1 / 0), new D(1 / 0,1 / 0,1 / 0));
            return
        }
        if (e !== void 0) {
            if (this.boundingBox.setFromBufferAttribute(e),
            t)
                for (let n = 0, i = t.length; n < i; n++) {
                    const s = t[n];
                    kt.setFromBufferAttribute(s),
                    this.morphTargetsRelative ? (wt.addVectors(this.boundingBox.min, kt.min),
                    this.boundingBox.expandByPoint(wt),
                    wt.addVectors(this.boundingBox.max, kt.max),
                    this.boundingBox.expandByPoint(wt)) : (this.boundingBox.expandByPoint(kt.min),
                    this.boundingBox.expandByPoint(kt.max))
                }
        } else
            this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new rn);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this),
            this.boundingSphere.set(new D, 1 / 0);
            return
        }
        if (e) {
            const n = this.boundingSphere.center;
            if (kt.setFromBufferAttribute(e),
            t)
                for (let s = 0, o = t.length; s < o; s++) {
                    const a = t[s];
                    cs.setFromBufferAttribute(a),
                    this.morphTargetsRelative ? (wt.addVectors(kt.min, cs.min),
                    kt.expandByPoint(wt),
                    wt.addVectors(kt.max, cs.max),
                    kt.expandByPoint(wt)) : (kt.expandByPoint(cs.min),
                    kt.expandByPoint(cs.max))
                }
            kt.getCenter(n);
            let i = 0;
            for (let s = 0, o = e.count; s < o; s++)
                wt.fromBufferAttribute(e, s),
                i = Math.max(i, n.distanceToSquared(wt));
            if (t)
                for (let s = 0, o = t.length; s < o; s++) {
                    const a = t[s]
                      , c = this.morphTargetsRelative;
                    for (let l = 0, u = a.count; l < u; l++)
                        wt.fromBufferAttribute(a, l),
                        c && (Di.fromBufferAttribute(e, l),
                        wt.add(Di)),
                        i = Math.max(i, n.distanceToSquared(wt))
                }
            this.boundingSphere.radius = Math.sqrt(i),
            isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
        }
    }
    computeTangents() {
        const e = this.index
          , t = this.attributes;
        if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return
        }
        const n = t.position
          , i = t.normal
          , s = t.uv;
        this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new vt(new Float32Array(4 * n.count),4));
        const o = this.getAttribute("tangent")
          , a = []
          , c = [];
        for (let H = 0; H < n.count; H++)
            a[H] = new D,
            c[H] = new D;
        const l = new D
          , u = new D
          , h = new D
          , d = new Ae
          , f = new Ae
          , m = new Ae
          , g = new D
          , A = new D;
        function p(H, P, T) {
            l.fromBufferAttribute(n, H),
            u.fromBufferAttribute(n, P),
            h.fromBufferAttribute(n, T),
            d.fromBufferAttribute(s, H),
            f.fromBufferAttribute(s, P),
            m.fromBufferAttribute(s, T),
            u.sub(l),
            h.sub(l),
            f.sub(d),
            m.sub(d);
            const _ = 1 / (f.x * m.y - m.x * f.y);
            isFinite(_) && (g.copy(u).multiplyScalar(m.y).addScaledVector(h, -f.y).multiplyScalar(_),
            A.copy(h).multiplyScalar(f.x).addScaledVector(u, -m.x).multiplyScalar(_),
            a[H].add(g),
            a[P].add(g),
            a[T].add(g),
            c[H].add(A),
            c[P].add(A),
            c[T].add(A))
        }
        let S = this.groups;
        S.length === 0 && (S = [{
            start: 0,
            count: e.count
        }]);
        for (let H = 0, P = S.length; H < P; ++H) {
            const T = S[H]
              , _ = T.start
              , re = T.count;
            for (let k = _, U = _ + re; k < U; k += 3)
                p(e.getX(k + 0), e.getX(k + 1), e.getX(k + 2))
        }
        const w = new D
          , b = new D
          , B = new D
          , z = new D;
        function I(H) {
            B.fromBufferAttribute(i, H),
            z.copy(B);
            const P = a[H];
            w.copy(P),
            w.sub(B.multiplyScalar(B.dot(P))).normalize(),
            b.crossVectors(z, P);
            const _ = b.dot(c[H]) < 0 ? -1 : 1;
            o.setXYZW(H, w.x, w.y, w.z, _)
        }
        for (let H = 0, P = S.length; H < P; ++H) {
            const T = S[H]
              , _ = T.start
              , re = T.count;
            for (let k = _, U = _ + re; k < U; k += 3)
                I(e.getX(k + 0)),
                I(e.getX(k + 1)),
                I(e.getX(k + 2))
        }
    }
    computeVertexNormals() {
        const e = this.index
          , t = this.getAttribute("position");
        if (t !== void 0) {
            let n = this.getAttribute("normal");
            if (n === void 0)
                n = new vt(new Float32Array(t.count * 3),3),
                this.setAttribute("normal", n);
            else
                for (let d = 0, f = n.count; d < f; d++)
                    n.setXYZ(d, 0, 0, 0);
            const i = new D
              , s = new D
              , o = new D
              , a = new D
              , c = new D
              , l = new D
              , u = new D
              , h = new D;
            if (e)
                for (let d = 0, f = e.count; d < f; d += 3) {
                    const m = e.getX(d + 0)
                      , g = e.getX(d + 1)
                      , A = e.getX(d + 2);
                    i.fromBufferAttribute(t, m),
                    s.fromBufferAttribute(t, g),
                    o.fromBufferAttribute(t, A),
                    u.subVectors(o, s),
                    h.subVectors(i, s),
                    u.cross(h),
                    a.fromBufferAttribute(n, m),
                    c.fromBufferAttribute(n, g),
                    l.fromBufferAttribute(n, A),
                    a.add(u),
                    c.add(u),
                    l.add(u),
                    n.setXYZ(m, a.x, a.y, a.z),
                    n.setXYZ(g, c.x, c.y, c.z),
                    n.setXYZ(A, l.x, l.y, l.z)
                }
            else
                for (let d = 0, f = t.count; d < f; d += 3)
                    i.fromBufferAttribute(t, d + 0),
                    s.fromBufferAttribute(t, d + 1),
                    o.fromBufferAttribute(t, d + 2),
                    u.subVectors(o, s),
                    h.subVectors(i, s),
                    u.cross(h),
                    n.setXYZ(d + 0, u.x, u.y, u.z),
                    n.setXYZ(d + 1, u.x, u.y, u.z),
                    n.setXYZ(d + 2, u.x, u.y, u.z);
            this.normalizeNormals(),
            n.needsUpdate = !0
        }
    }
    normalizeNormals() {
        const e = this.attributes.normal;
        for (let t = 0, n = e.count; t < n; t++)
            wt.fromBufferAttribute(e, t),
            wt.normalize(),
            e.setXYZ(t, wt.x, wt.y, wt.z)
    }
    toNonIndexed() {
        function e(a, c) {
            const l = a.array
              , u = a.itemSize
              , h = a.normalized
              , d = new l.constructor(c.length * u);
            let f = 0
              , m = 0;
            for (let g = 0, A = c.length; g < A; g++) {
                a.isInterleavedBufferAttribute ? f = c[g] * a.data.stride + a.offset : f = c[g] * u;
                for (let p = 0; p < u; p++)
                    d[m++] = l[f++]
            }
            return new vt(d,u,h)
        }
        if (this.index === null)
            return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
            this;
        const t = new At
          , n = this.index.array
          , i = this.attributes;
        for (const a in i) {
            const c = i[a]
              , l = e(c, n);
            t.setAttribute(a, l)
        }
        const s = this.morphAttributes;
        for (const a in s) {
            const c = []
              , l = s[a];
            for (let u = 0, h = l.length; u < h; u++) {
                const d = l[u]
                  , f = e(d, n);
                c.push(f)
            }
            t.morphAttributes[a] = c
        }
        t.morphTargetsRelative = this.morphTargetsRelative;
        const o = this.groups;
        for (let a = 0, c = o.length; a < c; a++) {
            const l = o[a];
            t.addGroup(l.start, l.count, l.materialIndex)
        }
        return t
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.7,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        if (e.uuid = this.uuid,
        e.type = this.type,
        this.name !== "" && (e.name = this.name),
        Object.keys(this.userData).length > 0 && (e.userData = this.userData),
        this.parameters !== void 0) {
            const c = this.parameters;
            for (const l in c)
                c[l] !== void 0 && (e[l] = c[l]);
            return e
        }
        e.data = {
            attributes: {}
        };
        const t = this.index;
        t !== null && (e.data.index = {
            type: t.array.constructor.name,
            array: Array.prototype.slice.call(t.array)
        });
        const n = this.attributes;
        for (const c in n) {
            const l = n[c];
            e.data.attributes[c] = l.toJSON(e.data)
        }
        const i = {};
        let s = !1;
        for (const c in this.morphAttributes) {
            const l = this.morphAttributes[c]
              , u = [];
            for (let h = 0, d = l.length; h < d; h++) {
                const f = l[h];
                u.push(f.toJSON(e.data))
            }
            u.length > 0 && (i[c] = u,
            s = !0)
        }
        s && (e.data.morphAttributes = i,
        e.data.morphTargetsRelative = this.morphTargetsRelative);
        const o = this.groups;
        o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
        const a = this.boundingSphere;
        return a !== null && (e.data.boundingSphere = a.toJSON()),
        e
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null;
        const t = {};
        this.name = e.name;
        const n = e.index;
        n !== null && this.setIndex(n.clone());
        const i = e.attributes;
        for (const l in i) {
            const u = i[l];
            this.setAttribute(l, u.clone(t))
        }
        const s = e.morphAttributes;
        for (const l in s) {
            const u = []
              , h = s[l];
            for (let d = 0, f = h.length; d < f; d++)
                u.push(h[d].clone(t));
            this.morphAttributes[l] = u
        }
        this.morphTargetsRelative = e.morphTargetsRelative;
        const o = e.groups;
        for (let l = 0, u = o.length; l < u; l++) {
            const h = o[l];
            this.addGroup(h.start, h.count, h.materialIndex)
        }
        const a = e.boundingBox;
        a !== null && (this.boundingBox = a.clone());
        const c = e.boundingSphere;
        return c !== null && (this.boundingSphere = c.clone()),
        this.drawRange.start = e.drawRange.start,
        this.drawRange.count = e.drawRange.count,
        this.userData = e.userData,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
const kc = new We
  , oi = new _s
  , er = new rn
  , Yc = new D
  , tr = new D
  , nr = new D
  , ir = new D
  , xo = new D
  , sr = new D
  , qc = new D
  , rr = new D;
class ct extends lt {
    constructor(e=new At, t=new Qn) {
        super(),
        this.isMesh = !0,
        this.type = "Mesh",
        this.geometry = e,
        this.material = t,
        this.morphTargetDictionary = void 0,
        this.morphTargetInfluences = void 0,
        this.count = 1,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
        e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
        this.geometry = e.geometry,
        this
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , n = Object.keys(t);
        if (n.length > 0) {
            const i = t[n[0]];
            if (i !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let s = 0, o = i.length; s < o; s++) {
                    const a = i[s].name || String(s);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = s
                }
            }
        }
    }
    getVertexPosition(e, t) {
        const n = this.geometry
          , i = n.attributes.position
          , s = n.morphAttributes.position
          , o = n.morphTargetsRelative;
        t.fromBufferAttribute(i, e);
        const a = this.morphTargetInfluences;
        if (s && a) {
            sr.set(0, 0, 0);
            for (let c = 0, l = s.length; c < l; c++) {
                const u = a[c]
                  , h = s[c];
                u !== 0 && (xo.fromBufferAttribute(h, e),
                o ? sr.addScaledVector(xo, u) : sr.addScaledVector(xo.sub(t), u))
            }
            t.add(sr)
        }
        return t
    }
    raycast(e, t) {
        const n = this.geometry
          , i = this.material
          , s = this.matrixWorld;
        i !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(),
        er.copy(n.boundingSphere),
        er.applyMatrix4(s),
        oi.copy(e.ray).recast(e.near),
        !(er.containsPoint(oi.origin) === !1 && (oi.intersectSphere(er, Yc) === null || oi.origin.distanceToSquared(Yc) > (e.far - e.near) ** 2)) && (kc.copy(s).invert(),
        oi.copy(e.ray).applyMatrix4(kc),
        !(n.boundingBox !== null && oi.intersectsBox(n.boundingBox) === !1) && this._computeIntersections(e, t, oi)))
    }
    _computeIntersections(e, t, n) {
        let i;
        const s = this.geometry
          , o = this.material
          , a = s.index
          , c = s.attributes.position
          , l = s.attributes.uv
          , u = s.attributes.uv1
          , h = s.attributes.normal
          , d = s.groups
          , f = s.drawRange;
        if (a !== null)
            if (Array.isArray(o))
                for (let m = 0, g = d.length; m < g; m++) {
                    const A = d[m]
                      , p = o[A.materialIndex]
                      , S = Math.max(A.start, f.start)
                      , w = Math.min(a.count, Math.min(A.start + A.count, f.start + f.count));
                    for (let b = S, B = w; b < B; b += 3) {
                        const z = a.getX(b)
                          , I = a.getX(b + 1)
                          , H = a.getX(b + 2);
                        i = or(this, p, e, n, l, u, h, z, I, H),
                        i && (i.faceIndex = Math.floor(b / 3),
                        i.face.materialIndex = A.materialIndex,
                        t.push(i))
                    }
                }
            else {
                const m = Math.max(0, f.start)
                  , g = Math.min(a.count, f.start + f.count);
                for (let A = m, p = g; A < p; A += 3) {
                    const S = a.getX(A)
                      , w = a.getX(A + 1)
                      , b = a.getX(A + 2);
                    i = or(this, o, e, n, l, u, h, S, w, b),
                    i && (i.faceIndex = Math.floor(A / 3),
                    t.push(i))
                }
            }
        else if (c !== void 0)
            if (Array.isArray(o))
                for (let m = 0, g = d.length; m < g; m++) {
                    const A = d[m]
                      , p = o[A.materialIndex]
                      , S = Math.max(A.start, f.start)
                      , w = Math.min(c.count, Math.min(A.start + A.count, f.start + f.count));
                    for (let b = S, B = w; b < B; b += 3) {
                        const z = b
                          , I = b + 1
                          , H = b + 2;
                        i = or(this, p, e, n, l, u, h, z, I, H),
                        i && (i.faceIndex = Math.floor(b / 3),
                        i.face.materialIndex = A.materialIndex,
                        t.push(i))
                    }
                }
            else {
                const m = Math.max(0, f.start)
                  , g = Math.min(c.count, f.start + f.count);
                for (let A = m, p = g; A < p; A += 3) {
                    const S = A
                      , w = A + 1
                      , b = A + 2;
                    i = or(this, o, e, n, l, u, h, S, w, b),
                    i && (i.faceIndex = Math.floor(A / 3),
                    t.push(i))
                }
            }
    }
}
function Vd(r, e, t, n, i, s, o, a) {
    let c;
    if (e.side === Vt ? c = n.intersectTriangle(o, s, i, !0, a) : c = n.intersectTriangle(i, s, o, e.side === Hn, a),
    c === null)
        return null;
    rr.copy(a),
    rr.applyMatrix4(r.matrixWorld);
    const l = t.ray.origin.distanceTo(rr);
    return l < t.near || l > t.far ? null : {
        distance: l,
        point: rr.clone(),
        object: r
    }
}
function or(r, e, t, n, i, s, o, a, c, l) {
    r.getVertexPosition(a, tr),
    r.getVertexPosition(c, nr),
    r.getVertexPosition(l, ir);
    const u = Vd(r, e, t, n, tr, nr, ir, qc);
    if (u) {
        const h = new D;
        en.getBarycoord(qc, tr, nr, ir, h),
        i && (u.uv = en.getInterpolatedAttribute(i, a, c, l, h, new Ae)),
        s && (u.uv1 = en.getInterpolatedAttribute(s, a, c, l, h, new Ae)),
        o && (u.normal = en.getInterpolatedAttribute(o, a, c, l, h, new D),
        u.normal.dot(n.direction) > 0 && u.normal.multiplyScalar(-1));
        const d = {
            a,
            b: c,
            c: l,
            normal: new D,
            materialIndex: 0
        };
        en.getNormal(tr, nr, ir, d.normal),
        u.face = d,
        u.barycoord = h
    }
    return u
}
class Hs extends At {
    constructor(e=1, t=1, n=1, i=1, s=1, o=1) {
        super(),
        this.type = "BoxGeometry",
        this.parameters = {
            width: e,
            height: t,
            depth: n,
            widthSegments: i,
            heightSegments: s,
            depthSegments: o
        };
        const a = this;
        i = Math.floor(i),
        s = Math.floor(s),
        o = Math.floor(o);
        const c = []
          , l = []
          , u = []
          , h = [];
        let d = 0
          , f = 0;
        m("z", "y", "x", -1, -1, n, t, e, o, s, 0),
        m("z", "y", "x", 1, -1, n, t, -e, o, s, 1),
        m("x", "z", "y", 1, 1, e, n, t, i, o, 2),
        m("x", "z", "y", 1, -1, e, n, -t, i, o, 3),
        m("x", "y", "z", 1, -1, e, t, n, i, s, 4),
        m("x", "y", "z", -1, -1, e, t, -n, i, s, 5),
        this.setIndex(c),
        this.setAttribute("position", new yt(l,3)),
        this.setAttribute("normal", new yt(u,3)),
        this.setAttribute("uv", new yt(h,2));
        function m(g, A, p, S, w, b, B, z, I, H, P) {
            const T = b / I
              , _ = B / H
              , re = b / 2
              , k = B / 2
              , U = z / 2
              , F = I + 1
              , O = H + 1;
            let y = 0
              , v = 0;
            const L = new D;
            for (let R = 0; R < O; R++) {
                const C = R * _ - k;
                for (let Y = 0; Y < F; Y++) {
                    const ue = Y * T - re;
                    L[g] = ue * S,
                    L[A] = C * w,
                    L[p] = U,
                    l.push(L.x, L.y, L.z),
                    L[g] = 0,
                    L[A] = 0,
                    L[p] = z > 0 ? 1 : -1,
                    u.push(L.x, L.y, L.z),
                    h.push(Y / I),
                    h.push(1 - R / H),
                    y += 1
                }
            }
            for (let R = 0; R < H; R++)
                for (let C = 0; C < I; C++) {
                    const Y = d + C + F * R
                      , ue = d + C + F * (R + 1)
                      , X = d + (C + 1) + F * (R + 1)
                      , ne = d + (C + 1) + F * R;
                    c.push(Y, ue, ne),
                    c.push(ue, X, ne),
                    v += 6
                }
            a.addGroup(f, v, P),
            f += v,
            d += y
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new Hs(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)
    }
}
function qi(r) {
    const e = {};
    for (const t in r) {
        e[t] = {};
        for (const n in r[t]) {
            const i = r[t][n];
            i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),
            e[t][n] = null) : e[t][n] = i.clone() : Array.isArray(i) ? e[t][n] = i.slice() : e[t][n] = i
        }
    }
    return e
}
function Ut(r) {
    const e = {};
    for (let t = 0; t < r.length; t++) {
        const n = qi(r[t]);
        for (const i in n)
            e[i] = n[i]
    }
    return e
}
function Wd(r) {
    const e = [];
    for (let t = 0; t < r.length; t++)
        e.push(r[t].clone());
    return e
}
function Ru(r) {
    const e = r.getRenderTarget();
    return e === null ? r.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : et.workingColorSpace
}
const sc = {
    clone: qi,
    merge: Ut
};
var jd = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`
  , kd = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class wn extends fn {
    constructor(e) {
        super(),
        this.isShaderMaterial = !0,
        this.type = "ShaderMaterial",
        this.defines = {},
        this.uniforms = {},
        this.uniformsGroups = [],
        this.vertexShader = jd,
        this.fragmentShader = kd,
        this.linewidth = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.clipping = !1,
        this.forceSinglePass = !0,
        this.extensions = {
            clipCullDistance: !1,
            multiDraw: !1
        },
        this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv1: [0, 0]
        },
        this.index0AttributeName = void 0,
        this.uniformsNeedUpdate = !1,
        this.glslVersion = null,
        e !== void 0 && this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.fragmentShader = e.fragmentShader,
        this.vertexShader = e.vertexShader,
        this.uniforms = qi(e.uniforms),
        this.uniformsGroups = Wd(e.uniformsGroups),
        this.defines = Object.assign({}, e.defines),
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.fog = e.fog,
        this.lights = e.lights,
        this.clipping = e.clipping,
        this.extensions = Object.assign({}, e.extensions),
        this.glslVersion = e.glslVersion,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        t.glslVersion = this.glslVersion,
        t.uniforms = {};
        for (const i in this.uniforms) {
            const o = this.uniforms[i].value;
            o && o.isTexture ? t.uniforms[i] = {
                type: "t",
                value: o.toJSON(e).uuid
            } : o && o.isColor ? t.uniforms[i] = {
                type: "c",
                value: o.getHex()
            } : o && o.isVector2 ? t.uniforms[i] = {
                type: "v2",
                value: o.toArray()
            } : o && o.isVector3 ? t.uniforms[i] = {
                type: "v3",
                value: o.toArray()
            } : o && o.isVector4 ? t.uniforms[i] = {
                type: "v4",
                value: o.toArray()
            } : o && o.isMatrix3 ? t.uniforms[i] = {
                type: "m3",
                value: o.toArray()
            } : o && o.isMatrix4 ? t.uniforms[i] = {
                type: "m4",
                value: o.toArray()
            } : t.uniforms[i] = {
                value: o
            }
        }
        Object.keys(this.defines).length > 0 && (t.defines = this.defines),
        t.vertexShader = this.vertexShader,
        t.fragmentShader = this.fragmentShader,
        t.lights = this.lights,
        t.clipping = this.clipping;
        const n = {};
        for (const i in this.extensions)
            this.extensions[i] === !0 && (n[i] = !0);
        return Object.keys(n).length > 0 && (t.extensions = n),
        t
    }
}
class Du extends lt {
    constructor() {
        super(),
        this.isCamera = !0,
        this.type = "Camera",
        this.matrixWorldInverse = new We,
        this.projectionMatrix = new We,
        this.projectionMatrixInverse = new We,
        this.coordinateSystem = Un
    }
    copy(e, t) {
        return super.copy(e, t),
        this.matrixWorldInverse.copy(e.matrixWorldInverse),
        this.projectionMatrix.copy(e.projectionMatrix),
        this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
        this.coordinateSystem = e.coordinateSystem,
        this
    }
    getWorldDirection(e) {
        return super.getWorldDirection(e).negate()
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    updateWorldMatrix(e, t) {
        super.updateWorldMatrix(e, t),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const kn = new D
  , Zc = new Ae
  , Kc = new Ae;
class Bt extends Du {
    constructor(e=50, t=1, n=.1, i=2e3) {
        super(),
        this.isPerspectiveCamera = !0,
        this.type = "PerspectiveCamera",
        this.fov = e,
        this.zoom = 1,
        this.near = n,
        this.far = i,
        this.focus = 10,
        this.aspect = t,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.fov = e.fov,
        this.zoom = e.zoom,
        this.near = e.near,
        this.far = e.far,
        this.focus = e.focus,
        this.aspect = e.aspect,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this.filmGauge = e.filmGauge,
        this.filmOffset = e.filmOffset,
        this
    }
    setFocalLength(e) {
        const t = .5 * this.getFilmHeight() / e;
        this.fov = Yi * 2 * Math.atan(t),
        this.updateProjectionMatrix()
    }
    getFocalLength() {
        const e = Math.tan(Fi * .5 * this.fov);
        return .5 * this.getFilmHeight() / e
    }
    getEffectiveFOV() {
        return Yi * 2 * Math.atan(Math.tan(Fi * .5 * this.fov) / this.zoom)
    }
    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1)
    }
    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1)
    }
    getViewBounds(e, t, n) {
        kn.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse),
        t.set(kn.x, kn.y).multiplyScalar(-e / kn.z),
        kn.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse),
        n.set(kn.x, kn.y).multiplyScalar(-e / kn.z)
    }
    getViewSize(e, t) {
        return this.getViewBounds(e, Zc, Kc),
        t.subVectors(Kc, Zc)
    }
    setViewOffset(e, t, n, i, s, o) {
        this.aspect = e / t,
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = n,
        this.view.offsetY = i,
        this.view.width = s,
        this.view.height = o,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = this.near;
        let t = e * Math.tan(Fi * .5 * this.fov) / this.zoom
          , n = 2 * t
          , i = this.aspect * n
          , s = -.5 * i;
        const o = this.view;
        if (this.view !== null && this.view.enabled) {
            const c = o.fullWidth
              , l = o.fullHeight;
            s += o.offsetX * i / c,
            t -= o.offsetY * n / l,
            i *= o.width / c,
            n *= o.height / l
        }
        const a = this.filmOffset;
        a !== 0 && (s += e * a / this.getFilmWidth()),
        this.projectionMatrix.makePerspective(s, s + i, t, t - n, e, this.far, this.coordinateSystem),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.fov = this.fov,
        t.object.zoom = this.zoom,
        t.object.near = this.near,
        t.object.far = this.far,
        t.object.focus = this.focus,
        t.object.aspect = this.aspect,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t.object.filmGauge = this.filmGauge,
        t.object.filmOffset = this.filmOffset,
        t
    }
}
const Ni = -90
  , Oi = 1;
class Yd extends lt {
    constructor(e, t, n) {
        super(),
        this.type = "CubeCamera",
        this.renderTarget = n,
        this.coordinateSystem = null,
        this.activeMipmapLevel = 0;
        const i = new Bt(Ni,Oi,e,t);
        i.layers = this.layers,
        this.add(i);
        const s = new Bt(Ni,Oi,e,t);
        s.layers = this.layers,
        this.add(s);
        const o = new Bt(Ni,Oi,e,t);
        o.layers = this.layers,
        this.add(o);
        const a = new Bt(Ni,Oi,e,t);
        a.layers = this.layers,
        this.add(a);
        const c = new Bt(Ni,Oi,e,t);
        c.layers = this.layers,
        this.add(c);
        const l = new Bt(Ni,Oi,e,t);
        l.layers = this.layers,
        this.add(l)
    }
    updateCoordinateSystem() {
        const e = this.coordinateSystem
          , t = this.children.concat()
          , [n,i,s,o,a,c] = t;
        for (const l of t)
            this.remove(l);
        if (e === Un)
            n.up.set(0, 1, 0),
            n.lookAt(1, 0, 0),
            i.up.set(0, 1, 0),
            i.lookAt(-1, 0, 0),
            s.up.set(0, 0, -1),
            s.lookAt(0, 1, 0),
            o.up.set(0, 0, 1),
            o.lookAt(0, -1, 0),
            a.up.set(0, 1, 0),
            a.lookAt(0, 0, 1),
            c.up.set(0, 1, 0),
            c.lookAt(0, 0, -1);
        else if (e === Hr)
            n.up.set(0, -1, 0),
            n.lookAt(-1, 0, 0),
            i.up.set(0, -1, 0),
            i.lookAt(1, 0, 0),
            s.up.set(0, 0, 1),
            s.lookAt(0, 1, 0),
            o.up.set(0, 0, -1),
            o.lookAt(0, -1, 0),
            a.up.set(0, -1, 0),
            a.lookAt(0, 0, 1),
            c.up.set(0, -1, 0),
            c.lookAt(0, 0, -1);
        else
            throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
        for (const l of t)
            this.add(l),
            l.updateMatrixWorld()
    }
    update(e, t) {
        this.parent === null && this.updateMatrixWorld();
        const {renderTarget: n, activeMipmapLevel: i} = this;
        this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem,
        this.updateCoordinateSystem());
        const [s,o,a,c,l,u] = this.children
          , h = e.getRenderTarget()
          , d = e.getActiveCubeFace()
          , f = e.getActiveMipmapLevel()
          , m = e.xr.enabled;
        e.xr.enabled = !1;
        const g = n.texture.generateMipmaps;
        n.texture.generateMipmaps = !1,
        e.setRenderTarget(n, 0, i),
        e.render(t, s),
        e.setRenderTarget(n, 1, i),
        e.render(t, o),
        e.setRenderTarget(n, 2, i),
        e.render(t, a),
        e.setRenderTarget(n, 3, i),
        e.render(t, c),
        e.setRenderTarget(n, 4, i),
        e.render(t, l),
        n.texture.generateMipmaps = g,
        e.setRenderTarget(n, 5, i),
        e.render(t, u),
        e.setRenderTarget(h, d, f),
        e.xr.enabled = m,
        n.texture.needsPMREMUpdate = !0
    }
}
class Nu extends Tt {
    constructor(e=[], t=Wi, n, i, s, o, a, c, l, u) {
        super(e, t, n, i, s, o, a, c, l, u),
        this.isCubeTexture = !0,
        this.flipY = !1
    }
    get images() {
        return this.image
    }
    set images(e) {
        this.image = e
    }
}
class qd extends gi {
    constructor(e=1, t={}) {
        super(e, e, t),
        this.isWebGLCubeRenderTarget = !0;
        const n = {
            width: e,
            height: e,
            depth: 1
        }
          , i = [n, n, n, n, n, n];
        this.texture = new Nu(i),
        this._setTextureOptions(t),
        this.texture.isRenderTargetTexture = !0
    }
    fromEquirectangularTexture(e, t) {
        this.texture.type = t.type,
        this.texture.colorSpace = t.colorSpace,
        this.texture.generateMipmaps = t.generateMipmaps,
        this.texture.minFilter = t.minFilter,
        this.texture.magFilter = t.magFilter;
        const n = {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
        }
          , i = new Hs(5,5,5)
          , s = new wn({
            name: "CubemapFromEquirect",
            uniforms: qi(n.uniforms),
            vertexShader: n.vertexShader,
            fragmentShader: n.fragmentShader,
            side: Vt,
            blending: ei
        });
        s.uniforms.tEquirect.value = t;
        const o = new ct(i,s)
          , a = t.minFilter;
        return t.minFilter === In && (t.minFilter = Yt),
        new Yd(1,10,this).update(e, o),
        t.minFilter = a,
        o.geometry.dispose(),
        o.material.dispose(),
        this
    }
    clear(e, t=!0, n=!0, i=!0) {
        const s = e.getRenderTarget();
        for (let o = 0; o < 6; o++)
            e.setRenderTarget(this, o),
            e.clear(t, n, i);
        e.setRenderTarget(s)
    }
}
class Jn extends lt {
    constructor() {
        super(),
        this.isGroup = !0,
        this.type = "Group"
    }
}
const Zd = {
    type: "move"
};
class yo {
    constructor() {
        this._targetRay = null,
        this._grip = null,
        this._hand = null
    }
    getHandSpace() {
        return this._hand === null && (this._hand = new Jn,
        this._hand.matrixAutoUpdate = !1,
        this._hand.visible = !1,
        this._hand.joints = {},
        this._hand.inputState = {
            pinching: !1
        }),
        this._hand
    }
    getTargetRaySpace() {
        return this._targetRay === null && (this._targetRay = new Jn,
        this._targetRay.matrixAutoUpdate = !1,
        this._targetRay.visible = !1,
        this._targetRay.hasLinearVelocity = !1,
        this._targetRay.linearVelocity = new D,
        this._targetRay.hasAngularVelocity = !1,
        this._targetRay.angularVelocity = new D),
        this._targetRay
    }
    getGripSpace() {
        return this._grip === null && (this._grip = new Jn,
        this._grip.matrixAutoUpdate = !1,
        this._grip.visible = !1,
        this._grip.hasLinearVelocity = !1,
        this._grip.linearVelocity = new D,
        this._grip.hasAngularVelocity = !1,
        this._grip.angularVelocity = new D),
        this._grip
    }
    dispatchEvent(e) {
        return this._targetRay !== null && this._targetRay.dispatchEvent(e),
        this._grip !== null && this._grip.dispatchEvent(e),
        this._hand !== null && this._hand.dispatchEvent(e),
        this
    }
    connect(e) {
        if (e && e.hand) {
            const t = this._hand;
            if (t)
                for (const n of e.hand.values())
                    this._getHandJoint(t, n)
        }
        return this.dispatchEvent({
            type: "connected",
            data: e
        }),
        this
    }
    disconnect(e) {
        return this.dispatchEvent({
            type: "disconnected",
            data: e
        }),
        this._targetRay !== null && (this._targetRay.visible = !1),
        this._grip !== null && (this._grip.visible = !1),
        this._hand !== null && (this._hand.visible = !1),
        this
    }
    update(e, t, n) {
        let i = null
          , s = null
          , o = null;
        const a = this._targetRay
          , c = this._grip
          , l = this._hand;
        if (e && t.session.visibilityState !== "visible-blurred") {
            if (l && e.hand) {
                o = !0;
                for (const g of e.hand.values()) {
                    const A = t.getJointPose(g, n)
                      , p = this._getHandJoint(l, g);
                    A !== null && (p.matrix.fromArray(A.transform.matrix),
                    p.matrix.decompose(p.position, p.rotation, p.scale),
                    p.matrixWorldNeedsUpdate = !0,
                    p.jointRadius = A.radius),
                    p.visible = A !== null
                }
                const u = l.joints["index-finger-tip"]
                  , h = l.joints["thumb-tip"]
                  , d = u.position.distanceTo(h.position)
                  , f = .02
                  , m = .005;
                l.inputState.pinching && d > f + m ? (l.inputState.pinching = !1,
                this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this
                })) : !l.inputState.pinching && d <= f - m && (l.inputState.pinching = !0,
                this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this
                }))
            } else
                c !== null && e.gripSpace && (s = t.getPose(e.gripSpace, n),
                s !== null && (c.matrix.fromArray(s.transform.matrix),
                c.matrix.decompose(c.position, c.rotation, c.scale),
                c.matrixWorldNeedsUpdate = !0,
                s.linearVelocity ? (c.hasLinearVelocity = !0,
                c.linearVelocity.copy(s.linearVelocity)) : c.hasLinearVelocity = !1,
                s.angularVelocity ? (c.hasAngularVelocity = !0,
                c.angularVelocity.copy(s.angularVelocity)) : c.hasAngularVelocity = !1));
            a !== null && (i = t.getPose(e.targetRaySpace, n),
            i === null && s !== null && (i = s),
            i !== null && (a.matrix.fromArray(i.transform.matrix),
            a.matrix.decompose(a.position, a.rotation, a.scale),
            a.matrixWorldNeedsUpdate = !0,
            i.linearVelocity ? (a.hasLinearVelocity = !0,
            a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1,
            i.angularVelocity ? (a.hasAngularVelocity = !0,
            a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1,
            this.dispatchEvent(Zd)))
        }
        return a !== null && (a.visible = i !== null),
        c !== null && (c.visible = s !== null),
        l !== null && (l.visible = o !== null),
        this
    }
    _getHandJoint(e, t) {
        if (e.joints[t.jointName] === void 0) {
            const n = new Jn;
            n.matrixAutoUpdate = !1,
            n.visible = !1,
            e.joints[t.jointName] = n,
            e.add(n)
        }
        return e.joints[t.jointName]
    }
}
class Qc extends lt {
    constructor() {
        super(),
        this.isScene = !0,
        this.type = "Scene",
        this.background = null,
        this.environment = null,
        this.fog = null,
        this.backgroundBlurriness = 0,
        this.backgroundIntensity = 1,
        this.backgroundRotation = new Ft,
        this.environmentIntensity = 1,
        this.environmentRotation = new Ft,
        this.overrideMaterial = null,
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    copy(e, t) {
        return super.copy(e, t),
        e.background !== null && (this.background = e.background.clone()),
        e.environment !== null && (this.environment = e.environment.clone()),
        e.fog !== null && (this.fog = e.fog.clone()),
        this.backgroundBlurriness = e.backgroundBlurriness,
        this.backgroundIntensity = e.backgroundIntensity,
        this.backgroundRotation.copy(e.backgroundRotation),
        this.environmentIntensity = e.environmentIntensity,
        this.environmentRotation.copy(e.environmentRotation),
        e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return this.fog !== null && (t.object.fog = this.fog.toJSON()),
        this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness),
        this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity),
        t.object.backgroundRotation = this.backgroundRotation.toArray(),
        this.environmentIntensity !== 1 && (t.object.environmentIntensity = this.environmentIntensity),
        t.object.environmentRotation = this.environmentRotation.toArray(),
        t
    }
}
class Ou {
    constructor(e, t) {
        this.isInterleavedBuffer = !0,
        this.array = e,
        this.stride = t,
        this.count = e !== void 0 ? e.length / t : 0,
        this.usage = Ca,
        this.updateRanges = [],
        this.version = 0,
        this.uuid = nn()
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    addUpdateRange(e, t) {
        this.updateRanges.push({
            start: e,
            count: t
        })
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0
    }
    copy(e) {
        return this.array = new e.array.constructor(e.array),
        this.count = e.count,
        this.stride = e.stride,
        this.usage = e.usage,
        this
    }
    copyAt(e, t, n) {
        e *= this.stride,
        n *= t.stride;
        for (let i = 0, s = this.stride; i < s; i++)
            this.array[e + i] = t.array[n + i];
        return this
    }
    set(e, t=0) {
        return this.array.set(e, t),
        this
    }
    clone(e) {
        e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = nn()),
        e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
        const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid])
          , n = new this.constructor(t,this.stride);
        return n.setUsage(this.usage),
        n
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    toJSON(e) {
        return e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = nn()),
        e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))),
        {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
        }
    }
}
const It = new D;
class Bn {
    constructor(e, t, n, i=!1) {
        this.isInterleavedBufferAttribute = !0,
        this.name = "",
        this.data = e,
        this.itemSize = t,
        this.offset = n,
        this.normalized = i
    }
    get count() {
        return this.data.count
    }
    get array() {
        return this.data.array
    }
    set needsUpdate(e) {
        this.data.needsUpdate = e
    }
    applyMatrix4(e) {
        for (let t = 0, n = this.data.count; t < n; t++)
            It.fromBufferAttribute(this, t),
            It.applyMatrix4(e),
            this.setXYZ(t, It.x, It.y, It.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, n = this.count; t < n; t++)
            It.fromBufferAttribute(this, t),
            It.applyNormalMatrix(e),
            this.setXYZ(t, It.x, It.y, It.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, n = this.count; t < n; t++)
            It.fromBufferAttribute(this, t),
            It.transformDirection(e),
            this.setXYZ(t, It.x, It.y, It.z);
        return this
    }
    getComponent(e, t) {
        let n = this.array[e * this.data.stride + this.offset + t];
        return this.normalized && (n = hn(n, this.array)),
        n
    }
    setComponent(e, t, n) {
        return this.normalized && (n = rt(n, this.array)),
        this.data.array[e * this.data.stride + this.offset + t] = n,
        this
    }
    setX(e, t) {
        return this.normalized && (t = rt(t, this.array)),
        this.data.array[e * this.data.stride + this.offset] = t,
        this
    }
    setY(e, t) {
        return this.normalized && (t = rt(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 1] = t,
        this
    }
    setZ(e, t) {
        return this.normalized && (t = rt(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 2] = t,
        this
    }
    setW(e, t) {
        return this.normalized && (t = rt(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 3] = t,
        this
    }
    getX(e) {
        let t = this.data.array[e * this.data.stride + this.offset];
        return this.normalized && (t = hn(t, this.array)),
        t
    }
    getY(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 1];
        return this.normalized && (t = hn(t, this.array)),
        t
    }
    getZ(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 2];
        return this.normalized && (t = hn(t, this.array)),
        t
    }
    getW(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 3];
        return this.normalized && (t = hn(t, this.array)),
        t
    }
    setXY(e, t, n) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = rt(t, this.array),
        n = rt(n, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = n,
        this
    }
    setXYZ(e, t, n, i) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = rt(t, this.array),
        n = rt(n, this.array),
        i = rt(i, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = n,
        this.data.array[e + 2] = i,
        this
    }
    setXYZW(e, t, n, i, s) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = rt(t, this.array),
        n = rt(n, this.array),
        i = rt(i, this.array),
        s = rt(s, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = n,
        this.data.array[e + 2] = i,
        this.data.array[e + 3] = s,
        this
    }
    clone(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let n = 0; n < this.count; n++) {
                const i = n * this.data.stride + this.offset;
                for (let s = 0; s < this.itemSize; s++)
                    t.push(this.data.array[i + s])
            }
            return new vt(new this.array.constructor(t),this.itemSize,this.normalized)
        } else
            return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
            e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
            new Bn(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
    }
    toJSON(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let n = 0; n < this.count; n++) {
                const i = n * this.data.stride + this.offset;
                for (let s = 0; s < this.itemSize; s++)
                    t.push(this.data.array[i + s])
            }
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: t,
                normalized: this.normalized
            }
        } else
            return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
            e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
            {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            }
    }
}
const Jc = new D
  , $c = new Je
  , el = new Je
  , Kd = new D
  , tl = new We
  , ar = new D
  , bo = new rn
  , nl = new We
  , Mo = new _s;
class Qd extends ct {
    constructor(e, t) {
        super(e, t),
        this.isSkinnedMesh = !0,
        this.type = "SkinnedMesh",
        this.bindMode = Pc,
        this.bindMatrix = new We,
        this.bindMatrixInverse = new We,
        this.boundingBox = null,
        this.boundingSphere = null
    }
    computeBoundingBox() {
        const e = this.geometry;
        this.boundingBox === null && (this.boundingBox = new xt),
        this.boundingBox.makeEmpty();
        const t = e.getAttribute("position");
        for (let n = 0; n < t.count; n++)
            this.getVertexPosition(n, ar),
            this.boundingBox.expandByPoint(ar)
    }
    computeBoundingSphere() {
        const e = this.geometry;
        this.boundingSphere === null && (this.boundingSphere = new rn),
        this.boundingSphere.makeEmpty();
        const t = e.getAttribute("position");
        for (let n = 0; n < t.count; n++)
            this.getVertexPosition(n, ar),
            this.boundingSphere.expandByPoint(ar)
    }
    copy(e, t) {
        return super.copy(e, t),
        this.bindMode = e.bindMode,
        this.bindMatrix.copy(e.bindMatrix),
        this.bindMatrixInverse.copy(e.bindMatrixInverse),
        this.skeleton = e.skeleton,
        e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
        e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()),
        this
    }
    raycast(e, t) {
        const n = this.material
          , i = this.matrixWorld;
        n !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(),
        bo.copy(this.boundingSphere),
        bo.applyMatrix4(i),
        e.ray.intersectsSphere(bo) !== !1 && (nl.copy(i).invert(),
        Mo.copy(e.ray).applyMatrix4(nl),
        !(this.boundingBox !== null && Mo.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, Mo)))
    }
    getVertexPosition(e, t) {
        return super.getVertexPosition(e, t),
        this.applyBoneTransform(e, t),
        t
    }
    bind(e, t) {
        this.skeleton = e,
        t === void 0 && (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        t = this.matrixWorld),
        this.bindMatrix.copy(t),
        this.bindMatrixInverse.copy(t).invert()
    }
    pose() {
        this.skeleton.pose()
    }
    normalizeSkinWeights() {
        const e = new Je
          , t = this.geometry.attributes.skinWeight;
        for (let n = 0, i = t.count; n < i; n++) {
            e.fromBufferAttribute(t, n);
            const s = 1 / e.manhattanLength();
            s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0),
            t.setXYZW(n, e.x, e.y, e.z, e.w)
        }
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
        this.bindMode === Pc ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === qh ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
    }
    applyBoneTransform(e, t) {
        const n = this.skeleton
          , i = this.geometry;
        $c.fromBufferAttribute(i.attributes.skinIndex, e),
        el.fromBufferAttribute(i.attributes.skinWeight, e),
        Jc.copy(t).applyMatrix4(this.bindMatrix),
        t.set(0, 0, 0);
        for (let s = 0; s < 4; s++) {
            const o = el.getComponent(s);
            if (o !== 0) {
                const a = $c.getComponent(s);
                tl.multiplyMatrices(n.bones[a].matrixWorld, n.boneInverses[a]),
                t.addScaledVector(Kd.copy(Jc).applyMatrix4(tl), o)
            }
        }
        return t.applyMatrix4(this.bindMatrixInverse)
    }
}
class zu extends lt {
    constructor() {
        super(),
        this.isBone = !0,
        this.type = "Bone"
    }
}
class Iu extends Tt {
    constructor(e=null, t=1, n=1, i, s, o, a, c, l=_t, u=_t, h, d) {
        super(null, o, a, c, l, u, i, s, h, d),
        this.isDataTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: n
        },
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
const il = new We
  , Jd = new We;
class rc {
    constructor(e=[], t=[]) {
        this.uuid = nn(),
        this.bones = e.slice(0),
        this.boneInverses = t,
        this.boneMatrices = null,
        this.boneTexture = null,
        this.init()
    }
    init() {
        const e = this.bones
          , t = this.boneInverses;
        if (this.boneMatrices = new Float32Array(e.length * 16),
        t.length === 0)
            this.calculateInverses();
        else if (e.length !== t.length) {
            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),
            this.boneInverses = [];
            for (let n = 0, i = this.bones.length; n < i; n++)
                this.boneInverses.push(new We)
        }
    }
    calculateInverses() {
        this.boneInverses.length = 0;
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const n = new We;
            this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(),
            this.boneInverses.push(n)
        }
    }
    pose() {
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const n = this.bones[e];
            n && n.matrixWorld.copy(this.boneInverses[e]).invert()
        }
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const n = this.bones[e];
            n && (n.parent && n.parent.isBone ? (n.matrix.copy(n.parent.matrixWorld).invert(),
            n.matrix.multiply(n.matrixWorld)) : n.matrix.copy(n.matrixWorld),
            n.matrix.decompose(n.position, n.quaternion, n.scale))
        }
    }
    update() {
        const e = this.bones
          , t = this.boneInverses
          , n = this.boneMatrices
          , i = this.boneTexture;
        for (let s = 0, o = e.length; s < o; s++) {
            const a = e[s] ? e[s].matrixWorld : Jd;
            il.multiplyMatrices(a, t[s]),
            il.toArray(n, s * 16)
        }
        i !== null && (i.needsUpdate = !0)
    }
    clone() {
        return new rc(this.bones,this.boneInverses)
    }
    computeBoneTexture() {
        let e = Math.sqrt(this.bones.length * 4);
        e = Math.ceil(e / 4) * 4,
        e = Math.max(e, 4);
        const t = new Float32Array(e * e * 4);
        t.set(this.boneMatrices);
        const n = new Iu(t,e,e,tn,dn);
        return n.needsUpdate = !0,
        this.boneMatrices = t,
        this.boneTexture = n,
        this
    }
    getBoneByName(e) {
        for (let t = 0, n = this.bones.length; t < n; t++) {
            const i = this.bones[t];
            if (i.name === e)
                return i
        }
    }
    dispose() {
        this.boneTexture !== null && (this.boneTexture.dispose(),
        this.boneTexture = null)
    }
    fromJSON(e, t) {
        this.uuid = e.uuid;
        for (let n = 0, i = e.bones.length; n < i; n++) {
            const s = e.bones[n];
            let o = t[s];
            o === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", s),
            o = new zu),
            this.bones.push(o),
            this.boneInverses.push(new We().fromArray(e.boneInverses[n]))
        }
        return this.init(),
        this
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.7,
                type: "Skeleton",
                generator: "Skeleton.toJSON"
            },
            bones: [],
            boneInverses: []
        };
        e.uuid = this.uuid;
        const t = this.bones
          , n = this.boneInverses;
        for (let i = 0, s = t.length; i < s; i++) {
            const o = t[i];
            e.bones.push(o.uuid);
            const a = n[i];
            e.boneInverses.push(a.toArray())
        }
        return e
    }
}
class Ra extends vt {
    constructor(e, t, n, i=1) {
        super(e, t, n),
        this.isInstancedBufferAttribute = !0,
        this.meshPerAttribute = i
    }
    copy(e) {
        return super.copy(e),
        this.meshPerAttribute = e.meshPerAttribute,
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.meshPerAttribute = this.meshPerAttribute,
        e.isInstancedBufferAttribute = !0,
        e
    }
}
const zi = new We
  , sl = new We
  , cr = []
  , rl = new xt
  , $d = new We
  , ls = new ct
  , us = new rn;
class Uu extends ct {
    constructor(e, t, n) {
        super(e, t),
        this.isInstancedMesh = !0,
        this.instanceMatrix = new Ra(new Float32Array(n * 16),16),
        this.instanceColor = null,
        this.morphTexture = null,
        this.count = n,
        this.boundingBox = null,
        this.boundingSphere = null;
        for (let i = 0; i < n; i++)
            this.setMatrixAt(i, $d)
    }
    computeBoundingBox() {
        const e = this.geometry
          , t = this.count;
        this.boundingBox === null && (this.boundingBox = new xt),
        e.boundingBox === null && e.computeBoundingBox(),
        this.boundingBox.makeEmpty();
        for (let n = 0; n < t; n++)
            this.getMatrixAt(n, zi),
            rl.copy(e.boundingBox).applyMatrix4(zi),
            this.boundingBox.union(rl)
    }
    computeBoundingSphere() {
        const e = this.geometry
          , t = this.count;
        this.boundingSphere === null && (this.boundingSphere = new rn),
        e.boundingSphere === null && e.computeBoundingSphere(),
        this.boundingSphere.makeEmpty();
        for (let n = 0; n < t; n++)
            this.getMatrixAt(n, zi),
            us.copy(e.boundingSphere).applyMatrix4(zi),
            this.boundingSphere.union(us)
    }
    copy(e, t) {
        return super.copy(e, t),
        this.instanceMatrix.copy(e.instanceMatrix),
        e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()),
        e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()),
        this.count = e.count,
        e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
        e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()),
        this
    }
    getColorAt(e, t) {
        t.fromArray(this.instanceColor.array, e * 3)
    }
    getMatrixAt(e, t) {
        t.fromArray(this.instanceMatrix.array, e * 16)
    }
    getMorphAt(e, t) {
        const n = t.morphTargetInfluences
          , i = this.morphTexture.source.data.data
          , s = n.length + 1
          , o = e * s + 1;
        for (let a = 0; a < n.length; a++)
            n[a] = i[o + a]
    }
    raycast(e, t) {
        const n = this.matrixWorld
          , i = this.count;
        if (ls.geometry = this.geometry,
        ls.material = this.material,
        ls.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(),
        us.copy(this.boundingSphere),
        us.applyMatrix4(n),
        e.ray.intersectsSphere(us) !== !1))
            for (let s = 0; s < i; s++) {
                this.getMatrixAt(s, zi),
                sl.multiplyMatrices(n, zi),
                ls.matrixWorld = sl,
                ls.raycast(e, cr);
                for (let o = 0, a = cr.length; o < a; o++) {
                    const c = cr[o];
                    c.instanceId = s,
                    c.object = this,
                    t.push(c)
                }
                cr.length = 0
            }
    }
    setColorAt(e, t) {
        this.instanceColor === null && (this.instanceColor = new Ra(new Float32Array(this.instanceMatrix.count * 3).fill(1),3)),
        t.toArray(this.instanceColor.array, e * 3)
    }
    setMatrixAt(e, t) {
        t.toArray(this.instanceMatrix.array, e * 16)
    }
    setMorphAt(e, t) {
        const n = t.morphTargetInfluences
          , i = n.length + 1;
        this.morphTexture === null && (this.morphTexture = new Iu(new Float32Array(i * this.count),i,this.count,Ka,dn));
        const s = this.morphTexture.source.data.data;
        let o = 0;
        for (let l = 0; l < n.length; l++)
            o += n[l];
        const a = this.geometry.morphTargetsRelative ? 1 : 1 - o
          , c = i * e;
        s[c] = a,
        s.set(n, c + 1)
    }
    updateMorphTargets() {}
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        }),
        this.morphTexture !== null && (this.morphTexture.dispose(),
        this.morphTexture = null)
    }
}
const wo = new D
  , ef = new D
  , tf = new qe;
class xn {
    constructor(e=new D(1,0,0), t=0) {
        this.isPlane = !0,
        this.normal = e,
        this.constant = t
    }
    set(e, t) {
        return this.normal.copy(e),
        this.constant = t,
        this
    }
    setComponents(e, t, n, i) {
        return this.normal.set(e, t, n),
        this.constant = i,
        this
    }
    setFromNormalAndCoplanarPoint(e, t) {
        return this.normal.copy(e),
        this.constant = -t.dot(this.normal),
        this
    }
    setFromCoplanarPoints(e, t, n) {
        const i = wo.subVectors(n, t).cross(ef.subVectors(e, t)).normalize();
        return this.setFromNormalAndCoplanarPoint(i, e),
        this
    }
    copy(e) {
        return this.normal.copy(e.normal),
        this.constant = e.constant,
        this
    }
    normalize() {
        const e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e),
        this.constant *= e,
        this
    }
    negate() {
        return this.constant *= -1,
        this.normal.negate(),
        this
    }
    distanceToPoint(e) {
        return this.normal.dot(e) + this.constant
    }
    distanceToSphere(e) {
        return this.distanceToPoint(e.center) - e.radius
    }
    projectPoint(e, t) {
        return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
    }
    intersectLine(e, t) {
        const n = e.delta(wo)
          , i = this.normal.dot(n);
        if (i === 0)
            return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
        const s = -(e.start.dot(this.normal) + this.constant) / i;
        return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(n, s)
    }
    intersectsLine(e) {
        const t = this.distanceToPoint(e.start)
          , n = this.distanceToPoint(e.end);
        return t < 0 && n > 0 || n < 0 && t > 0
    }
    intersectsBox(e) {
        return e.intersectsPlane(this)
    }
    intersectsSphere(e) {
        return e.intersectsPlane(this)
    }
    coplanarPoint(e) {
        return e.copy(this.normal).multiplyScalar(-this.constant)
    }
    applyMatrix4(e, t) {
        const n = t || tf.getNormalMatrix(e)
          , i = this.coplanarPoint(wo).applyMatrix4(e)
          , s = this.normal.applyMatrix3(n).normalize();
        return this.constant = -i.dot(s),
        this
    }
    translate(e) {
        return this.constant -= e.dot(this.normal),
        this
    }
    equals(e) {
        return e.normal.equals(this.normal) && e.constant === this.constant
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const ai = new rn
  , lr = new D;
class oc {
    constructor(e=new xn, t=new xn, n=new xn, i=new xn, s=new xn, o=new xn) {
        this.planes = [e, t, n, i, s, o]
    }
    set(e, t, n, i, s, o) {
        const a = this.planes;
        return a[0].copy(e),
        a[1].copy(t),
        a[2].copy(n),
        a[3].copy(i),
        a[4].copy(s),
        a[5].copy(o),
        this
    }
    copy(e) {
        const t = this.planes;
        for (let n = 0; n < 6; n++)
            t[n].copy(e.planes[n]);
        return this
    }
    setFromProjectionMatrix(e, t=Un) {
        const n = this.planes
          , i = e.elements
          , s = i[0]
          , o = i[1]
          , a = i[2]
          , c = i[3]
          , l = i[4]
          , u = i[5]
          , h = i[6]
          , d = i[7]
          , f = i[8]
          , m = i[9]
          , g = i[10]
          , A = i[11]
          , p = i[12]
          , S = i[13]
          , w = i[14]
          , b = i[15];
        if (n[0].setComponents(c - s, d - l, A - f, b - p).normalize(),
        n[1].setComponents(c + s, d + l, A + f, b + p).normalize(),
        n[2].setComponents(c + o, d + u, A + m, b + S).normalize(),
        n[3].setComponents(c - o, d - u, A - m, b - S).normalize(),
        n[4].setComponents(c - a, d - h, A - g, b - w).normalize(),
        t === Un)
            n[5].setComponents(c + a, d + h, A + g, b + w).normalize();
        else if (t === Hr)
            n[5].setComponents(a, h, g, w).normalize();
        else
            throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
        return this
    }
    intersectsObject(e) {
        if (e.boundingSphere !== void 0)
            e.boundingSphere === null && e.computeBoundingSphere(),
            ai.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
        else {
            const t = e.geometry;
            t.boundingSphere === null && t.computeBoundingSphere(),
            ai.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
        }
        return this.intersectsSphere(ai)
    }
    intersectsSprite(e) {
        return ai.center.set(0, 0, 0),
        ai.radius = .7071067811865476,
        ai.applyMatrix4(e.matrixWorld),
        this.intersectsSphere(ai)
    }
    intersectsSphere(e) {
        const t = this.planes
          , n = e.center
          , i = -e.radius;
        for (let s = 0; s < 6; s++)
            if (t[s].distanceToPoint(n) < i)
                return !1;
        return !0
    }
    intersectsBox(e) {
        const t = this.planes;
        for (let n = 0; n < 6; n++) {
            const i = t[n];
            if (lr.x = i.normal.x > 0 ? e.max.x : e.min.x,
            lr.y = i.normal.y > 0 ? e.max.y : e.min.y,
            lr.z = i.normal.z > 0 ? e.max.z : e.min.z,
            i.distanceToPoint(lr) < 0)
                return !1
        }
        return !0
    }
    containsPoint(e) {
        const t = this.planes;
        for (let n = 0; n < 6; n++)
            if (t[n].distanceToPoint(e) < 0)
                return !1;
        return !0
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class jr extends fn {
    constructor(e) {
        super(),
        this.isLineBasicMaterial = !0,
        this.type = "LineBasicMaterial",
        this.color = new Ge(16777215),
        this.map = null,
        this.linewidth = 1,
        this.linecap = "round",
        this.linejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.linewidth = e.linewidth,
        this.linecap = e.linecap,
        this.linejoin = e.linejoin,
        this.fog = e.fog,
        this
    }
}
const Xr = new D
  , Gr = new D
  , ol = new We
  , hs = new _s
  , ur = new rn
  , So = new D
  , al = new D;
class Xi extends lt {
    constructor(e=new At, t=new jr) {
        super(),
        this.isLine = !0,
        this.type = "Line",
        this.geometry = e,
        this.material = t,
        this.morphTargetDictionary = void 0,
        this.morphTargetInfluences = void 0,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
        this.geometry = e.geometry,
        this
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const t = e.attributes.position
              , n = [0];
            for (let i = 1, s = t.count; i < s; i++)
                Xr.fromBufferAttribute(t, i - 1),
                Gr.fromBufferAttribute(t, i),
                n[i] = n[i - 1],
                n[i] += Xr.distanceTo(Gr);
            e.setAttribute("lineDistance", new yt(n,1))
        } else
            console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
    raycast(e, t) {
        const n = this.geometry
          , i = this.matrixWorld
          , s = e.params.Line.threshold
          , o = n.drawRange;
        if (n.boundingSphere === null && n.computeBoundingSphere(),
        ur.copy(n.boundingSphere),
        ur.applyMatrix4(i),
        ur.radius += s,
        e.ray.intersectsSphere(ur) === !1)
            return;
        ol.copy(i).invert(),
        hs.copy(e.ray).applyMatrix4(ol);
        const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3)
          , c = a * a
          , l = this.isLineSegments ? 2 : 1
          , u = n.index
          , d = n.attributes.position;
        if (u !== null) {
            const f = Math.max(0, o.start)
              , m = Math.min(u.count, o.start + o.count);
            for (let g = f, A = m - 1; g < A; g += l) {
                const p = u.getX(g)
                  , S = u.getX(g + 1)
                  , w = hr(this, e, hs, c, p, S, g);
                w && t.push(w)
            }
            if (this.isLineLoop) {
                const g = u.getX(m - 1)
                  , A = u.getX(f)
                  , p = hr(this, e, hs, c, g, A, m - 1);
                p && t.push(p)
            }
        } else {
            const f = Math.max(0, o.start)
              , m = Math.min(d.count, o.start + o.count);
            for (let g = f, A = m - 1; g < A; g += l) {
                const p = hr(this, e, hs, c, g, g + 1, g);
                p && t.push(p)
            }
            if (this.isLineLoop) {
                const g = hr(this, e, hs, c, m - 1, f, m - 1);
                g && t.push(g)
            }
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , n = Object.keys(t);
        if (n.length > 0) {
            const i = t[n[0]];
            if (i !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let s = 0, o = i.length; s < o; s++) {
                    const a = i[s].name || String(s);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = s
                }
            }
        }
    }
}
function hr(r, e, t, n, i, s, o) {
    const a = r.geometry.attributes.position;
    if (Xr.fromBufferAttribute(a, i),
    Gr.fromBufferAttribute(a, s),
    t.distanceSqToSegment(Xr, Gr, So, al) > n)
        return;
    So.applyMatrix4(r.matrixWorld);
    const l = e.ray.origin.distanceTo(So);
    if (!(l < e.near || l > e.far))
        return {
            distance: l,
            point: al.clone().applyMatrix4(r.matrixWorld),
            index: o,
            face: null,
            faceIndex: null,
            barycoord: null,
            object: r
        }
}
const cl = new D
  , ll = new D;
class Bu extends Xi {
    constructor(e, t) {
        super(e, t),
        this.isLineSegments = !0,
        this.type = "LineSegments"
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const t = e.attributes.position
              , n = [];
            for (let i = 0, s = t.count; i < s; i += 2)
                cl.fromBufferAttribute(t, i),
                ll.fromBufferAttribute(t, i + 1),
                n[i] = i === 0 ? 0 : n[i - 1],
                n[i + 1] = n[i] + cl.distanceTo(ll);
            e.setAttribute("lineDistance", new yt(n,1))
        } else
            console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
}
class nf extends Xi {
    constructor(e, t) {
        super(e, t),
        this.isLineLoop = !0,
        this.type = "LineLoop"
    }
}
class Fu extends fn {
    constructor(e) {
        super(),
        this.isPointsMaterial = !0,
        this.type = "PointsMaterial",
        this.color = new Ge(16777215),
        this.map = null,
        this.alphaMap = null,
        this.size = 1,
        this.sizeAttenuation = !0,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.size = e.size,
        this.sizeAttenuation = e.sizeAttenuation,
        this.fog = e.fog,
        this
    }
}
const ul = new We
  , Da = new _s
  , dr = new rn
  , fr = new D;
class sf extends lt {
    constructor(e=new At, t=new Fu) {
        super(),
        this.isPoints = !0,
        this.type = "Points",
        this.geometry = e,
        this.material = t,
        this.morphTargetDictionary = void 0,
        this.morphTargetInfluences = void 0,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
        this.geometry = e.geometry,
        this
    }
    raycast(e, t) {
        const n = this.geometry
          , i = this.matrixWorld
          , s = e.params.Points.threshold
          , o = n.drawRange;
        if (n.boundingSphere === null && n.computeBoundingSphere(),
        dr.copy(n.boundingSphere),
        dr.applyMatrix4(i),
        dr.radius += s,
        e.ray.intersectsSphere(dr) === !1)
            return;
        ul.copy(i).invert(),
        Da.copy(e.ray).applyMatrix4(ul);
        const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3)
          , c = a * a
          , l = n.index
          , h = n.attributes.position;
        if (l !== null) {
            const d = Math.max(0, o.start)
              , f = Math.min(l.count, o.start + o.count);
            for (let m = d, g = f; m < g; m++) {
                const A = l.getX(m);
                fr.fromBufferAttribute(h, A),
                hl(fr, A, c, i, e, t, this)
            }
        } else {
            const d = Math.max(0, o.start)
              , f = Math.min(h.count, o.start + o.count);
            for (let m = d, g = f; m < g; m++)
                fr.fromBufferAttribute(h, m),
                hl(fr, m, c, i, e, t, this)
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , n = Object.keys(t);
        if (n.length > 0) {
            const i = t[n[0]];
            if (i !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let s = 0, o = i.length; s < o; s++) {
                    const a = i[s].name || String(s);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = s
                }
            }
        }
    }
}
function hl(r, e, t, n, i, s, o) {
    const a = Da.distanceSqToPoint(r);
    if (a < t) {
        const c = new D;
        Da.closestPointToPoint(r, c),
        c.applyMatrix4(n);
        const l = i.ray.origin.distanceTo(c);
        if (l < i.near || l > i.far)
            return;
        s.push({
            distance: l,
            distanceToRay: Math.sqrt(a),
            point: c,
            index: e,
            face: null,
            faceIndex: null,
            barycoord: null,
            object: o
        })
    }
}
class _u extends Tt {
    constructor(e, t, n=Ai, i, s, o, a=_t, c=_t, l, u=Ls, h=1) {
        if (u !== Ls && u !== Cs)
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        const d = {
            width: e,
            height: t,
            depth: h
        };
        super(d, i, s, o, a, c, u, n, l),
        this.isDepthTexture = !0,
        this.flipY = !1,
        this.generateMipmaps = !1,
        this.compareFunction = null
    }
    copy(e) {
        return super.copy(e),
        this.source = new nc(Object.assign({}, e.image)),
        this.compareFunction = e.compareFunction,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return this.compareFunction !== null && (t.compareFunction = this.compareFunction),
        t
    }
}
const pr = new D
  , mr = new D
  , To = new D
  , Ar = new en;
class Na extends At {
    constructor(e=null, t=1) {
        if (super(),
        this.type = "EdgesGeometry",
        this.parameters = {
            geometry: e,
            thresholdAngle: t
        },
        e !== null) {
            const i = Math.pow(10, 4)
              , s = Math.cos(Fi * t)
              , o = e.getIndex()
              , a = e.getAttribute("position")
              , c = o ? o.count : a.count
              , l = [0, 0, 0]
              , u = ["a", "b", "c"]
              , h = new Array(3)
              , d = {}
              , f = [];
            for (let m = 0; m < c; m += 3) {
                o ? (l[0] = o.getX(m),
                l[1] = o.getX(m + 1),
                l[2] = o.getX(m + 2)) : (l[0] = m,
                l[1] = m + 1,
                l[2] = m + 2);
                const {a: g, b: A, c: p} = Ar;
                if (g.fromBufferAttribute(a, l[0]),
                A.fromBufferAttribute(a, l[1]),
                p.fromBufferAttribute(a, l[2]),
                Ar.getNormal(To),
                h[0] = `${Math.round(g.x * i)},${Math.round(g.y * i)},${Math.round(g.z * i)}`,
                h[1] = `${Math.round(A.x * i)},${Math.round(A.y * i)},${Math.round(A.z * i)}`,
                h[2] = `${Math.round(p.x * i)},${Math.round(p.y * i)},${Math.round(p.z * i)}`,
                !(h[0] === h[1] || h[1] === h[2] || h[2] === h[0]))
                    for (let S = 0; S < 3; S++) {
                        const w = (S + 1) % 3
                          , b = h[S]
                          , B = h[w]
                          , z = Ar[u[S]]
                          , I = Ar[u[w]]
                          , H = `${b}_${B}`
                          , P = `${B}_${b}`;
                        P in d && d[P] ? (To.dot(d[P].normal) <= s && (f.push(z.x, z.y, z.z),
                        f.push(I.x, I.y, I.z)),
                        d[P] = null) : H in d || (d[H] = {
                            index0: l[S],
                            index1: l[w],
                            normal: To.clone()
                        })
                    }
            }
            for (const m in d)
                if (d[m]) {
                    const {index0: g, index1: A} = d[m];
                    pr.fromBufferAttribute(a, g),
                    mr.fromBufferAttribute(a, A),
                    f.push(pr.x, pr.y, pr.z),
                    f.push(mr.x, mr.y, mr.z)
                }
            this.setAttribute("position", new yt(f,3))
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
}
class Sn {
    constructor() {
        this.type = "Curve",
        this.arcLengthDivisions = 200,
        this.needsUpdate = !1,
        this.cacheArcLengths = null
    }
    getPoint() {
        console.warn("THREE.Curve: .getPoint() not implemented.")
    }
    getPointAt(e, t) {
        const n = this.getUtoTmapping(e);
        return this.getPoint(n, t)
    }
    getPoints(e=5) {
        const t = [];
        for (let n = 0; n <= e; n++)
            t.push(this.getPoint(n / e));
        return t
    }
    getSpacedPoints(e=5) {
        const t = [];
        for (let n = 0; n <= e; n++)
            t.push(this.getPointAt(n / e));
        return t
    }
    getLength() {
        const e = this.getLengths();
        return e[e.length - 1]
    }
    getLengths(e=this.arcLengthDivisions) {
        if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
            return this.cacheArcLengths;
        this.needsUpdate = !1;
        const t = [];
        let n, i = this.getPoint(0), s = 0;
        t.push(0);
        for (let o = 1; o <= e; o++)
            n = this.getPoint(o / e),
            s += n.distanceTo(i),
            t.push(s),
            i = n;
        return this.cacheArcLengths = t,
        t
    }
    updateArcLengths() {
        this.needsUpdate = !0,
        this.getLengths()
    }
    getUtoTmapping(e, t=null) {
        const n = this.getLengths();
        let i = 0;
        const s = n.length;
        let o;
        t ? o = t : o = e * n[s - 1];
        let a = 0, c = s - 1, l;
        for (; a <= c; )
            if (i = Math.floor(a + (c - a) / 2),
            l = n[i] - o,
            l < 0)
                a = i + 1;
            else if (l > 0)
                c = i - 1;
            else {
                c = i;
                break
            }
        if (i = c,
        n[i] === o)
            return i / (s - 1);
        const u = n[i]
          , d = n[i + 1] - u
          , f = (o - u) / d;
        return (i + f) / (s - 1)
    }
    getTangent(e, t) {
        let i = e - 1e-4
          , s = e + 1e-4;
        i < 0 && (i = 0),
        s > 1 && (s = 1);
        const o = this.getPoint(i)
          , a = this.getPoint(s)
          , c = t || (o.isVector2 ? new Ae : new D);
        return c.copy(a).sub(o).normalize(),
        c
    }
    getTangentAt(e, t) {
        const n = this.getUtoTmapping(e);
        return this.getTangent(n, t)
    }
    computeFrenetFrames(e, t=!1) {
        const n = new D
          , i = []
          , s = []
          , o = []
          , a = new D
          , c = new We;
        for (let f = 0; f <= e; f++) {
            const m = f / e;
            i[f] = this.getTangentAt(m, new D)
        }
        s[0] = new D,
        o[0] = new D;
        let l = Number.MAX_VALUE;
        const u = Math.abs(i[0].x)
          , h = Math.abs(i[0].y)
          , d = Math.abs(i[0].z);
        u <= l && (l = u,
        n.set(1, 0, 0)),
        h <= l && (l = h,
        n.set(0, 1, 0)),
        d <= l && n.set(0, 0, 1),
        a.crossVectors(i[0], n).normalize(),
        s[0].crossVectors(i[0], a),
        o[0].crossVectors(i[0], s[0]);
        for (let f = 1; f <= e; f++) {
            if (s[f] = s[f - 1].clone(),
            o[f] = o[f - 1].clone(),
            a.crossVectors(i[f - 1], i[f]),
            a.length() > Number.EPSILON) {
                a.normalize();
                const m = Math.acos(Ke(i[f - 1].dot(i[f]), -1, 1));
                s[f].applyMatrix4(c.makeRotationAxis(a, m))
            }
            o[f].crossVectors(i[f], s[f])
        }
        if (t === !0) {
            let f = Math.acos(Ke(s[0].dot(s[e]), -1, 1));
            f /= e,
            i[0].dot(a.crossVectors(s[0], s[e])) > 0 && (f = -f);
            for (let m = 1; m <= e; m++)
                s[m].applyMatrix4(c.makeRotationAxis(i[m], f * m)),
                o[m].crossVectors(i[m], s[m])
        }
        return {
            tangents: i,
            normals: s,
            binormals: o
        }
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions,
        this
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.7,
                type: "Curve",
                generator: "Curve.toJSON"
            }
        };
        return e.arcLengthDivisions = this.arcLengthDivisions,
        e.type = this.type,
        e
    }
    fromJSON(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions,
        this
    }
}
class ac extends Sn {
    constructor(e=0, t=0, n=1, i=1, s=0, o=Math.PI * 2, a=!1, c=0) {
        super(),
        this.isEllipseCurve = !0,
        this.type = "EllipseCurve",
        this.aX = e,
        this.aY = t,
        this.xRadius = n,
        this.yRadius = i,
        this.aStartAngle = s,
        this.aEndAngle = o,
        this.aClockwise = a,
        this.aRotation = c
    }
    getPoint(e, t=new Ae) {
        const n = t
          , i = Math.PI * 2;
        let s = this.aEndAngle - this.aStartAngle;
        const o = Math.abs(s) < Number.EPSILON;
        for (; s < 0; )
            s += i;
        for (; s > i; )
            s -= i;
        s < Number.EPSILON && (o ? s = 0 : s = i),
        this.aClockwise === !0 && !o && (s === i ? s = -i : s = s - i);
        const a = this.aStartAngle + e * s;
        let c = this.aX + this.xRadius * Math.cos(a)
          , l = this.aY + this.yRadius * Math.sin(a);
        if (this.aRotation !== 0) {
            const u = Math.cos(this.aRotation)
              , h = Math.sin(this.aRotation)
              , d = c - this.aX
              , f = l - this.aY;
            c = d * u - f * h + this.aX,
            l = d * h + f * u + this.aY
        }
        return n.set(c, l)
    }
    copy(e) {
        return super.copy(e),
        this.aX = e.aX,
        this.aY = e.aY,
        this.xRadius = e.xRadius,
        this.yRadius = e.yRadius,
        this.aStartAngle = e.aStartAngle,
        this.aEndAngle = e.aEndAngle,
        this.aClockwise = e.aClockwise,
        this.aRotation = e.aRotation,
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.aX = this.aX,
        e.aY = this.aY,
        e.xRadius = this.xRadius,
        e.yRadius = this.yRadius,
        e.aStartAngle = this.aStartAngle,
        e.aEndAngle = this.aEndAngle,
        e.aClockwise = this.aClockwise,
        e.aRotation = this.aRotation,
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.aX = e.aX,
        this.aY = e.aY,
        this.xRadius = e.xRadius,
        this.yRadius = e.yRadius,
        this.aStartAngle = e.aStartAngle,
        this.aEndAngle = e.aEndAngle,
        this.aClockwise = e.aClockwise,
        this.aRotation = e.aRotation,
        this
    }
}
class rf extends ac {
    constructor(e, t, n, i, s, o) {
        super(e, t, n, n, i, s, o),
        this.isArcCurve = !0,
        this.type = "ArcCurve"
    }
}
function cc() {
    let r = 0
      , e = 0
      , t = 0
      , n = 0;
    function i(s, o, a, c) {
        r = s,
        e = a,
        t = -3 * s + 3 * o - 2 * a - c,
        n = 2 * s - 2 * o + a + c
    }
    return {
        initCatmullRom: function(s, o, a, c, l) {
            i(o, a, l * (a - s), l * (c - o))
        },
        initNonuniformCatmullRom: function(s, o, a, c, l, u, h) {
            let d = (o - s) / l - (a - s) / (l + u) + (a - o) / u
              , f = (a - o) / u - (c - o) / (u + h) + (c - a) / h;
            d *= u,
            f *= u,
            i(o, a, d, f)
        },
        calc: function(s) {
            const o = s * s
              , a = o * s;
            return r + e * s + t * o + n * a
        }
    }
}
const gr = new D
  , Eo = new cc
  , Po = new cc
  , Lo = new cc;
class of extends Sn {
    constructor(e=[], t=!1, n="centripetal", i=.5) {
        super(),
        this.isCatmullRomCurve3 = !0,
        this.type = "CatmullRomCurve3",
        this.points = e,
        this.closed = t,
        this.curveType = n,
        this.tension = i
    }
    getPoint(e, t=new D) {
        const n = t
          , i = this.points
          , s = i.length
          , o = (s - (this.closed ? 0 : 1)) * e;
        let a = Math.floor(o)
          , c = o - a;
        this.closed ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s : c === 0 && a === s - 1 && (a = s - 2,
        c = 1);
        let l, u;
        this.closed || a > 0 ? l = i[(a - 1) % s] : (gr.subVectors(i[0], i[1]).add(i[0]),
        l = gr);
        const h = i[a % s]
          , d = i[(a + 1) % s];
        if (this.closed || a + 2 < s ? u = i[(a + 2) % s] : (gr.subVectors(i[s - 1], i[s - 2]).add(i[s - 1]),
        u = gr),
        this.curveType === "centripetal" || this.curveType === "chordal") {
            const f = this.curveType === "chordal" ? .5 : .25;
            let m = Math.pow(l.distanceToSquared(h), f)
              , g = Math.pow(h.distanceToSquared(d), f)
              , A = Math.pow(d.distanceToSquared(u), f);
            g < 1e-4 && (g = 1),
            m < 1e-4 && (m = g),
            A < 1e-4 && (A = g),
            Eo.initNonuniformCatmullRom(l.x, h.x, d.x, u.x, m, g, A),
            Po.initNonuniformCatmullRom(l.y, h.y, d.y, u.y, m, g, A),
            Lo.initNonuniformCatmullRom(l.z, h.z, d.z, u.z, m, g, A)
        } else
            this.curveType === "catmullrom" && (Eo.initCatmullRom(l.x, h.x, d.x, u.x, this.tension),
            Po.initCatmullRom(l.y, h.y, d.y, u.y, this.tension),
            Lo.initCatmullRom(l.z, h.z, d.z, u.z, this.tension));
        return n.set(Eo.calc(c), Po.calc(c), Lo.calc(c)),
        n
    }
    copy(e) {
        super.copy(e),
        this.points = [];
        for (let t = 0, n = e.points.length; t < n; t++) {
            const i = e.points[t];
            this.points.push(i.clone())
        }
        return this.closed = e.closed,
        this.curveType = e.curveType,
        this.tension = e.tension,
        this
    }
    toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, n = this.points.length; t < n; t++) {
            const i = this.points[t];
            e.points.push(i.toArray())
        }
        return e.closed = this.closed,
        e.curveType = this.curveType,
        e.tension = this.tension,
        e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.points = [];
        for (let t = 0, n = e.points.length; t < n; t++) {
            const i = e.points[t];
            this.points.push(new D().fromArray(i))
        }
        return this.closed = e.closed,
        this.curveType = e.curveType,
        this.tension = e.tension,
        this
    }
}
function dl(r, e, t, n, i) {
    const s = (n - e) * .5
      , o = (i - t) * .5
      , a = r * r
      , c = r * a;
    return (2 * t - 2 * n + s + o) * c + (-3 * t + 3 * n - 2 * s - o) * a + s * r + t
}
function af(r, e) {
    const t = 1 - r;
    return t * t * e
}
function cf(r, e) {
    return 2 * (1 - r) * r * e
}
function lf(r, e) {
    return r * r * e
}
function Ms(r, e, t, n) {
    return af(r, e) + cf(r, t) + lf(r, n)
}
function uf(r, e) {
    const t = 1 - r;
    return t * t * t * e
}
function hf(r, e) {
    const t = 1 - r;
    return 3 * t * t * r * e
}
function df(r, e) {
    return 3 * (1 - r) * r * r * e
}
function ff(r, e) {
    return r * r * r * e
}
function ws(r, e, t, n, i) {
    return uf(r, e) + hf(r, t) + df(r, n) + ff(r, i)
}
class Hu extends Sn {
    constructor(e=new Ae, t=new Ae, n=new Ae, i=new Ae) {
        super(),
        this.isCubicBezierCurve = !0,
        this.type = "CubicBezierCurve",
        this.v0 = e,
        this.v1 = t,
        this.v2 = n,
        this.v3 = i
    }
    getPoint(e, t=new Ae) {
        const n = t
          , i = this.v0
          , s = this.v1
          , o = this.v2
          , a = this.v3;
        return n.set(ws(e, i.x, s.x, o.x, a.x), ws(e, i.y, s.y, o.y, a.y)),
        n
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e.v3 = this.v3.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
    }
}
class pf extends Sn {
    constructor(e=new D, t=new D, n=new D, i=new D) {
        super(),
        this.isCubicBezierCurve3 = !0,
        this.type = "CubicBezierCurve3",
        this.v0 = e,
        this.v1 = t,
        this.v2 = n,
        this.v3 = i
    }
    getPoint(e, t=new D) {
        const n = t
          , i = this.v0
          , s = this.v1
          , o = this.v2
          , a = this.v3;
        return n.set(ws(e, i.x, s.x, o.x, a.x), ws(e, i.y, s.y, o.y, a.y), ws(e, i.z, s.z, o.z, a.z)),
        n
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e.v3 = this.v3.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
    }
}
class Xu extends Sn {
    constructor(e=new Ae, t=new Ae) {
        super(),
        this.isLineCurve = !0,
        this.type = "LineCurve",
        this.v1 = e,
        this.v2 = t
    }
    getPoint(e, t=new Ae) {
        const n = t;
        return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
        n.multiplyScalar(e).add(this.v1)),
        n
    }
    getPointAt(e, t) {
        return this.getPoint(e, t)
    }
    getTangent(e, t=new Ae) {
        return t.subVectors(this.v2, this.v1).normalize()
    }
    getTangentAt(e, t) {
        return this.getTangent(e, t)
    }
    copy(e) {
        return super.copy(e),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class mf extends Sn {
    constructor(e=new D, t=new D) {
        super(),
        this.isLineCurve3 = !0,
        this.type = "LineCurve3",
        this.v1 = e,
        this.v2 = t
    }
    getPoint(e, t=new D) {
        const n = t;
        return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
        n.multiplyScalar(e).add(this.v1)),
        n
    }
    getPointAt(e, t) {
        return this.getPoint(e, t)
    }
    getTangent(e, t=new D) {
        return t.subVectors(this.v2, this.v1).normalize()
    }
    getTangentAt(e, t) {
        return this.getTangent(e, t)
    }
    copy(e) {
        return super.copy(e),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class Gu extends Sn {
    constructor(e=new Ae, t=new Ae, n=new Ae) {
        super(),
        this.isQuadraticBezierCurve = !0,
        this.type = "QuadraticBezierCurve",
        this.v0 = e,
        this.v1 = t,
        this.v2 = n
    }
    getPoint(e, t=new Ae) {
        const n = t
          , i = this.v0
          , s = this.v1
          , o = this.v2;
        return n.set(Ms(e, i.x, s.x, o.x), Ms(e, i.y, s.y, o.y)),
        n
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class Af extends Sn {
    constructor(e=new D, t=new D, n=new D) {
        super(),
        this.isQuadraticBezierCurve3 = !0,
        this.type = "QuadraticBezierCurve3",
        this.v0 = e,
        this.v1 = t,
        this.v2 = n
    }
    getPoint(e, t=new D) {
        const n = t
          , i = this.v0
          , s = this.v1
          , o = this.v2;
        return n.set(Ms(e, i.x, s.x, o.x), Ms(e, i.y, s.y, o.y), Ms(e, i.z, s.z, o.z)),
        n
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class Vu extends Sn {
    constructor(e=[]) {
        super(),
        this.isSplineCurve = !0,
        this.type = "SplineCurve",
        this.points = e
    }
    getPoint(e, t=new Ae) {
        const n = t
          , i = this.points
          , s = (i.length - 1) * e
          , o = Math.floor(s)
          , a = s - o
          , c = i[o === 0 ? o : o - 1]
          , l = i[o]
          , u = i[o > i.length - 2 ? i.length - 1 : o + 1]
          , h = i[o > i.length - 3 ? i.length - 1 : o + 2];
        return n.set(dl(a, c.x, l.x, u.x, h.x), dl(a, c.y, l.y, u.y, h.y)),
        n
    }
    copy(e) {
        super.copy(e),
        this.points = [];
        for (let t = 0, n = e.points.length; t < n; t++) {
            const i = e.points[t];
            this.points.push(i.clone())
        }
        return this
    }
    toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, n = this.points.length; t < n; t++) {
            const i = this.points[t];
            e.points.push(i.toArray())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.points = [];
        for (let t = 0, n = e.points.length; t < n; t++) {
            const i = e.points[t];
            this.points.push(new Ae().fromArray(i))
        }
        return this
    }
}
var Oa = Object.freeze({
    __proto__: null,
    ArcCurve: rf,
    CatmullRomCurve3: of,
    CubicBezierCurve: Hu,
    CubicBezierCurve3: pf,
    EllipseCurve: ac,
    LineCurve: Xu,
    LineCurve3: mf,
    QuadraticBezierCurve: Gu,
    QuadraticBezierCurve3: Af,
    SplineCurve: Vu
});
class gf extends Sn {
    constructor() {
        super(),
        this.type = "CurvePath",
        this.curves = [],
        this.autoClose = !1
    }
    add(e) {
        this.curves.push(e)
    }
    closePath() {
        const e = this.curves[0].getPoint(0)
          , t = this.curves[this.curves.length - 1].getPoint(1);
        if (!e.equals(t)) {
            const n = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
            this.curves.push(new Oa[n](t,e))
        }
        return this
    }
    getPoint(e, t) {
        const n = e * this.getLength()
          , i = this.getCurveLengths();
        let s = 0;
        for (; s < i.length; ) {
            if (i[s] >= n) {
                const o = i[s] - n
                  , a = this.curves[s]
                  , c = a.getLength()
                  , l = c === 0 ? 0 : 1 - o / c;
                return a.getPointAt(l, t)
            }
            s++
        }
        return null
    }
    getLength() {
        const e = this.getCurveLengths();
        return e[e.length - 1]
    }
    updateArcLengths() {
        this.needsUpdate = !0,
        this.cacheLengths = null,
        this.getCurveLengths()
    }
    getCurveLengths() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
            return this.cacheLengths;
        const e = [];
        let t = 0;
        for (let n = 0, i = this.curves.length; n < i; n++)
            t += this.curves[n].getLength(),
            e.push(t);
        return this.cacheLengths = e,
        e
    }
    getSpacedPoints(e=40) {
        const t = [];
        for (let n = 0; n <= e; n++)
            t.push(this.getPoint(n / e));
        return this.autoClose && t.push(t[0]),
        t
    }
    getPoints(e=12) {
        const t = [];
        let n;
        for (let i = 0, s = this.curves; i < s.length; i++) {
            const o = s[i]
              , a = o.isEllipseCurve ? e * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e
              , c = o.getPoints(a);
            for (let l = 0; l < c.length; l++) {
                const u = c[l];
                n && n.equals(u) || (t.push(u),
                n = u)
            }
        }
        return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]),
        t
    }
    copy(e) {
        super.copy(e),
        this.curves = [];
        for (let t = 0, n = e.curves.length; t < n; t++) {
            const i = e.curves[t];
            this.curves.push(i.clone())
        }
        return this.autoClose = e.autoClose,
        this
    }
    toJSON() {
        const e = super.toJSON();
        e.autoClose = this.autoClose,
        e.curves = [];
        for (let t = 0, n = this.curves.length; t < n; t++) {
            const i = this.curves[t];
            e.curves.push(i.toJSON())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.autoClose = e.autoClose,
        this.curves = [];
        for (let t = 0, n = e.curves.length; t < n; t++) {
            const i = e.curves[t];
            this.curves.push(new Oa[i.type]().fromJSON(i))
        }
        return this
    }
}
class za extends gf {
    constructor(e) {
        super(),
        this.type = "Path",
        this.currentPoint = new Ae,
        e && this.setFromPoints(e)
    }
    setFromPoints(e) {
        this.moveTo(e[0].x, e[0].y);
        for (let t = 1, n = e.length; t < n; t++)
            this.lineTo(e[t].x, e[t].y);
        return this
    }
    moveTo(e, t) {
        return this.currentPoint.set(e, t),
        this
    }
    lineTo(e, t) {
        const n = new Xu(this.currentPoint.clone(),new Ae(e,t));
        return this.curves.push(n),
        this.currentPoint.set(e, t),
        this
    }
    quadraticCurveTo(e, t, n, i) {
        const s = new Gu(this.currentPoint.clone(),new Ae(e,t),new Ae(n,i));
        return this.curves.push(s),
        this.currentPoint.set(n, i),
        this
    }
    bezierCurveTo(e, t, n, i, s, o) {
        const a = new Hu(this.currentPoint.clone(),new Ae(e,t),new Ae(n,i),new Ae(s,o));
        return this.curves.push(a),
        this.currentPoint.set(s, o),
        this
    }
    splineThru(e) {
        const t = [this.currentPoint.clone()].concat(e)
          , n = new Vu(t);
        return this.curves.push(n),
        this.currentPoint.copy(e[e.length - 1]),
        this
    }
    arc(e, t, n, i, s, o) {
        const a = this.currentPoint.x
          , c = this.currentPoint.y;
        return this.absarc(e + a, t + c, n, i, s, o),
        this
    }
    absarc(e, t, n, i, s, o) {
        return this.absellipse(e, t, n, n, i, s, o),
        this
    }
    ellipse(e, t, n, i, s, o, a, c) {
        const l = this.currentPoint.x
          , u = this.currentPoint.y;
        return this.absellipse(e + l, t + u, n, i, s, o, a, c),
        this
    }
    absellipse(e, t, n, i, s, o, a, c) {
        const l = new ac(e,t,n,i,s,o,a,c);
        if (this.curves.length > 0) {
            const h = l.getPoint(0);
            h.equals(this.currentPoint) || this.lineTo(h.x, h.y)
        }
        this.curves.push(l);
        const u = l.getPoint(1);
        return this.currentPoint.copy(u),
        this
    }
    copy(e) {
        return super.copy(e),
        this.currentPoint.copy(e.currentPoint),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.currentPoint = this.currentPoint.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.currentPoint.fromArray(e.currentPoint),
        this
    }
}
class Ss extends za {
    constructor(e) {
        super(e),
        this.uuid = nn(),
        this.type = "Shape",
        this.holes = []
    }
    getPointsHoles(e) {
        const t = [];
        for (let n = 0, i = this.holes.length; n < i; n++)
            t[n] = this.holes[n].getPoints(e);
        return t
    }
    extractPoints(e) {
        return {
            shape: this.getPoints(e),
            holes: this.getPointsHoles(e)
        }
    }
    copy(e) {
        super.copy(e),
        this.holes = [];
        for (let t = 0, n = e.holes.length; t < n; t++) {
            const i = e.holes[t];
            this.holes.push(i.clone())
        }
        return this
    }
    toJSON() {
        const e = super.toJSON();
        e.uuid = this.uuid,
        e.holes = [];
        for (let t = 0, n = this.holes.length; t < n; t++) {
            const i = this.holes[t];
            e.holes.push(i.toJSON())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.uuid = e.uuid,
        this.holes = [];
        for (let t = 0, n = e.holes.length; t < n; t++) {
            const i = e.holes[t];
            this.holes.push(new za().fromJSON(i))
        }
        return this
    }
}
function vf(r, e, t=2) {
    const n = e && e.length
      , i = n ? e[0] * t : r.length;
    let s = Wu(r, 0, i, t, !0);
    const o = [];
    if (!s || s.next === s.prev)
        return o;
    let a, c, l;
    if (n && (s = wf(r, e, s, t)),
    r.length > 80 * t) {
        a = 1 / 0,
        c = 1 / 0;
        let u = -1 / 0
          , h = -1 / 0;
        for (let d = t; d < i; d += t) {
            const f = r[d]
              , m = r[d + 1];
            f < a && (a = f),
            m < c && (c = m),
            f > u && (u = f),
            m > h && (h = m)
        }
        l = Math.max(u - a, h - c),
        l = l !== 0 ? 32767 / l : 0
    }
    return Os(s, o, t, a, c, l, 0),
    o
}
function Wu(r, e, t, n, i) {
    let s;
    if (i === zf(r, e, t, n) > 0)
        for (let o = e; o < t; o += n)
            s = fl(o / n | 0, r[o], r[o + 1], s);
    else
        for (let o = t - n; o >= e; o -= n)
            s = fl(o / n | 0, r[o], r[o + 1], s);
    return s && Zi(s, s.next) && (Is(s),
    s = s.next),
    s
}
function vi(r, e) {
    if (!r)
        return r;
    e || (e = r);
    let t = r, n;
    do
        if (n = !1,
        !t.steiner && (Zi(t, t.next) || ft(t.prev, t, t.next) === 0)) {
            if (Is(t),
            t = e = t.prev,
            t === t.next)
                break;
            n = !0
        } else
            t = t.next;
    while (n || t !== e);
    return e
}
function Os(r, e, t, n, i, s, o) {
    if (!r)
        return;
    !o && s && Lf(r, n, i, s);
    let a = r;
    for (; r.prev !== r.next; ) {
        const c = r.prev
          , l = r.next;
        if (s ? yf(r, n, i, s) : xf(r)) {
            e.push(c.i, r.i, l.i),
            Is(r),
            r = l.next,
            a = l.next;
            continue
        }
        if (r = l,
        r === a) {
            o ? o === 1 ? (r = bf(vi(r), e),
            Os(r, e, t, n, i, s, 2)) : o === 2 && Mf(r, e, t, n, i, s) : Os(vi(r), e, t, n, i, s, 1);
            break
        }
    }
}
function xf(r) {
    const e = r.prev
      , t = r
      , n = r.next;
    if (ft(e, t, n) >= 0)
        return !1;
    const i = e.x
      , s = t.x
      , o = n.x
      , a = e.y
      , c = t.y
      , l = n.y
      , u = Math.min(i, s, o)
      , h = Math.min(a, c, l)
      , d = Math.max(i, s, o)
      , f = Math.max(a, c, l);
    let m = n.next;
    for (; m !== e; ) {
        if (m.x >= u && m.x <= d && m.y >= h && m.y <= f && gs(i, a, s, c, o, l, m.x, m.y) && ft(m.prev, m, m.next) >= 0)
            return !1;
        m = m.next
    }
    return !0
}
function yf(r, e, t, n) {
    const i = r.prev
      , s = r
      , o = r.next;
    if (ft(i, s, o) >= 0)
        return !1;
    const a = i.x
      , c = s.x
      , l = o.x
      , u = i.y
      , h = s.y
      , d = o.y
      , f = Math.min(a, c, l)
      , m = Math.min(u, h, d)
      , g = Math.max(a, c, l)
      , A = Math.max(u, h, d)
      , p = Ia(f, m, e, t, n)
      , S = Ia(g, A, e, t, n);
    let w = r.prevZ
      , b = r.nextZ;
    for (; w && w.z >= p && b && b.z <= S; ) {
        if (w.x >= f && w.x <= g && w.y >= m && w.y <= A && w !== i && w !== o && gs(a, u, c, h, l, d, w.x, w.y) && ft(w.prev, w, w.next) >= 0 || (w = w.prevZ,
        b.x >= f && b.x <= g && b.y >= m && b.y <= A && b !== i && b !== o && gs(a, u, c, h, l, d, b.x, b.y) && ft(b.prev, b, b.next) >= 0))
            return !1;
        b = b.nextZ
    }
    for (; w && w.z >= p; ) {
        if (w.x >= f && w.x <= g && w.y >= m && w.y <= A && w !== i && w !== o && gs(a, u, c, h, l, d, w.x, w.y) && ft(w.prev, w, w.next) >= 0)
            return !1;
        w = w.prevZ
    }
    for (; b && b.z <= S; ) {
        if (b.x >= f && b.x <= g && b.y >= m && b.y <= A && b !== i && b !== o && gs(a, u, c, h, l, d, b.x, b.y) && ft(b.prev, b, b.next) >= 0)
            return !1;
        b = b.nextZ
    }
    return !0
}
function bf(r, e) {
    let t = r;
    do {
        const n = t.prev
          , i = t.next.next;
        !Zi(n, i) && ku(n, t, t.next, i) && zs(n, i) && zs(i, n) && (e.push(n.i, t.i, i.i),
        Is(t),
        Is(t.next),
        t = r = i),
        t = t.next
    } while (t !== r);
    return vi(t)
}
function Mf(r, e, t, n, i, s) {
    let o = r;
    do {
        let a = o.next.next;
        for (; a !== o.prev; ) {
            if (o.i !== a.i && Df(o, a)) {
                let c = Yu(o, a);
                o = vi(o, o.next),
                c = vi(c, c.next),
                Os(o, e, t, n, i, s, 0),
                Os(c, e, t, n, i, s, 0);
                return
            }
            a = a.next
        }
        o = o.next
    } while (o !== r)
}
function wf(r, e, t, n) {
    const i = [];
    for (let s = 0, o = e.length; s < o; s++) {
        const a = e[s] * n
          , c = s < o - 1 ? e[s + 1] * n : r.length
          , l = Wu(r, a, c, n, !1);
        l === l.next && (l.steiner = !0),
        i.push(Rf(l))
    }
    i.sort(Sf);
    for (let s = 0; s < i.length; s++)
        t = Tf(i[s], t);
    return t
}
function Sf(r, e) {
    let t = r.x - e.x;
    if (t === 0 && (t = r.y - e.y,
    t === 0)) {
        const n = (r.next.y - r.y) / (r.next.x - r.x)
          , i = (e.next.y - e.y) / (e.next.x - e.x);
        t = n - i
    }
    return t
}
function Tf(r, e) {
    const t = Ef(r, e);
    if (!t)
        return e;
    const n = Yu(t, r);
    return vi(n, n.next),
    vi(t, t.next)
}
function Ef(r, e) {
    let t = e;
    const n = r.x
      , i = r.y;
    let s = -1 / 0, o;
    if (Zi(r, t))
        return t;
    do {
        if (Zi(r, t.next))
            return t.next;
        if (i <= t.y && i >= t.next.y && t.next.y !== t.y) {
            const h = t.x + (i - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
            if (h <= n && h > s && (s = h,
            o = t.x < t.next.x ? t : t.next,
            h === n))
                return o
        }
        t = t.next
    } while (t !== e);
    if (!o)
        return null;
    const a = o
      , c = o.x
      , l = o.y;
    let u = 1 / 0;
    t = o;
    do {
        if (n >= t.x && t.x >= c && n !== t.x && ju(i < l ? n : s, i, c, l, i < l ? s : n, i, t.x, t.y)) {
            const h = Math.abs(i - t.y) / (n - t.x);
            zs(t, r) && (h < u || h === u && (t.x > o.x || t.x === o.x && Pf(o, t))) && (o = t,
            u = h)
        }
        t = t.next
    } while (t !== a);
    return o
}
function Pf(r, e) {
    return ft(r.prev, r, e.prev) < 0 && ft(e.next, r, r.next) < 0
}
function Lf(r, e, t, n) {
    let i = r;
    do
        i.z === 0 && (i.z = Ia(i.x, i.y, e, t, n)),
        i.prevZ = i.prev,
        i.nextZ = i.next,
        i = i.next;
    while (i !== r);
    i.prevZ.nextZ = null,
    i.prevZ = null,
    Cf(i)
}
function Cf(r) {
    let e, t = 1;
    do {
        let n = r, i;
        r = null;
        let s = null;
        for (e = 0; n; ) {
            e++;
            let o = n
              , a = 0;
            for (let l = 0; l < t && (a++,
            o = o.nextZ,
            !!o); l++)
                ;
            let c = t;
            for (; a > 0 || c > 0 && o; )
                a !== 0 && (c === 0 || !o || n.z <= o.z) ? (i = n,
                n = n.nextZ,
                a--) : (i = o,
                o = o.nextZ,
                c--),
                s ? s.nextZ = i : r = i,
                i.prevZ = s,
                s = i;
            n = o
        }
        s.nextZ = null,
        t *= 2
    } while (e > 1);
    return r
}
function Ia(r, e, t, n, i) {
    return r = (r - t) * i | 0,
    e = (e - n) * i | 0,
    r = (r | r << 8) & 16711935,
    r = (r | r << 4) & 252645135,
    r = (r | r << 2) & 858993459,
    r = (r | r << 1) & 1431655765,
    e = (e | e << 8) & 16711935,
    e = (e | e << 4) & 252645135,
    e = (e | e << 2) & 858993459,
    e = (e | e << 1) & 1431655765,
    r | e << 1
}
function Rf(r) {
    let e = r
      , t = r;
    do
        (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e),
        e = e.next;
    while (e !== r);
    return t
}
function ju(r, e, t, n, i, s, o, a) {
    return (i - o) * (e - a) >= (r - o) * (s - a) && (r - o) * (n - a) >= (t - o) * (e - a) && (t - o) * (s - a) >= (i - o) * (n - a)
}
function gs(r, e, t, n, i, s, o, a) {
    return !(r === o && e === a) && ju(r, e, t, n, i, s, o, a)
}
function Df(r, e) {
    return r.next.i !== e.i && r.prev.i !== e.i && !Nf(r, e) && (zs(r, e) && zs(e, r) && Of(r, e) && (ft(r.prev, r, e.prev) || ft(r, e.prev, e)) || Zi(r, e) && ft(r.prev, r, r.next) > 0 && ft(e.prev, e, e.next) > 0)
}
function ft(r, e, t) {
    return (e.y - r.y) * (t.x - e.x) - (e.x - r.x) * (t.y - e.y)
}
function Zi(r, e) {
    return r.x === e.x && r.y === e.y
}
function ku(r, e, t, n) {
    const i = xr(ft(r, e, t))
      , s = xr(ft(r, e, n))
      , o = xr(ft(t, n, r))
      , a = xr(ft(t, n, e));
    return !!(i !== s && o !== a || i === 0 && vr(r, t, e) || s === 0 && vr(r, n, e) || o === 0 && vr(t, r, n) || a === 0 && vr(t, e, n))
}
function vr(r, e, t) {
    return e.x <= Math.max(r.x, t.x) && e.x >= Math.min(r.x, t.x) && e.y <= Math.max(r.y, t.y) && e.y >= Math.min(r.y, t.y)
}
function xr(r) {
    return r > 0 ? 1 : r < 0 ? -1 : 0
}
function Nf(r, e) {
    let t = r;
    do {
        if (t.i !== r.i && t.next.i !== r.i && t.i !== e.i && t.next.i !== e.i && ku(t, t.next, r, e))
            return !0;
        t = t.next
    } while (t !== r);
    return !1
}
function zs(r, e) {
    return ft(r.prev, r, r.next) < 0 ? ft(r, e, r.next) >= 0 && ft(r, r.prev, e) >= 0 : ft(r, e, r.prev) < 0 || ft(r, r.next, e) < 0
}
function Of(r, e) {
    let t = r
      , n = !1;
    const i = (r.x + e.x) / 2
      , s = (r.y + e.y) / 2;
    do
        t.y > s != t.next.y > s && t.next.y !== t.y && i < (t.next.x - t.x) * (s - t.y) / (t.next.y - t.y) + t.x && (n = !n),
        t = t.next;
    while (t !== r);
    return n
}
function Yu(r, e) {
    const t = Ua(r.i, r.x, r.y)
      , n = Ua(e.i, e.x, e.y)
      , i = r.next
      , s = e.prev;
    return r.next = e,
    e.prev = r,
    t.next = i,
    i.prev = t,
    n.next = t,
    t.prev = n,
    s.next = n,
    n.prev = s,
    n
}
function fl(r, e, t, n) {
    const i = Ua(r, e, t);
    return n ? (i.next = n.next,
    i.prev = n,
    n.next.prev = i,
    n.next = i) : (i.prev = i,
    i.next = i),
    i
}
function Is(r) {
    r.next.prev = r.prev,
    r.prev.next = r.next,
    r.prevZ && (r.prevZ.nextZ = r.nextZ),
    r.nextZ && (r.nextZ.prevZ = r.prevZ)
}
function Ua(r, e, t) {
    return {
        i: r,
        x: e,
        y: t,
        prev: null,
        next: null,
        z: 0,
        prevZ: null,
        nextZ: null,
        steiner: !1
    }
}
function zf(r, e, t, n) {
    let i = 0;
    for (let s = e, o = t - n; s < t; s += n)
        i += (r[o] - r[s]) * (r[s + 1] + r[o + 1]),
        o = s;
    return i
}
class If {
    static triangulate(e, t, n=2) {
        return vf(e, t, n)
    }
}
class bn {
    static area(e) {
        const t = e.length;
        let n = 0;
        for (let i = t - 1, s = 0; s < t; i = s++)
            n += e[i].x * e[s].y - e[s].x * e[i].y;
        return n * .5
    }
    static isClockWise(e) {
        return bn.area(e) < 0
    }
    static triangulateShape(e, t) {
        const n = []
          , i = []
          , s = [];
        pl(e),
        ml(n, e);
        let o = e.length;
        t.forEach(pl);
        for (let c = 0; c < t.length; c++)
            i.push(o),
            o += t[c].length,
            ml(n, t[c]);
        const a = If.triangulate(n, i);
        for (let c = 0; c < a.length; c += 3)
            s.push(a.slice(c, c + 3));
        return s
    }
}
function pl(r) {
    const e = r.length;
    e > 2 && r[e - 1].equals(r[0]) && r.pop()
}
function ml(r, e) {
    for (let t = 0; t < e.length; t++)
        r.push(e[t].x),
        r.push(e[t].y)
}
class lc extends At {
    constructor(e=new Ss([new Ae(.5,.5), new Ae(-.5,.5), new Ae(-.5,-.5), new Ae(.5,-.5)]), t={}) {
        super(),
        this.type = "ExtrudeGeometry",
        this.parameters = {
            shapes: e,
            options: t
        },
        e = Array.isArray(e) ? e : [e];
        const n = this
          , i = []
          , s = [];
        for (let a = 0, c = e.length; a < c; a++) {
            const l = e[a];
            o(l)
        }
        this.setAttribute("position", new yt(i,3)),
        this.setAttribute("uv", new yt(s,2)),
        this.computeVertexNormals();
        function o(a) {
            const c = []
              , l = t.curveSegments !== void 0 ? t.curveSegments : 12
              , u = t.steps !== void 0 ? t.steps : 1
              , h = t.depth !== void 0 ? t.depth : 1;
            let d = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0
              , f = t.bevelThickness !== void 0 ? t.bevelThickness : .2
              , m = t.bevelSize !== void 0 ? t.bevelSize : f - .1
              , g = t.bevelOffset !== void 0 ? t.bevelOffset : 0
              , A = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
            const p = t.extrudePath
              , S = t.UVGenerator !== void 0 ? t.UVGenerator : Uf;
            let w, b = !1, B, z, I, H;
            p && (w = p.getSpacedPoints(u),
            b = !0,
            d = !1,
            B = p.computeFrenetFrames(u, !1),
            z = new D,
            I = new D,
            H = new D),
            d || (A = 0,
            f = 0,
            m = 0,
            g = 0);
            const P = a.extractPoints(l);
            let T = P.shape;
            const _ = P.holes;
            if (!bn.isClockWise(T)) {
                T = T.reverse();
                for (let x = 0, V = _.length; x < V; x++) {
                    const W = _[x];
                    bn.isClockWise(W) && (_[x] = W.reverse())
                }
            }
            function k(x) {
                const W = 10000000000000001e-36;
                let oe = x[0];
                for (let $ = 1; $ <= x.length; $++) {
                    const me = $ % x.length
                      , he = x[me]
                      , ge = he.x - oe.x
                      , De = he.y - oe.y
                      , N = ge * ge + De * De
                      , M = Math.max(Math.abs(he.x), Math.abs(he.y), Math.abs(oe.x), Math.abs(oe.y))
                      , q = W * M * M;
                    if (N <= q) {
                        x.splice(me, 1),
                        $--;
                        continue
                    }
                    oe = he
                }
            }
            k(T),
            _.forEach(k);
            const U = _.length
              , F = T;
            for (let x = 0; x < U; x++) {
                const V = _[x];
                T = T.concat(V)
            }
            function O(x, V, W) {
                return V || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                x.clone().addScaledVector(V, W)
            }
            const y = T.length;
            function v(x, V, W) {
                let oe, $, me;
                const he = x.x - V.x
                  , ge = x.y - V.y
                  , De = W.x - x.x
                  , N = W.y - x.y
                  , M = he * he + ge * ge
                  , q = he * N - ge * De;
                if (Math.abs(q) > Number.EPSILON) {
                    const J = Math.sqrt(M)
                      , ee = Math.sqrt(De * De + N * N)
                      , te = V.x - ge / J
                      , we = V.y + he / J
                      , de = W.x - N / ee
                      , Ee = W.y + De / ee
                      , Pe = ((de - te) * N - (Ee - we) * De) / (he * N - ge * De);
                    oe = te + he * Pe - x.x,
                    $ = we + ge * Pe - x.y;
                    const fe = oe * oe + $ * $;
                    if (fe <= 2)
                        return new Ae(oe,$);
                    me = Math.sqrt(fe / 2)
                } else {
                    let J = !1;
                    he > Number.EPSILON ? De > Number.EPSILON && (J = !0) : he < -Number.EPSILON ? De < -Number.EPSILON && (J = !0) : Math.sign(ge) === Math.sign(N) && (J = !0),
                    J ? (oe = -ge,
                    $ = he,
                    me = Math.sqrt(M)) : (oe = he,
                    $ = ge,
                    me = Math.sqrt(M / 2))
                }
                return new Ae(oe / me,$ / me)
            }
            const L = [];
            for (let x = 0, V = F.length, W = V - 1, oe = x + 1; x < V; x++,
            W++,
            oe++)
                W === V && (W = 0),
                oe === V && (oe = 0),
                L[x] = v(F[x], F[W], F[oe]);
            const R = [];
            let C, Y = L.concat();
            for (let x = 0, V = U; x < V; x++) {
                const W = _[x];
                C = [];
                for (let oe = 0, $ = W.length, me = $ - 1, he = oe + 1; oe < $; oe++,
                me++,
                he++)
                    me === $ && (me = 0),
                    he === $ && (he = 0),
                    C[oe] = v(W[oe], W[me], W[he]);
                R.push(C),
                Y = Y.concat(C)
            }
            let ue;
            if (A === 0)
                ue = bn.triangulateShape(F, _);
            else {
                const x = []
                  , V = [];
                for (let W = 0; W < A; W++) {
                    const oe = W / A
                      , $ = f * Math.cos(oe * Math.PI / 2)
                      , me = m * Math.sin(oe * Math.PI / 2) + g;
                    for (let he = 0, ge = F.length; he < ge; he++) {
                        const De = O(F[he], L[he], me);
                        xe(De.x, De.y, -$),
                        oe === 0 && x.push(De)
                    }
                    for (let he = 0, ge = U; he < ge; he++) {
                        const De = _[he];
                        C = R[he];
                        const N = [];
                        for (let M = 0, q = De.length; M < q; M++) {
                            const J = O(De[M], C[M], me);
                            xe(J.x, J.y, -$),
                            oe === 0 && N.push(J)
                        }
                        oe === 0 && V.push(N)
                    }
                }
                ue = bn.triangulateShape(x, V)
            }
            const X = ue.length
              , ne = m + g;
            for (let x = 0; x < y; x++) {
                const V = d ? O(T[x], Y[x], ne) : T[x];
                b ? (I.copy(B.normals[0]).multiplyScalar(V.x),
                z.copy(B.binormals[0]).multiplyScalar(V.y),
                H.copy(w[0]).add(I).add(z),
                xe(H.x, H.y, H.z)) : xe(V.x, V.y, 0)
            }
            for (let x = 1; x <= u; x++)
                for (let V = 0; V < y; V++) {
                    const W = d ? O(T[V], Y[V], ne) : T[V];
                    b ? (I.copy(B.normals[x]).multiplyScalar(W.x),
                    z.copy(B.binormals[x]).multiplyScalar(W.y),
                    H.copy(w[x]).add(I).add(z),
                    xe(H.x, H.y, H.z)) : xe(W.x, W.y, h / u * x)
                }
            for (let x = A - 1; x >= 0; x--) {
                const V = x / A
                  , W = f * Math.cos(V * Math.PI / 2)
                  , oe = m * Math.sin(V * Math.PI / 2) + g;
                for (let $ = 0, me = F.length; $ < me; $++) {
                    const he = O(F[$], L[$], oe);
                    xe(he.x, he.y, h + W)
                }
                for (let $ = 0, me = _.length; $ < me; $++) {
                    const he = _[$];
                    C = R[$];
                    for (let ge = 0, De = he.length; ge < De; ge++) {
                        const N = O(he[ge], C[ge], oe);
                        b ? xe(N.x, N.y + w[u - 1].y, w[u - 1].x + W) : xe(N.x, N.y, h + W)
                    }
                }
            }
            ae(),
            ce();
            function ae() {
                const x = i.length / 3;
                if (d) {
                    let V = 0
                      , W = y * V;
                    for (let oe = 0; oe < X; oe++) {
                        const $ = ue[oe];
                        ye($[2] + W, $[1] + W, $[0] + W)
                    }
                    V = u + A * 2,
                    W = y * V;
                    for (let oe = 0; oe < X; oe++) {
                        const $ = ue[oe];
                        ye($[0] + W, $[1] + W, $[2] + W)
                    }
                } else {
                    for (let V = 0; V < X; V++) {
                        const W = ue[V];
                        ye(W[2], W[1], W[0])
                    }
                    for (let V = 0; V < X; V++) {
                        const W = ue[V];
                        ye(W[0] + y * u, W[1] + y * u, W[2] + y * u)
                    }
                }
                n.addGroup(x, i.length / 3 - x, 0)
            }
            function ce() {
                const x = i.length / 3;
                let V = 0;
                le(F, V),
                V += F.length;
                for (let W = 0, oe = _.length; W < oe; W++) {
                    const $ = _[W];
                    le($, V),
                    V += $.length
                }
                n.addGroup(x, i.length / 3 - x, 1)
            }
            function le(x, V) {
                let W = x.length;
                for (; --W >= 0; ) {
                    const oe = W;
                    let $ = W - 1;
                    $ < 0 && ($ = x.length - 1);
                    for (let me = 0, he = u + A * 2; me < he; me++) {
                        const ge = y * me
                          , De = y * (me + 1)
                          , N = V + oe + ge
                          , M = V + $ + ge
                          , q = V + $ + De
                          , J = V + oe + De;
                        Te(N, M, q, J)
                    }
                }
            }
            function xe(x, V, W) {
                c.push(x),
                c.push(V),
                c.push(W)
            }
            function ye(x, V, W) {
                G(x),
                G(V),
                G(W);
                const oe = i.length / 3
                  , $ = S.generateTopUV(n, i, oe - 3, oe - 2, oe - 1);
                K($[0]),
                K($[1]),
                K($[2])
            }
            function Te(x, V, W, oe) {
                G(x),
                G(V),
                G(oe),
                G(V),
                G(W),
                G(oe);
                const $ = i.length / 3
                  , me = S.generateSideWallUV(n, i, $ - 6, $ - 3, $ - 2, $ - 1);
                K(me[0]),
                K(me[1]),
                K(me[3]),
                K(me[1]),
                K(me[2]),
                K(me[3])
            }
            function G(x) {
                i.push(c[x * 3 + 0]),
                i.push(c[x * 3 + 1]),
                i.push(c[x * 3 + 2])
            }
            function K(x) {
                s.push(x.x),
                s.push(x.y)
            }
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    toJSON() {
        const e = super.toJSON()
          , t = this.parameters.shapes
          , n = this.parameters.options;
        return Bf(t, n, e)
    }
    static fromJSON(e, t) {
        const n = [];
        for (let s = 0, o = e.shapes.length; s < o; s++) {
            const a = t[e.shapes[s]];
            n.push(a)
        }
        const i = e.options.extrudePath;
        return i !== void 0 && (e.options.extrudePath = new Oa[i.type]().fromJSON(i)),
        new lc(n,e.options)
    }
}
const Uf = {
    generateTopUV: function(r, e, t, n, i) {
        const s = e[t * 3]
          , o = e[t * 3 + 1]
          , a = e[n * 3]
          , c = e[n * 3 + 1]
          , l = e[i * 3]
          , u = e[i * 3 + 1];
        return [new Ae(s,o), new Ae(a,c), new Ae(l,u)]
    },
    generateSideWallUV: function(r, e, t, n, i, s) {
        const o = e[t * 3]
          , a = e[t * 3 + 1]
          , c = e[t * 3 + 2]
          , l = e[n * 3]
          , u = e[n * 3 + 1]
          , h = e[n * 3 + 2]
          , d = e[i * 3]
          , f = e[i * 3 + 1]
          , m = e[i * 3 + 2]
          , g = e[s * 3]
          , A = e[s * 3 + 1]
          , p = e[s * 3 + 2];
        return Math.abs(a - u) < Math.abs(o - l) ? [new Ae(o,1 - c), new Ae(l,1 - h), new Ae(d,1 - m), new Ae(g,1 - p)] : [new Ae(a,1 - c), new Ae(u,1 - h), new Ae(f,1 - m), new Ae(A,1 - p)]
    }
};
function Bf(r, e, t) {
    if (t.shapes = [],
    Array.isArray(r))
        for (let n = 0, i = r.length; n < i; n++) {
            const s = r[n];
            t.shapes.push(s.uuid)
        }
    else
        t.shapes.push(r.uuid);
    return t.options = Object.assign({}, e),
    e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()),
    t
}
class Xs extends At {
    constructor(e=1, t=1, n=1, i=1) {
        super(),
        this.type = "PlaneGeometry",
        this.parameters = {
            width: e,
            height: t,
            widthSegments: n,
            heightSegments: i
        };
        const s = e / 2
          , o = t / 2
          , a = Math.floor(n)
          , c = Math.floor(i)
          , l = a + 1
          , u = c + 1
          , h = e / a
          , d = t / c
          , f = []
          , m = []
          , g = []
          , A = [];
        for (let p = 0; p < u; p++) {
            const S = p * d - o;
            for (let w = 0; w < l; w++) {
                const b = w * h - s;
                m.push(b, -S, 0),
                g.push(0, 0, 1),
                A.push(w / a),
                A.push(1 - p / c)
            }
        }
        for (let p = 0; p < c; p++)
            for (let S = 0; S < a; S++) {
                const w = S + l * p
                  , b = S + l * (p + 1)
                  , B = S + 1 + l * (p + 1)
                  , z = S + 1 + l * p;
                f.push(w, b, z),
                f.push(b, B, z)
            }
        this.setIndex(f),
        this.setAttribute("position", new yt(m,3)),
        this.setAttribute("normal", new yt(g,3)),
        this.setAttribute("uv", new yt(A,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new Xs(e.width,e.height,e.widthSegments,e.heightSegments)
    }
}
class uc extends At {
    constructor(e=new Ss([new Ae(0,.5), new Ae(-.5,-.5), new Ae(.5,-.5)]), t=12) {
        super(),
        this.type = "ShapeGeometry",
        this.parameters = {
            shapes: e,
            curveSegments: t
        };
        const n = []
          , i = []
          , s = []
          , o = [];
        let a = 0
          , c = 0;
        if (Array.isArray(e) === !1)
            l(e);
        else
            for (let u = 0; u < e.length; u++)
                l(e[u]),
                this.addGroup(a, c, u),
                a += c,
                c = 0;
        this.setIndex(n),
        this.setAttribute("position", new yt(i,3)),
        this.setAttribute("normal", new yt(s,3)),
        this.setAttribute("uv", new yt(o,2));
        function l(u) {
            const h = i.length / 3
              , d = u.extractPoints(t);
            let f = d.shape;
            const m = d.holes;
            bn.isClockWise(f) === !1 && (f = f.reverse());
            for (let A = 0, p = m.length; A < p; A++) {
                const S = m[A];
                bn.isClockWise(S) === !0 && (m[A] = S.reverse())
            }
            const g = bn.triangulateShape(f, m);
            for (let A = 0, p = m.length; A < p; A++) {
                const S = m[A];
                f = f.concat(S)
            }
            for (let A = 0, p = f.length; A < p; A++) {
                const S = f[A];
                i.push(S.x, S.y, 0),
                s.push(0, 0, 1),
                o.push(S.x, S.y)
            }
            for (let A = 0, p = g.length; A < p; A++) {
                const S = g[A]
                  , w = S[0] + h
                  , b = S[1] + h
                  , B = S[2] + h;
                n.push(w, b, B),
                c += 3
            }
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    toJSON() {
        const e = super.toJSON()
          , t = this.parameters.shapes;
        return Ff(t, e)
    }
    static fromJSON(e, t) {
        const n = [];
        for (let i = 0, s = e.shapes.length; i < s; i++) {
            const o = t[e.shapes[i]];
            n.push(o)
        }
        return new uc(n,e.curveSegments)
    }
}
function Ff(r, e) {
    if (e.shapes = [],
    Array.isArray(r))
        for (let t = 0, n = r.length; t < n; t++) {
            const i = r[t];
            e.shapes.push(i.uuid)
        }
    else
        e.shapes.push(r.uuid);
    return e
}
class _f extends At {
    constructor(e=null) {
        if (super(),
        this.type = "WireframeGeometry",
        this.parameters = {
            geometry: e
        },
        e !== null) {
            const t = []
              , n = new Set
              , i = new D
              , s = new D;
            if (e.index !== null) {
                const o = e.attributes.position
                  , a = e.index;
                let c = e.groups;
                c.length === 0 && (c = [{
                    start: 0,
                    count: a.count,
                    materialIndex: 0
                }]);
                for (let l = 0, u = c.length; l < u; ++l) {
                    const h = c[l]
                      , d = h.start
                      , f = h.count;
                    for (let m = d, g = d + f; m < g; m += 3)
                        for (let A = 0; A < 3; A++) {
                            const p = a.getX(m + A)
                              , S = a.getX(m + (A + 1) % 3);
                            i.fromBufferAttribute(o, p),
                            s.fromBufferAttribute(o, S),
                            Al(i, s, n) === !0 && (t.push(i.x, i.y, i.z),
                            t.push(s.x, s.y, s.z))
                        }
                }
            } else {
                const o = e.attributes.position;
                for (let a = 0, c = o.count / 3; a < c; a++)
                    for (let l = 0; l < 3; l++) {
                        const u = 3 * a + l
                          , h = 3 * a + (l + 1) % 3;
                        i.fromBufferAttribute(o, u),
                        s.fromBufferAttribute(o, h),
                        Al(i, s, n) === !0 && (t.push(i.x, i.y, i.z),
                        t.push(s.x, s.y, s.z))
                    }
            }
            this.setAttribute("position", new yt(t,3))
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
}
function Al(r, e, t) {
    const n = `${r.x},${r.y},${r.z}-${e.x},${e.y},${e.z}`
      , i = `${e.x},${e.y},${e.z}-${r.x},${r.y},${r.z}`;
    return t.has(n) === !0 || t.has(i) === !0 ? !1 : (t.add(n),
    t.add(i),
    !0)
}
class Ki extends fn {
    constructor(e) {
        super(),
        this.isMeshStandardMaterial = !0,
        this.type = "MeshStandardMaterial",
        this.defines = {
            STANDARD: ""
        },
        this.color = new Ge(16777215),
        this.roughness = 1,
        this.metalness = 0,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Ge(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = ec,
        this.normalScale = new Ae(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.roughnessMap = null,
        this.metalnessMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapRotation = new Ft,
        this.envMapIntensity = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            STANDARD: ""
        },
        this.color.copy(e.color),
        this.roughness = e.roughness,
        this.metalness = e.metalness,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.roughnessMap = e.roughnessMap,
        this.metalnessMap = e.metalnessMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapRotation.copy(e.envMapRotation),
        this.envMapIntensity = e.envMapIntensity,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class pn extends Ki {
    constructor(e) {
        super(),
        this.isMeshPhysicalMaterial = !0,
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.type = "MeshPhysicalMaterial",
        this.anisotropyRotation = 0,
        this.anisotropyMap = null,
        this.clearcoatMap = null,
        this.clearcoatRoughness = 0,
        this.clearcoatRoughnessMap = null,
        this.clearcoatNormalScale = new Ae(1,1),
        this.clearcoatNormalMap = null,
        this.ior = 1.5,
        Object.defineProperty(this, "reflectivity", {
            get: function() {
                return Ke(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
            },
            set: function(t) {
                this.ior = (1 + .4 * t) / (1 - .4 * t)
            }
        }),
        this.iridescenceMap = null,
        this.iridescenceIOR = 1.3,
        this.iridescenceThicknessRange = [100, 400],
        this.iridescenceThicknessMap = null,
        this.sheenColor = new Ge(0),
        this.sheenColorMap = null,
        this.sheenRoughness = 1,
        this.sheenRoughnessMap = null,
        this.transmissionMap = null,
        this.thickness = 0,
        this.thicknessMap = null,
        this.attenuationDistance = 1 / 0,
        this.attenuationColor = new Ge(1,1,1),
        this.specularIntensity = 1,
        this.specularIntensityMap = null,
        this.specularColor = new Ge(1,1,1),
        this.specularColorMap = null,
        this._anisotropy = 0,
        this._clearcoat = 0,
        this._dispersion = 0,
        this._iridescence = 0,
        this._sheen = 0,
        this._transmission = 0,
        this.setValues(e)
    }
    get anisotropy() {
        return this._anisotropy
    }
    set anisotropy(e) {
        this._anisotropy > 0 != e > 0 && this.version++,
        this._anisotropy = e
    }
    get clearcoat() {
        return this._clearcoat
    }
    set clearcoat(e) {
        this._clearcoat > 0 != e > 0 && this.version++,
        this._clearcoat = e
    }
    get iridescence() {
        return this._iridescence
    }
    set iridescence(e) {
        this._iridescence > 0 != e > 0 && this.version++,
        this._iridescence = e
    }
    get dispersion() {
        return this._dispersion
    }
    set dispersion(e) {
        this._dispersion > 0 != e > 0 && this.version++,
        this._dispersion = e
    }
    get sheen() {
        return this._sheen
    }
    set sheen(e) {
        this._sheen > 0 != e > 0 && this.version++,
        this._sheen = e
    }
    get transmission() {
        return this._transmission
    }
    set transmission(e) {
        this._transmission > 0 != e > 0 && this.version++,
        this._transmission = e
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.anisotropy = e.anisotropy,
        this.anisotropyRotation = e.anisotropyRotation,
        this.anisotropyMap = e.anisotropyMap,
        this.clearcoat = e.clearcoat,
        this.clearcoatMap = e.clearcoatMap,
        this.clearcoatRoughness = e.clearcoatRoughness,
        this.clearcoatRoughnessMap = e.clearcoatRoughnessMap,
        this.clearcoatNormalMap = e.clearcoatNormalMap,
        this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
        this.dispersion = e.dispersion,
        this.ior = e.ior,
        this.iridescence = e.iridescence,
        this.iridescenceMap = e.iridescenceMap,
        this.iridescenceIOR = e.iridescenceIOR,
        this.iridescenceThicknessRange = [...e.iridescenceThicknessRange],
        this.iridescenceThicknessMap = e.iridescenceThicknessMap,
        this.sheen = e.sheen,
        this.sheenColor.copy(e.sheenColor),
        this.sheenColorMap = e.sheenColorMap,
        this.sheenRoughness = e.sheenRoughness,
        this.sheenRoughnessMap = e.sheenRoughnessMap,
        this.transmission = e.transmission,
        this.transmissionMap = e.transmissionMap,
        this.thickness = e.thickness,
        this.thicknessMap = e.thicknessMap,
        this.attenuationDistance = e.attenuationDistance,
        this.attenuationColor.copy(e.attenuationColor),
        this.specularIntensity = e.specularIntensity,
        this.specularIntensityMap = e.specularIntensityMap,
        this.specularColor.copy(e.specularColor),
        this.specularColorMap = e.specularColorMap,
        this
    }
}
class gl extends fn {
    constructor(e) {
        super(),
        this.isMeshPhongMaterial = !0,
        this.type = "MeshPhongMaterial",
        this.color = new Ge(16777215),
        this.specular = new Ge(1118481),
        this.shininess = 30,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Ge(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = ec,
        this.normalScale = new Ae(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapRotation = new Ft,
        this.combine = ka,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.specular.copy(e.specular),
        this.shininess = e.shininess,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapRotation.copy(e.envMapRotation),
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class Hf extends fn {
    constructor(e) {
        super(),
        this.isMeshDepthMaterial = !0,
        this.type = "MeshDepthMaterial",
        this.depthPacking = Qh,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.depthPacking = e.depthPacking,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this
    }
}
class Xf extends fn {
    constructor(e) {
        super(),
        this.isMeshDistanceMaterial = !0,
        this.type = "MeshDistanceMaterial",
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this
    }
}
class vl extends jr {
    constructor(e) {
        super(),
        this.isLineDashedMaterial = !0,
        this.type = "LineDashedMaterial",
        this.scale = 1,
        this.dashSize = 3,
        this.gapSize = 1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.scale = e.scale,
        this.dashSize = e.dashSize,
        this.gapSize = e.gapSize,
        this
    }
}
function yr(r, e) {
    return !r || r.constructor === e ? r : typeof e.BYTES_PER_ELEMENT == "number" ? new e(r) : Array.prototype.slice.call(r)
}
function Gf(r) {
    return ArrayBuffer.isView(r) && !(r instanceof DataView)
}
function Vf(r) {
    function e(i, s) {
        return r[i] - r[s]
    }
    const t = r.length
      , n = new Array(t);
    for (let i = 0; i !== t; ++i)
        n[i] = i;
    return n.sort(e),
    n
}
function xl(r, e, t) {
    const n = r.length
      , i = new r.constructor(n);
    for (let s = 0, o = 0; o !== n; ++s) {
        const a = t[s] * e;
        for (let c = 0; c !== e; ++c)
            i[o++] = r[a + c]
    }
    return i
}
function qu(r, e, t, n) {
    let i = 1
      , s = r[0];
    for (; s !== void 0 && s[n] === void 0; )
        s = r[i++];
    if (s === void 0)
        return;
    let o = s[n];
    if (o !== void 0)
        if (Array.isArray(o))
            do
                o = s[n],
                o !== void 0 && (e.push(s.time),
                t.push(...o)),
                s = r[i++];
            while (s !== void 0);
        else if (o.toArray !== void 0)
            do
                o = s[n],
                o !== void 0 && (e.push(s.time),
                o.toArray(t, t.length)),
                s = r[i++];
            while (s !== void 0);
        else
            do
                o = s[n],
                o !== void 0 && (e.push(s.time),
                t.push(o)),
                s = r[i++];
            while (s !== void 0)
}
class Gs {
    constructor(e, t, n, i) {
        this.parameterPositions = e,
        this._cachedIndex = 0,
        this.resultBuffer = i !== void 0 ? i : new t.constructor(n),
        this.sampleValues = t,
        this.valueSize = n,
        this.settings = null,
        this.DefaultSettings_ = {}
    }
    evaluate(e) {
        const t = this.parameterPositions;
        let n = this._cachedIndex
          , i = t[n]
          , s = t[n - 1];
        n: {
            e: {
                let o;
                t: {
                    i: if (!(e < i)) {
                        for (let a = n + 2; ; ) {
                            if (i === void 0) {
                                if (e < s)
                                    break i;
                                return n = t.length,
                                this._cachedIndex = n,
                                this.copySampleValue_(n - 1)
                            }
                            if (n === a)
                                break;
                            if (s = i,
                            i = t[++n],
                            e < i)
                                break e
                        }
                        o = t.length;
                        break t
                    }
                    if (!(e >= s)) {
                        const a = t[1];
                        e < a && (n = 2,
                        s = a);
                        for (let c = n - 2; ; ) {
                            if (s === void 0)
                                return this._cachedIndex = 0,
                                this.copySampleValue_(0);
                            if (n === c)
                                break;
                            if (i = s,
                            s = t[--n - 1],
                            e >= s)
                                break e
                        }
                        o = n,
                        n = 0;
                        break t
                    }
                    break n
                }
                for (; n < o; ) {
                    const a = n + o >>> 1;
                    e < t[a] ? o = a : n = a + 1
                }
                if (i = t[n],
                s = t[n - 1],
                s === void 0)
                    return this._cachedIndex = 0,
                    this.copySampleValue_(0);
                if (i === void 0)
                    return n = t.length,
                    this._cachedIndex = n,
                    this.copySampleValue_(n - 1)
            }
            this._cachedIndex = n,
            this.intervalChanged_(n, s, i)
        }
        return this.interpolate_(n, s, e, i)
    }
    getSettings_() {
        return this.settings || this.DefaultSettings_
    }
    copySampleValue_(e) {
        const t = this.resultBuffer
          , n = this.sampleValues
          , i = this.valueSize
          , s = e * i;
        for (let o = 0; o !== i; ++o)
            t[o] = n[s + o];
        return t
    }
    interpolate_() {
        throw new Error("call to abstract method")
    }
    intervalChanged_() {}
}
class Wf extends Gs {
    constructor(e, t, n, i) {
        super(e, t, n, i),
        this._weightPrev = -0,
        this._offsetPrev = -0,
        this._weightNext = -0,
        this._offsetNext = -0,
        this.DefaultSettings_ = {
            endingStart: Lc,
            endingEnd: Lc
        }
    }
    intervalChanged_(e, t, n) {
        const i = this.parameterPositions;
        let s = e - 2
          , o = e + 1
          , a = i[s]
          , c = i[o];
        if (a === void 0)
            switch (this.getSettings_().endingStart) {
            case Cc:
                s = e,
                a = 2 * t - n;
                break;
            case Rc:
                s = i.length - 2,
                a = t + i[s] - i[s + 1];
                break;
            default:
                s = e,
                a = n
            }
        if (c === void 0)
            switch (this.getSettings_().endingEnd) {
            case Cc:
                o = e,
                c = 2 * n - t;
                break;
            case Rc:
                o = 1,
                c = n + i[1] - i[0];
                break;
            default:
                o = e - 1,
                c = t
            }
        const l = (n - t) * .5
          , u = this.valueSize;
        this._weightPrev = l / (t - a),
        this._weightNext = l / (c - n),
        this._offsetPrev = s * u,
        this._offsetNext = o * u
    }
    interpolate_(e, t, n, i) {
        const s = this.resultBuffer
          , o = this.sampleValues
          , a = this.valueSize
          , c = e * a
          , l = c - a
          , u = this._offsetPrev
          , h = this._offsetNext
          , d = this._weightPrev
          , f = this._weightNext
          , m = (n - t) / (i - t)
          , g = m * m
          , A = g * m
          , p = -d * A + 2 * d * g - d * m
          , S = (1 + d) * A + (-1.5 - 2 * d) * g + (-.5 + d) * m + 1
          , w = (-1 - f) * A + (1.5 + f) * g + .5 * m
          , b = f * A - f * g;
        for (let B = 0; B !== a; ++B)
            s[B] = p * o[u + B] + S * o[l + B] + w * o[c + B] + b * o[h + B];
        return s
    }
}
class jf extends Gs {
    constructor(e, t, n, i) {
        super(e, t, n, i)
    }
    interpolate_(e, t, n, i) {
        const s = this.resultBuffer
          , o = this.sampleValues
          , a = this.valueSize
          , c = e * a
          , l = c - a
          , u = (n - t) / (i - t)
          , h = 1 - u;
        for (let d = 0; d !== a; ++d)
            s[d] = o[l + d] * h + o[c + d] * u;
        return s
    }
}
class kf extends Gs {
    constructor(e, t, n, i) {
        super(e, t, n, i)
    }
    interpolate_(e) {
        return this.copySampleValue_(e - 1)
    }
}
class mn {
    constructor(e, t, n, i) {
        if (e === void 0)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (t === void 0 || t.length === 0)
            throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
        this.name = e,
        this.times = yr(t, this.TimeBufferType),
        this.values = yr(n, this.ValueBufferType),
        this.setInterpolation(i || this.DefaultInterpolation)
    }
    static toJSON(e) {
        const t = e.constructor;
        let n;
        if (t.toJSON !== this.toJSON)
            n = t.toJSON(e);
        else {
            n = {
                name: e.name,
                times: yr(e.times, Array),
                values: yr(e.values, Array)
            };
            const i = e.getInterpolation();
            i !== e.DefaultInterpolation && (n.interpolation = i)
        }
        return n.type = e.ValueTypeName,
        n
    }
    InterpolantFactoryMethodDiscrete(e) {
        return new kf(this.times,this.values,this.getValueSize(),e)
    }
    InterpolantFactoryMethodLinear(e) {
        return new jf(this.times,this.values,this.getValueSize(),e)
    }
    InterpolantFactoryMethodSmooth(e) {
        return new Wf(this.times,this.values,this.getValueSize(),e)
    }
    setInterpolation(e) {
        let t;
        switch (e) {
        case Rs:
            t = this.InterpolantFactoryMethodDiscrete;
            break;
        case Ds:
            t = this.InterpolantFactoryMethodLinear;
            break;
        case Jr:
            t = this.InterpolantFactoryMethodSmooth;
            break
        }
        if (t === void 0) {
            const n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === void 0)
                if (e !== this.DefaultInterpolation)
                    this.setInterpolation(this.DefaultInterpolation);
                else
                    throw new Error(n);
            return console.warn("THREE.KeyframeTrack:", n),
            this
        }
        return this.createInterpolant = t,
        this
    }
    getInterpolation() {
        switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
            return Rs;
        case this.InterpolantFactoryMethodLinear:
            return Ds;
        case this.InterpolantFactoryMethodSmooth:
            return Jr
        }
    }
    getValueSize() {
        return this.values.length / this.times.length
    }
    shift(e) {
        if (e !== 0) {
            const t = this.times;
            for (let n = 0, i = t.length; n !== i; ++n)
                t[n] += e
        }
        return this
    }
    scale(e) {
        if (e !== 1) {
            const t = this.times;
            for (let n = 0, i = t.length; n !== i; ++n)
                t[n] *= e
        }
        return this
    }
    trim(e, t) {
        const n = this.times
          , i = n.length;
        let s = 0
          , o = i - 1;
        for (; s !== i && n[s] < e; )
            ++s;
        for (; o !== -1 && n[o] > t; )
            --o;
        if (++o,
        s !== 0 || o !== i) {
            s >= o && (o = Math.max(o, 1),
            s = o - 1);
            const a = this.getValueSize();
            this.times = n.slice(s, o),
            this.values = this.values.slice(s * a, o * a)
        }
        return this
    }
    validate() {
        let e = !0;
        const t = this.getValueSize();
        t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
        e = !1);
        const n = this.times
          , i = this.values
          , s = n.length;
        s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this),
        e = !1);
        let o = null;
        for (let a = 0; a !== s; a++) {
            const c = n[a];
            if (typeof c == "number" && isNaN(c)) {
                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, c),
                e = !1;
                break
            }
            if (o !== null && o > c) {
                console.error("THREE.KeyframeTrack: Out of order keys.", this, a, c, o),
                e = !1;
                break
            }
            o = c
        }
        if (i !== void 0 && Gf(i))
            for (let a = 0, c = i.length; a !== c; ++a) {
                const l = i[a];
                if (isNaN(l)) {
                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, l),
                    e = !1;
                    break
                }
            }
        return e
    }
    optimize() {
        const e = this.times.slice()
          , t = this.values.slice()
          , n = this.getValueSize()
          , i = this.getInterpolation() === Jr
          , s = e.length - 1;
        let o = 1;
        for (let a = 1; a < s; ++a) {
            let c = !1;
            const l = e[a]
              , u = e[a + 1];
            if (l !== u && (a !== 1 || l !== e[0]))
                if (i)
                    c = !0;
                else {
                    const h = a * n
                      , d = h - n
                      , f = h + n;
                    for (let m = 0; m !== n; ++m) {
                        const g = t[h + m];
                        if (g !== t[d + m] || g !== t[f + m]) {
                            c = !0;
                            break
                        }
                    }
                }
            if (c) {
                if (a !== o) {
                    e[o] = e[a];
                    const h = a * n
                      , d = o * n;
                    for (let f = 0; f !== n; ++f)
                        t[d + f] = t[h + f]
                }
                ++o
            }
        }
        if (s > 0) {
            e[o] = e[s];
            for (let a = s * n, c = o * n, l = 0; l !== n; ++l)
                t[c + l] = t[a + l];
            ++o
        }
        return o !== e.length ? (this.times = e.slice(0, o),
        this.values = t.slice(0, o * n)) : (this.times = e,
        this.values = t),
        this
    }
    clone() {
        const e = this.times.slice()
          , t = this.values.slice()
          , n = this.constructor
          , i = new n(this.name,e,t);
        return i.createInterpolant = this.createInterpolant,
        i
    }
}
mn.prototype.ValueTypeName = "";
mn.prototype.TimeBufferType = Float32Array;
mn.prototype.ValueBufferType = Float32Array;
mn.prototype.DefaultInterpolation = Ds;
class ts extends mn {
    constructor(e, t, n) {
        super(e, t, n)
    }
}
ts.prototype.ValueTypeName = "bool";
ts.prototype.ValueBufferType = Array;
ts.prototype.DefaultInterpolation = Rs;
ts.prototype.InterpolantFactoryMethodLinear = void 0;
ts.prototype.InterpolantFactoryMethodSmooth = void 0;
class Zu extends mn {
    constructor(e, t, n, i) {
        super(e, t, n, i)
    }
}
Zu.prototype.ValueTypeName = "color";
class Qi extends mn {
    constructor(e, t, n, i) {
        super(e, t, n, i)
    }
}
Qi.prototype.ValueTypeName = "number";
class Yf extends Gs {
    constructor(e, t, n, i) {
        super(e, t, n, i)
    }
    interpolate_(e, t, n, i) {
        const s = this.resultBuffer
          , o = this.sampleValues
          , a = this.valueSize
          , c = (n - t) / (i - t);
        let l = e * a;
        for (let u = l + a; l !== u; l += 4)
            sn.slerpFlat(s, 0, o, l - a, o, l, c);
        return s
    }
}
class Ji extends mn {
    constructor(e, t, n, i) {
        super(e, t, n, i)
    }
    InterpolantFactoryMethodLinear(e) {
        return new Yf(this.times,this.values,this.getValueSize(),e)
    }
}
Ji.prototype.ValueTypeName = "quaternion";
Ji.prototype.InterpolantFactoryMethodSmooth = void 0;
class ns extends mn {
    constructor(e, t, n) {
        super(e, t, n)
    }
}
ns.prototype.ValueTypeName = "string";
ns.prototype.ValueBufferType = Array;
ns.prototype.DefaultInterpolation = Rs;
ns.prototype.InterpolantFactoryMethodLinear = void 0;
ns.prototype.InterpolantFactoryMethodSmooth = void 0;
class $i extends mn {
    constructor(e, t, n, i) {
        super(e, t, n, i)
    }
}
$i.prototype.ValueTypeName = "vector";
class qf {
    constructor(e="", t=-1, n=[], i=Zh) {
        this.name = e,
        this.tracks = n,
        this.duration = t,
        this.blendMode = i,
        this.uuid = nn(),
        this.duration < 0 && this.resetDuration()
    }
    static parse(e) {
        const t = []
          , n = e.tracks
          , i = 1 / (e.fps || 1);
        for (let o = 0, a = n.length; o !== a; ++o)
            t.push(Kf(n[o]).scale(i));
        const s = new this(e.name,e.duration,t,e.blendMode);
        return s.uuid = e.uuid,
        s
    }
    static toJSON(e) {
        const t = []
          , n = e.tracks
          , i = {
            name: e.name,
            duration: e.duration,
            tracks: t,
            uuid: e.uuid,
            blendMode: e.blendMode
        };
        for (let s = 0, o = n.length; s !== o; ++s)
            t.push(mn.toJSON(n[s]));
        return i
    }
    static CreateFromMorphTargetSequence(e, t, n, i) {
        const s = t.length
          , o = [];
        for (let a = 0; a < s; a++) {
            let c = []
              , l = [];
            c.push((a + s - 1) % s, a, (a + 1) % s),
            l.push(0, 1, 0);
            const u = Vf(c);
            c = xl(c, 1, u),
            l = xl(l, 1, u),
            !i && c[0] === 0 && (c.push(s),
            l.push(l[0])),
            o.push(new Qi(".morphTargetInfluences[" + t[a].name + "]",c,l).scale(1 / n))
        }
        return new this(e,-1,o)
    }
    static findByName(e, t) {
        let n = e;
        if (!Array.isArray(e)) {
            const i = e;
            n = i.geometry && i.geometry.animations || i.animations
        }
        for (let i = 0; i < n.length; i++)
            if (n[i].name === t)
                return n[i];
        return null
    }
    static CreateClipsFromMorphTargetSequences(e, t, n) {
        const i = {}
          , s = /^([\w-]*?)([\d]+)$/;
        for (let a = 0, c = e.length; a < c; a++) {
            const l = e[a]
              , u = l.name.match(s);
            if (u && u.length > 1) {
                const h = u[1];
                let d = i[h];
                d || (i[h] = d = []),
                d.push(l)
            }
        }
        const o = [];
        for (const a in i)
            o.push(this.CreateFromMorphTargetSequence(a, i[a], t, n));
        return o
    }
    static parseAnimation(e, t) {
        if (console.warn("THREE.AnimationClip: parseAnimation() is deprecated and will be removed with r185"),
        !e)
            return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
            null;
        const n = function(h, d, f, m, g) {
            if (f.length !== 0) {
                const A = []
                  , p = [];
                qu(f, A, p, m),
                A.length !== 0 && g.push(new h(d,A,p))
            }
        }
          , i = []
          , s = e.name || "default"
          , o = e.fps || 30
          , a = e.blendMode;
        let c = e.length || -1;
        const l = e.hierarchy || [];
        for (let h = 0; h < l.length; h++) {
            const d = l[h].keys;
            if (!(!d || d.length === 0))
                if (d[0].morphTargets) {
                    const f = {};
                    let m;
                    for (m = 0; m < d.length; m++)
                        if (d[m].morphTargets)
                            for (let g = 0; g < d[m].morphTargets.length; g++)
                                f[d[m].morphTargets[g]] = -1;
                    for (const g in f) {
                        const A = []
                          , p = [];
                        for (let S = 0; S !== d[m].morphTargets.length; ++S) {
                            const w = d[m];
                            A.push(w.time),
                            p.push(w.morphTarget === g ? 1 : 0)
                        }
                        i.push(new Qi(".morphTargetInfluence[" + g + "]",A,p))
                    }
                    c = f.length * o
                } else {
                    const f = ".bones[" + t[h].name + "]";
                    n($i, f + ".position", d, "pos", i),
                    n(Ji, f + ".quaternion", d, "rot", i),
                    n($i, f + ".scale", d, "scl", i)
                }
        }
        return i.length === 0 ? null : new this(s,c,i,a)
    }
    resetDuration() {
        const e = this.tracks;
        let t = 0;
        for (let n = 0, i = e.length; n !== i; ++n) {
            const s = this.tracks[n];
            t = Math.max(t, s.times[s.times.length - 1])
        }
        return this.duration = t,
        this
    }
    trim() {
        for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].trim(0, this.duration);
        return this
    }
    validate() {
        let e = !0;
        for (let t = 0; t < this.tracks.length; t++)
            e = e && this.tracks[t].validate();
        return e
    }
    optimize() {
        for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].optimize();
        return this
    }
    clone() {
        const e = [];
        for (let t = 0; t < this.tracks.length; t++)
            e.push(this.tracks[t].clone());
        return new this.constructor(this.name,this.duration,e,this.blendMode)
    }
    toJSON() {
        return this.constructor.toJSON(this)
    }
}
function Zf(r) {
    switch (r.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
        return Qi;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
        return $i;
    case "color":
        return Zu;
    case "quaternion":
        return Ji;
    case "bool":
    case "boolean":
        return ts;
    case "string":
        return ns
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + r)
}
function Kf(r) {
    if (r.type === void 0)
        throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    const e = Zf(r.type);
    if (r.times === void 0) {
        const t = []
          , n = [];
        qu(r.keys, t, n, "value"),
        r.times = t,
        r.values = n
    }
    return e.parse !== void 0 ? e.parse(r) : new e(r.name,r.times,r.values,r.interpolation)
}
const $n = {
    enabled: !1,
    files: {},
    add: function(r, e) {
        this.enabled !== !1 && (this.files[r] = e)
    },
    get: function(r) {
        if (this.enabled !== !1)
            return this.files[r]
    },
    remove: function(r) {
        delete this.files[r]
    },
    clear: function() {
        this.files = {}
    }
};
class Ku {
    constructor(e, t, n) {
        const i = this;
        let s = !1, o = 0, a = 0, c;
        const l = [];
        this.onStart = void 0,
        this.onLoad = e,
        this.onProgress = t,
        this.onError = n,
        this.itemStart = function(u) {
            a++,
            s === !1 && i.onStart !== void 0 && i.onStart(u, o, a),
            s = !0
        }
        ,
        this.itemEnd = function(u) {
            o++,
            i.onProgress !== void 0 && i.onProgress(u, o, a),
            o === a && (s = !1,
            i.onLoad !== void 0 && i.onLoad())
        }
        ,
        this.itemError = function(u) {
            i.onError !== void 0 && i.onError(u)
        }
        ,
        this.resolveURL = function(u) {
            return c ? c(u) : u
        }
        ,
        this.setURLModifier = function(u) {
            return c = u,
            this
        }
        ,
        this.addHandler = function(u, h) {
            return l.push(u, h),
            this
        }
        ,
        this.removeHandler = function(u) {
            const h = l.indexOf(u);
            return h !== -1 && l.splice(h, 2),
            this
        }
        ,
        this.getHandler = function(u) {
            for (let h = 0, d = l.length; h < d; h += 2) {
                const f = l[h]
                  , m = l[h + 1];
                if (f.global && (f.lastIndex = 0),
                f.test(u))
                    return m
            }
            return null
        }
    }
}
const Qf = new Ku;
class xi {
    constructor(e) {
        this.manager = e !== void 0 ? e : Qf,
        this.crossOrigin = "anonymous",
        this.withCredentials = !1,
        this.path = "",
        this.resourcePath = "",
        this.requestHeader = {}
    }
    load() {}
    loadAsync(e, t) {
        const n = this;
        return new Promise(function(i, s) {
            n.load(e, i, t, s)
        }
        )
    }
    parse() {}
    setCrossOrigin(e) {
        return this.crossOrigin = e,
        this
    }
    setWithCredentials(e) {
        return this.withCredentials = e,
        this
    }
    setPath(e) {
        return this.path = e,
        this
    }
    setResourcePath(e) {
        return this.resourcePath = e,
        this
    }
    setRequestHeader(e) {
        return this.requestHeader = e,
        this
    }
}
xi.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const Dn = {};
class Jf extends Error {
    constructor(e, t) {
        super(e),
        this.response = t
    }
}
class hc extends xi {
    constructor(e) {
        super(e),
        this.mimeType = "",
        this.responseType = ""
    }
    load(e, t, n, i) {
        e === void 0 && (e = ""),
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const s = $n.get(e);
        if (s !== void 0)
            return this.manager.itemStart(e),
            setTimeout( () => {
                t && t(s),
                this.manager.itemEnd(e)
            }
            , 0),
            s;
        if (Dn[e] !== void 0) {
            Dn[e].push({
                onLoad: t,
                onProgress: n,
                onError: i
            });
            return
        }
        Dn[e] = [],
        Dn[e].push({
            onLoad: t,
            onProgress: n,
            onError: i
        });
        const o = new Request(e,{
            headers: new Headers(this.requestHeader),
            credentials: this.withCredentials ? "include" : "same-origin"
        })
          , a = this.mimeType
          , c = this.responseType;
        fetch(o).then(l => {
            if (l.status === 200 || l.status === 0) {
                if (l.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                typeof ReadableStream > "u" || l.body === void 0 || l.body.getReader === void 0)
                    return l;
                const u = Dn[e]
                  , h = l.body.getReader()
                  , d = l.headers.get("X-File-Size") || l.headers.get("Content-Length")
                  , f = d ? parseInt(d) : 0
                  , m = f !== 0;
                let g = 0;
                const A = new ReadableStream({
                    start(p) {
                        S();
                        function S() {
                            h.read().then( ({done: w, value: b}) => {
                                if (w)
                                    p.close();
                                else {
                                    g += b.byteLength;
                                    const B = new ProgressEvent("progress",{
                                        lengthComputable: m,
                                        loaded: g,
                                        total: f
                                    });
                                    for (let z = 0, I = u.length; z < I; z++) {
                                        const H = u[z];
                                        H.onProgress && H.onProgress(B)
                                    }
                                    p.enqueue(b),
                                    S()
                                }
                            }
                            , w => {
                                p.error(w)
                            }
                            )
                        }
                    }
                });
                return new Response(A)
            } else
                throw new Jf(`fetch for "${l.url}" responded with ${l.status}: ${l.statusText}`,l)
        }
        ).then(l => {
            switch (c) {
            case "arraybuffer":
                return l.arrayBuffer();
            case "blob":
                return l.blob();
            case "document":
                return l.text().then(u => new DOMParser().parseFromString(u, a));
            case "json":
                return l.json();
            default:
                if (a === "")
                    return l.text();
                {
                    const h = /charset="?([^;"\s]*)"?/i.exec(a)
                      , d = h && h[1] ? h[1].toLowerCase() : void 0
                      , f = new TextDecoder(d);
                    return l.arrayBuffer().then(m => f.decode(m))
                }
            }
        }
        ).then(l => {
            $n.add(e, l);
            const u = Dn[e];
            delete Dn[e];
            for (let h = 0, d = u.length; h < d; h++) {
                const f = u[h];
                f.onLoad && f.onLoad(l)
            }
        }
        ).catch(l => {
            const u = Dn[e];
            if (u === void 0)
                throw this.manager.itemError(e),
                l;
            delete Dn[e];
            for (let h = 0, d = u.length; h < d; h++) {
                const f = u[h];
                f.onError && f.onError(l)
            }
            this.manager.itemError(e)
        }
        ).finally( () => {
            this.manager.itemEnd(e)
        }
        ),
        this.manager.itemStart(e)
    }
    setResponseType(e) {
        return this.responseType = e,
        this
    }
    setMimeType(e) {
        return this.mimeType = e,
        this
    }
}
class $f extends xi {
    constructor(e) {
        super(e)
    }
    load(e, t, n, i) {
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const s = this
          , o = $n.get(e);
        if (o !== void 0)
            return s.manager.itemStart(e),
            setTimeout(function() {
                t && t(o),
                s.manager.itemEnd(e)
            }, 0),
            o;
        const a = Ns("img");
        function c() {
            u(),
            $n.add(e, this),
            t && t(this),
            s.manager.itemEnd(e)
        }
        function l(h) {
            u(),
            i && i(h),
            s.manager.itemError(e),
            s.manager.itemEnd(e)
        }
        function u() {
            a.removeEventListener("load", c, !1),
            a.removeEventListener("error", l, !1)
        }
        return a.addEventListener("load", c, !1),
        a.addEventListener("error", l, !1),
        e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin),
        s.manager.itemStart(e),
        a.src = e,
        a
    }
}
class ep extends xi {
    constructor(e) {
        super(e)
    }
    load(e, t, n, i) {
        const s = new Tt
          , o = new $f(this.manager);
        return o.setCrossOrigin(this.crossOrigin),
        o.setPath(this.path),
        o.load(e, function(a) {
            s.image = a,
            s.needsUpdate = !0,
            t !== void 0 && t(s)
        }, n, i),
        s
    }
}
class kr extends lt {
    constructor(e, t=1) {
        super(),
        this.isLight = !0,
        this.type = "Light",
        this.color = new Ge(e),
        this.intensity = t
    }
    dispose() {}
    copy(e, t) {
        return super.copy(e, t),
        this.color.copy(e.color),
        this.intensity = e.intensity,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.color = this.color.getHex(),
        t.object.intensity = this.intensity,
        this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()),
        this.distance !== void 0 && (t.object.distance = this.distance),
        this.angle !== void 0 && (t.object.angle = this.angle),
        this.decay !== void 0 && (t.object.decay = this.decay),
        this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
        this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
        this.target !== void 0 && (t.object.target = this.target.uuid),
        t
    }
}
class tp extends kr {
    constructor(e, t, n) {
        super(e, n),
        this.isHemisphereLight = !0,
        this.type = "HemisphereLight",
        this.position.copy(lt.DEFAULT_UP),
        this.updateMatrix(),
        this.groundColor = new Ge(t)
    }
    copy(e, t) {
        return super.copy(e, t),
        this.groundColor.copy(e.groundColor),
        this
    }
}
const Co = new We
  , yl = new D
  , bl = new D;
class dc {
    constructor(e) {
        this.camera = e,
        this.intensity = 1,
        this.bias = 0,
        this.normalBias = 0,
        this.radius = 1,
        this.blurSamples = 8,
        this.mapSize = new Ae(512,512),
        this.mapType = Mn,
        this.map = null,
        this.mapPass = null,
        this.matrix = new We,
        this.autoUpdate = !0,
        this.needsUpdate = !1,
        this._frustum = new oc,
        this._frameExtents = new Ae(1,1),
        this._viewportCount = 1,
        this._viewports = [new Je(0,0,1,1)]
    }
    getViewportCount() {
        return this._viewportCount
    }
    getFrustum() {
        return this._frustum
    }
    updateMatrices(e) {
        const t = this.camera
          , n = this.matrix;
        yl.setFromMatrixPosition(e.matrixWorld),
        t.position.copy(yl),
        bl.setFromMatrixPosition(e.target.matrixWorld),
        t.lookAt(bl),
        t.updateMatrixWorld(),
        Co.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(Co),
        n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
        n.multiply(Co)
    }
    getViewport(e) {
        return this._viewports[e]
    }
    getFrameExtents() {
        return this._frameExtents
    }
    dispose() {
        this.map && this.map.dispose(),
        this.mapPass && this.mapPass.dispose()
    }
    copy(e) {
        return this.camera = e.camera.clone(),
        this.intensity = e.intensity,
        this.bias = e.bias,
        this.radius = e.radius,
        this.autoUpdate = e.autoUpdate,
        this.needsUpdate = e.needsUpdate,
        this.normalBias = e.normalBias,
        this.blurSamples = e.blurSamples,
        this.mapSize.copy(e.mapSize),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    toJSON() {
        const e = {};
        return this.intensity !== 1 && (e.intensity = this.intensity),
        this.bias !== 0 && (e.bias = this.bias),
        this.normalBias !== 0 && (e.normalBias = this.normalBias),
        this.radius !== 1 && (e.radius = this.radius),
        (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()),
        e.camera = this.camera.toJSON(!1).object,
        delete e.camera.matrix,
        e
    }
}
class np extends dc {
    constructor() {
        super(new Bt(50,1,.5,500)),
        this.isSpotLightShadow = !0,
        this.focus = 1,
        this.aspect = 1
    }
    updateMatrices(e) {
        const t = this.camera
          , n = Yi * 2 * e.angle * this.focus
          , i = this.mapSize.width / this.mapSize.height * this.aspect
          , s = e.distance || t.far;
        (n !== t.fov || i !== t.aspect || s !== t.far) && (t.fov = n,
        t.aspect = i,
        t.far = s,
        t.updateProjectionMatrix()),
        super.updateMatrices(e)
    }
    copy(e) {
        return super.copy(e),
        this.focus = e.focus,
        this
    }
}
class ip extends kr {
    constructor(e, t, n=0, i=Math.PI / 3, s=0, o=2) {
        super(e, t),
        this.isSpotLight = !0,
        this.type = "SpotLight",
        this.position.copy(lt.DEFAULT_UP),
        this.updateMatrix(),
        this.target = new lt,
        this.distance = n,
        this.angle = i,
        this.penumbra = s,
        this.decay = o,
        this.map = null,
        this.shadow = new np
    }
    get power() {
        return this.intensity * Math.PI
    }
    set power(e) {
        this.intensity = e / Math.PI
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.distance = e.distance,
        this.angle = e.angle,
        this.penumbra = e.penumbra,
        this.decay = e.decay,
        this.target = e.target.clone(),
        this.shadow = e.shadow.clone(),
        this
    }
}
const Ml = new We
  , ds = new D
  , Ro = new D;
class sp extends dc {
    constructor() {
        super(new Bt(90,1,.5,500)),
        this.isPointLightShadow = !0,
        this._frameExtents = new Ae(4,2),
        this._viewportCount = 6,
        this._viewports = [new Je(2,1,1,1), new Je(0,1,1,1), new Je(3,1,1,1), new Je(1,1,1,1), new Je(3,0,1,1), new Je(1,0,1,1)],
        this._cubeDirections = [new D(1,0,0), new D(-1,0,0), new D(0,0,1), new D(0,0,-1), new D(0,1,0), new D(0,-1,0)],
        this._cubeUps = [new D(0,1,0), new D(0,1,0), new D(0,1,0), new D(0,1,0), new D(0,0,1), new D(0,0,-1)]
    }
    updateMatrices(e, t=0) {
        const n = this.camera
          , i = this.matrix
          , s = e.distance || n.far;
        s !== n.far && (n.far = s,
        n.updateProjectionMatrix()),
        ds.setFromMatrixPosition(e.matrixWorld),
        n.position.copy(ds),
        Ro.copy(n.position),
        Ro.add(this._cubeDirections[t]),
        n.up.copy(this._cubeUps[t]),
        n.lookAt(Ro),
        n.updateMatrixWorld(),
        i.makeTranslation(-ds.x, -ds.y, -ds.z),
        Ml.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(Ml)
    }
}
class rp extends kr {
    constructor(e, t, n=0, i=2) {
        super(e, t),
        this.isPointLight = !0,
        this.type = "PointLight",
        this.distance = n,
        this.decay = i,
        this.shadow = new sp
    }
    get power() {
        return this.intensity * 4 * Math.PI
    }
    set power(e) {
        this.intensity = e / (4 * Math.PI)
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.distance = e.distance,
        this.decay = e.decay,
        this.shadow = e.shadow.clone(),
        this
    }
}
class Yr extends Du {
    constructor(e=-1, t=1, n=1, i=-1, s=.1, o=2e3) {
        super(),
        this.isOrthographicCamera = !0,
        this.type = "OrthographicCamera",
        this.zoom = 1,
        this.view = null,
        this.left = e,
        this.right = t,
        this.top = n,
        this.bottom = i,
        this.near = s,
        this.far = o,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.left = e.left,
        this.right = e.right,
        this.top = e.top,
        this.bottom = e.bottom,
        this.near = e.near,
        this.far = e.far,
        this.zoom = e.zoom,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this
    }
    setViewOffset(e, t, n, i, s, o) {
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = n,
        this.view.offsetY = i,
        this.view.width = s,
        this.view.height = o,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = (this.right - this.left) / (2 * this.zoom)
          , t = (this.top - this.bottom) / (2 * this.zoom)
          , n = (this.right + this.left) / 2
          , i = (this.top + this.bottom) / 2;
        let s = n - e
          , o = n + e
          , a = i + t
          , c = i - t;
        if (this.view !== null && this.view.enabled) {
            const l = (this.right - this.left) / this.view.fullWidth / this.zoom
              , u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            s += l * this.view.offsetX,
            o = s + l * this.view.width,
            a -= u * this.view.offsetY,
            c = a - u * this.view.height
        }
        this.projectionMatrix.makeOrthographic(s, o, a, c, this.near, this.far, this.coordinateSystem),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.zoom = this.zoom,
        t.object.left = this.left,
        t.object.right = this.right,
        t.object.top = this.top,
        t.object.bottom = this.bottom,
        t.object.near = this.near,
        t.object.far = this.far,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t
    }
}
class op extends dc {
    constructor() {
        super(new Yr(-5,5,5,-5,.5,500)),
        this.isDirectionalLightShadow = !0
    }
}
class Qu extends kr {
    constructor(e, t) {
        super(e, t),
        this.isDirectionalLight = !0,
        this.type = "DirectionalLight",
        this.position.copy(lt.DEFAULT_UP),
        this.updateMatrix(),
        this.target = new lt,
        this.shadow = new op
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e) {
        return super.copy(e),
        this.target = e.target.clone(),
        this.shadow = e.shadow.clone(),
        this
    }
}
class Ts {
    static extractUrlBase(e) {
        const t = e.lastIndexOf("/");
        return t === -1 ? "./" : e.slice(0, t + 1)
    }
    static resolveURL(e, t) {
        return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
    }
}
class ap extends At {
    constructor() {
        super(),
        this.isInstancedBufferGeometry = !0,
        this.type = "InstancedBufferGeometry",
        this.instanceCount = 1 / 0
    }
    copy(e) {
        return super.copy(e),
        this.instanceCount = e.instanceCount,
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.instanceCount = this.instanceCount,
        e.isInstancedBufferGeometry = !0,
        e
    }
}
const Do = new WeakMap;
class cp extends xi {
    constructor(e) {
        super(e),
        this.isImageBitmapLoader = !0,
        typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
        typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
        this.options = {
            premultiplyAlpha: "none"
        }
    }
    setOptions(e) {
        return this.options = e,
        this
    }
    load(e, t, n, i) {
        e === void 0 && (e = ""),
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const s = this
          , o = $n.get(e);
        if (o !== void 0) {
            if (s.manager.itemStart(e),
            o.then) {
                o.then(l => {
                    if (Do.has(o) === !0)
                        i && i(Do.get(o)),
                        s.manager.itemError(e),
                        s.manager.itemEnd(e);
                    else
                        return t && t(l),
                        s.manager.itemEnd(e),
                        l
                }
                );
                return
            }
            return setTimeout(function() {
                t && t(o),
                s.manager.itemEnd(e)
            }, 0),
            o
        }
        const a = {};
        a.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include",
        a.headers = this.requestHeader;
        const c = fetch(e, a).then(function(l) {
            return l.blob()
        }).then(function(l) {
            return createImageBitmap(l, Object.assign(s.options, {
                colorSpaceConversion: "none"
            }))
        }).then(function(l) {
            return $n.add(e, l),
            t && t(l),
            s.manager.itemEnd(e),
            l
        }).catch(function(l) {
            i && i(l),
            Do.set(c, l),
            $n.remove(e),
            s.manager.itemError(e),
            s.manager.itemEnd(e)
        });
        $n.add(e, c),
        s.manager.itemStart(e)
    }
}
class lp extends Bt {
    constructor(e=[]) {
        super(),
        this.isArrayCamera = !0,
        this.isMultiViewCamera = !1,
        this.cameras = e
    }
}
const fc = "\\[\\]\\.:\\/"
  , up = new RegExp("[" + fc + "]","g")
  , pc = "[^" + fc + "]"
  , hp = "[^" + fc.replace("\\.", "") + "]"
  , dp = /((?:WC+[\/:])*)/.source.replace("WC", pc)
  , fp = /(WCOD+)?/.source.replace("WCOD", hp)
  , pp = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", pc)
  , mp = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", pc)
  , Ap = new RegExp("^" + dp + fp + pp + mp + "$")
  , gp = ["material", "materials", "bones", "map"];
class vp {
    constructor(e, t, n) {
        const i = n || ot.parseTrackName(t);
        this._targetGroup = e,
        this._bindings = e.subscribe_(t, i)
    }
    getValue(e, t) {
        this.bind();
        const n = this._targetGroup.nCachedObjects_
          , i = this._bindings[n];
        i !== void 0 && i.getValue(e, t)
    }
    setValue(e, t) {
        const n = this._bindings;
        for (let i = this._targetGroup.nCachedObjects_, s = n.length; i !== s; ++i)
            n[i].setValue(e, t)
    }
    bind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
            e[t].bind()
    }
    unbind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
            e[t].unbind()
    }
}
class ot {
    constructor(e, t, n) {
        this.path = t,
        this.parsedPath = n || ot.parseTrackName(t),
        this.node = ot.findNode(e, this.parsedPath.nodeName),
        this.rootNode = e,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
    static create(e, t, n) {
        return e && e.isAnimationObjectGroup ? new ot.Composite(e,t,n) : new ot(e,t,n)
    }
    static sanitizeNodeName(e) {
        return e.replace(/\s/g, "_").replace(up, "")
    }
    static parseTrackName(e) {
        const t = Ap.exec(e);
        if (t === null)
            throw new Error("PropertyBinding: Cannot parse trackName: " + e);
        const n = {
            nodeName: t[2],
            objectName: t[3],
            objectIndex: t[4],
            propertyName: t[5],
            propertyIndex: t[6]
        }
          , i = n.nodeName && n.nodeName.lastIndexOf(".");
        if (i !== void 0 && i !== -1) {
            const s = n.nodeName.substring(i + 1);
            gp.indexOf(s) !== -1 && (n.nodeName = n.nodeName.substring(0, i),
            n.objectName = s)
        }
        if (n.propertyName === null || n.propertyName.length === 0)
            throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
        return n
    }
    static findNode(e, t) {
        if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
            return e;
        if (e.skeleton) {
            const n = e.skeleton.getBoneByName(t);
            if (n !== void 0)
                return n
        }
        if (e.children) {
            const n = function(s) {
                for (let o = 0; o < s.length; o++) {
                    const a = s[o];
                    if (a.name === t || a.uuid === t)
                        return a;
                    const c = n(a.children);
                    if (c)
                        return c
                }
                return null
            }
              , i = n(e.children);
            if (i)
                return i
        }
        return null
    }
    _getValue_unavailable() {}
    _setValue_unavailable() {}
    _getValue_direct(e, t) {
        e[t] = this.targetObject[this.propertyName]
    }
    _getValue_array(e, t) {
        const n = this.resolvedProperty;
        for (let i = 0, s = n.length; i !== s; ++i)
            e[t++] = n[i]
    }
    _getValue_arrayElement(e, t) {
        e[t] = this.resolvedProperty[this.propertyIndex]
    }
    _getValue_toArray(e, t) {
        this.resolvedProperty.toArray(e, t)
    }
    _setValue_direct(e, t) {
        this.targetObject[this.propertyName] = e[t]
    }
    _setValue_direct_setNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t],
        this.targetObject.needsUpdate = !0
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_array(e, t) {
        const n = this.resolvedProperty;
        for (let i = 0, s = n.length; i !== s; ++i)
            n[i] = e[t++]
    }
    _setValue_array_setNeedsUpdate(e, t) {
        const n = this.resolvedProperty;
        for (let i = 0, s = n.length; i !== s; ++i)
            n[i] = e[t++];
        this.targetObject.needsUpdate = !0
    }
    _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
        const n = this.resolvedProperty;
        for (let i = 0, s = n.length; i !== s; ++i)
            n[i] = e[t++];
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_arrayElement(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t]
    }
    _setValue_arrayElement_setNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t],
        this.targetObject.needsUpdate = !0
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_fromArray(e, t) {
        this.resolvedProperty.fromArray(e, t)
    }
    _setValue_fromArray_setNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t),
        this.targetObject.needsUpdate = !0
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t),
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _getValue_unbound(e, t) {
        this.bind(),
        this.getValue(e, t)
    }
    _setValue_unbound(e, t) {
        this.bind(),
        this.setValue(e, t)
    }
    bind() {
        let e = this.node;
        const t = this.parsedPath
          , n = t.objectName
          , i = t.propertyName;
        let s = t.propertyIndex;
        if (e || (e = ot.findNode(this.rootNode, t.nodeName),
        this.node = e),
        this.getValue = this._getValue_unavailable,
        this.setValue = this._setValue_unavailable,
        !e) {
            console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
            return
        }
        if (n) {
            let l = t.objectIndex;
            switch (n) {
            case "materials":
                if (!e.material) {
                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    return
                }
                if (!e.material.materials) {
                    console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                    return
                }
                e = e.material.materials;
                break;
            case "bones":
                if (!e.skeleton) {
                    console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                    return
                }
                e = e.skeleton.bones;
                for (let u = 0; u < e.length; u++)
                    if (e[u].name === l) {
                        l = u;
                        break
                    }
                break;
            case "map":
                if ("map"in e) {
                    e = e.map;
                    break
                }
                if (!e.material) {
                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    return
                }
                if (!e.material.map) {
                    console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                    return
                }
                e = e.material.map;
                break;
            default:
                if (e[n] === void 0) {
                    console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                    return
                }
                e = e[n]
            }
            if (l !== void 0) {
                if (e[l] === void 0) {
                    console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                    return
                }
                e = e[l]
            }
        }
        const o = e[i];
        if (o === void 0) {
            const l = t.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + l + "." + i + " but it wasn't found.", e);
            return
        }
        let a = this.Versioning.None;
        this.targetObject = e,
        e.isMaterial === !0 ? a = this.Versioning.NeedsUpdate : e.isObject3D === !0 && (a = this.Versioning.MatrixWorldNeedsUpdate);
        let c = this.BindingType.Direct;
        if (s !== void 0) {
            if (i === "morphTargetInfluences") {
                if (!e.geometry) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                    return
                }
                if (!e.geometry.morphAttributes) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                    return
                }
                e.morphTargetDictionary[s] !== void 0 && (s = e.morphTargetDictionary[s])
            }
            c = this.BindingType.ArrayElement,
            this.resolvedProperty = o,
            this.propertyIndex = s
        } else
            o.fromArray !== void 0 && o.toArray !== void 0 ? (c = this.BindingType.HasFromToArray,
            this.resolvedProperty = o) : Array.isArray(o) ? (c = this.BindingType.EntireArray,
            this.resolvedProperty = o) : this.propertyName = i;
        this.getValue = this.GetterByBindingType[c],
        this.setValue = this.SetterByBindingTypeAndVersioning[c][a]
    }
    unbind() {
        this.node = null,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
}
ot.Composite = vp;
ot.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
};
ot.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
};
ot.prototype.GetterByBindingType = [ot.prototype._getValue_direct, ot.prototype._getValue_array, ot.prototype._getValue_arrayElement, ot.prototype._getValue_toArray];
ot.prototype.SetterByBindingTypeAndVersioning = [[ot.prototype._setValue_direct, ot.prototype._setValue_direct_setNeedsUpdate, ot.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [ot.prototype._setValue_array, ot.prototype._setValue_array_setNeedsUpdate, ot.prototype._setValue_array_setMatrixWorldNeedsUpdate], [ot.prototype._setValue_arrayElement, ot.prototype._setValue_arrayElement_setNeedsUpdate, ot.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [ot.prototype._setValue_fromArray, ot.prototype._setValue_fromArray_setNeedsUpdate, ot.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
class Ba extends Ou {
    constructor(e, t, n=1) {
        super(e, t),
        this.isInstancedInterleavedBuffer = !0,
        this.meshPerAttribute = n
    }
    copy(e) {
        return super.copy(e),
        this.meshPerAttribute = e.meshPerAttribute,
        this
    }
    clone(e) {
        const t = super.clone(e);
        return t.meshPerAttribute = this.meshPerAttribute,
        t
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.isInstancedInterleavedBuffer = !0,
        t.meshPerAttribute = this.meshPerAttribute,
        t
    }
}
const wl = new We;
class Vr {
    constructor(e, t, n=0, i=1 / 0) {
        this.ray = new _s(e,t),
        this.near = n,
        this.far = i,
        this.camera = null,
        this.layers = new ic,
        this.params = {
            Mesh: {},
            Line: {
                threshold: 1
            },
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        }
    }
    set(e, t) {
        this.ray.set(e, t)
    }
    setFromCamera(e, t) {
        t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
        this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(),
        this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t),
        this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
        this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
    }
    setFromXRController(e) {
        return wl.identity().extractRotation(e.matrixWorld),
        this.ray.origin.setFromMatrixPosition(e.matrixWorld),
        this.ray.direction.set(0, 0, -1).applyMatrix4(wl),
        this
    }
    intersectObject(e, t=!0, n=[]) {
        return Fa(e, this, n, t),
        n.sort(Sl),
        n
    }
    intersectObjects(e, t=!0, n=[]) {
        for (let i = 0, s = e.length; i < s; i++)
            Fa(e[i], this, n, t);
        return n.sort(Sl),
        n
    }
}
function Sl(r, e) {
    return r.distance - e.distance
}
function Fa(r, e, t, n) {
    let i = !0;
    if (r.layers.test(e.layers) && r.raycast(e, t) === !1 && (i = !1),
    i === !0 && n === !0) {
        const s = r.children;
        for (let o = 0, a = s.length; o < a; o++)
            Fa(s[o], e, t, !0)
    }
}
const Tl = new D
  , br = new D;
class xp {
    constructor(e=new D, t=new D) {
        this.start = e,
        this.end = t
    }
    set(e, t) {
        return this.start.copy(e),
        this.end.copy(t),
        this
    }
    copy(e) {
        return this.start.copy(e.start),
        this.end.copy(e.end),
        this
    }
    getCenter(e) {
        return e.addVectors(this.start, this.end).multiplyScalar(.5)
    }
    delta(e) {
        return e.subVectors(this.end, this.start)
    }
    distanceSq() {
        return this.start.distanceToSquared(this.end)
    }
    distance() {
        return this.start.distanceTo(this.end)
    }
    at(e, t) {
        return this.delta(t).multiplyScalar(e).add(this.start)
    }
    closestPointToPointParameter(e, t) {
        Tl.subVectors(e, this.start),
        br.subVectors(this.end, this.start);
        const n = br.dot(br);
        let s = br.dot(Tl) / n;
        return t && (s = Ke(s, 0, 1)),
        s
    }
    closestPointToPoint(e, t, n) {
        const i = this.closestPointToPointParameter(e, t);
        return this.delta(n).multiplyScalar(i).add(this.start)
    }
    applyMatrix4(e) {
        return this.start.applyMatrix4(e),
        this.end.applyMatrix4(e),
        this
    }
    equals(e) {
        return e.start.equals(this.start) && e.end.equals(this.end)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class yp extends Bu {
    constructor(e=1) {
        const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e]
          , n = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1]
          , i = new At;
        i.setAttribute("position", new yt(t,3)),
        i.setAttribute("color", new yt(n,3));
        const s = new jr({
            vertexColors: !0,
            toneMapped: !1
        });
        super(i, s),
        this.type = "AxesHelper"
    }
    setColors(e, t, n) {
        const i = new Ge
          , s = this.geometry.attributes.color.array;
        return i.set(e),
        i.toArray(s, 0),
        i.toArray(s, 3),
        i.set(t),
        i.toArray(s, 6),
        i.toArray(s, 9),
        i.set(n),
        i.toArray(s, 12),
        i.toArray(s, 15),
        this.geometry.attributes.color.needsUpdate = !0,
        this
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
class bp {
    constructor() {
        this.type = "ShapePath",
        this.color = new Ge,
        this.subPaths = [],
        this.currentPath = null
    }
    moveTo(e, t) {
        return this.currentPath = new za,
        this.subPaths.push(this.currentPath),
        this.currentPath.moveTo(e, t),
        this
    }
    lineTo(e, t) {
        return this.currentPath.lineTo(e, t),
        this
    }
    quadraticCurveTo(e, t, n, i) {
        return this.currentPath.quadraticCurveTo(e, t, n, i),
        this
    }
    bezierCurveTo(e, t, n, i, s, o) {
        return this.currentPath.bezierCurveTo(e, t, n, i, s, o),
        this
    }
    splineThru(e) {
        return this.currentPath.splineThru(e),
        this
    }
    toShapes(e) {
        function t(p) {
            const S = [];
            for (let w = 0, b = p.length; w < b; w++) {
                const B = p[w]
                  , z = new Ss;
                z.curves = B.curves,
                S.push(z)
            }
            return S
        }
        function n(p, S) {
            const w = S.length;
            let b = !1;
            for (let B = w - 1, z = 0; z < w; B = z++) {
                let I = S[B]
                  , H = S[z]
                  , P = H.x - I.x
                  , T = H.y - I.y;
                if (Math.abs(T) > Number.EPSILON) {
                    if (T < 0 && (I = S[z],
                    P = -P,
                    H = S[B],
                    T = -T),
                    p.y < I.y || p.y > H.y)
                        continue;
                    if (p.y === I.y) {
                        if (p.x === I.x)
                            return !0
                    } else {
                        const _ = T * (p.x - I.x) - P * (p.y - I.y);
                        if (_ === 0)
                            return !0;
                        if (_ < 0)
                            continue;
                        b = !b
                    }
                } else {
                    if (p.y !== I.y)
                        continue;
                    if (H.x <= p.x && p.x <= I.x || I.x <= p.x && p.x <= H.x)
                        return !0
                }
            }
            return b
        }
        const i = bn.isClockWise
          , s = this.subPaths;
        if (s.length === 0)
            return [];
        let o, a, c;
        const l = [];
        if (s.length === 1)
            return a = s[0],
            c = new Ss,
            c.curves = a.curves,
            l.push(c),
            l;
        let u = !i(s[0].getPoints());
        u = e ? !u : u;
        const h = []
          , d = [];
        let f = [], m = 0, g;
        d[m] = void 0,
        f[m] = [];
        for (let p = 0, S = s.length; p < S; p++)
            a = s[p],
            g = a.getPoints(),
            o = i(g),
            o = e ? !o : o,
            o ? (!u && d[m] && m++,
            d[m] = {
                s: new Ss,
                p: g
            },
            d[m].s.curves = a.curves,
            u && m++,
            f[m] = []) : f[m].push({
                h: a,
                p: g[0]
            });
        if (!d[0])
            return t(s);
        if (d.length > 1) {
            let p = !1
              , S = 0;
            for (let w = 0, b = d.length; w < b; w++)
                h[w] = [];
            for (let w = 0, b = d.length; w < b; w++) {
                const B = f[w];
                for (let z = 0; z < B.length; z++) {
                    const I = B[z];
                    let H = !0;
                    for (let P = 0; P < d.length; P++)
                        n(I.p, d[P].p) && (w !== P && S++,
                        H ? (H = !1,
                        h[P].push(I)) : p = !0);
                    H && h[w].push(I)
                }
            }
            S > 0 && p === !1 && (f = h)
        }
        let A;
        for (let p = 0, S = d.length; p < S; p++) {
            c = d[p].s,
            l.push(c),
            A = f[p];
            for (let w = 0, b = A.length; w < b; w++)
                c.holes.push(A[w].h)
        }
        return l
    }
}
function El(r, e, t, n) {
    const i = Mp(n);
    switch (t) {
    case xu:
        return r * e;
    case Ka:
        return r * e / i.components * i.byteLength;
    case Qa:
        return r * e / i.components * i.byteLength;
    case bu:
        return r * e * 2 / i.components * i.byteLength;
    case Ja:
        return r * e * 2 / i.components * i.byteLength;
    case yu:
        return r * e * 3 / i.components * i.byteLength;
    case tn:
        return r * e * 4 / i.components * i.byteLength;
    case $a:
        return r * e * 4 / i.components * i.byteLength;
    case Rr:
    case Dr:
        return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case Nr:
    case Or:
        return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case ia:
    case ra:
        return Math.max(r, 16) * Math.max(e, 8) / 4;
    case na:
    case sa:
        return Math.max(r, 8) * Math.max(e, 8) / 2;
    case oa:
    case aa:
        return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case ca:
        return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case la:
        return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case ua:
        return Math.floor((r + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case ha:
        return Math.floor((r + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case da:
        return Math.floor((r + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case fa:
        return Math.floor((r + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case pa:
        return Math.floor((r + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case ma:
        return Math.floor((r + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case Aa:
        return Math.floor((r + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case ga:
        return Math.floor((r + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case va:
        return Math.floor((r + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case xa:
        return Math.floor((r + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case ya:
        return Math.floor((r + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case ba:
        return Math.floor((r + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case Ma:
        return Math.floor((r + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    case zr:
    case wa:
    case Sa:
        return Math.ceil(r / 4) * Math.ceil(e / 4) * 16;
    case Mu:
    case Ta:
        return Math.ceil(r / 4) * Math.ceil(e / 4) * 8;
    case Ea:
    case Pa:
        return Math.ceil(r / 4) * Math.ceil(e / 4) * 16
    }
    throw new Error(`Unable to determine texture byte length for ${t} format.`)
}
function Mp(r) {
    switch (r) {
    case Mn:
    case Au:
        return {
            byteLength: 1,
            components: 1
        };
    case Es:
    case gu:
    case Fs:
        return {
            byteLength: 2,
            components: 1
        };
    case qa:
    case Za:
        return {
            byteLength: 2,
            components: 4
        };
    case Ai:
    case Ya:
    case dn:
        return {
            byteLength: 4,
            components: 1
        };
    case vu:
        return {
            byteLength: 4,
            components: 3
        }
    }
    throw new Error(`Unknown texture type ${r}.`)
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
    detail: {
        revision: Wa
    }
}));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Wa);
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
function Ju() {
    let r = null
      , e = !1
      , t = null
      , n = null;
    function i(s, o) {
        t(s, o),
        n = r.requestAnimationFrame(i)
    }
    return {
        start: function() {
            e !== !0 && t !== null && (n = r.requestAnimationFrame(i),
            e = !0)
        },
        stop: function() {
            r.cancelAnimationFrame(n),
            e = !1
        },
        setAnimationLoop: function(s) {
            t = s
        },
        setContext: function(s) {
            r = s
        }
    }
}
function wp(r) {
    const e = new WeakMap;
    function t(a, c) {
        const l = a.array
          , u = a.usage
          , h = l.byteLength
          , d = r.createBuffer();
        r.bindBuffer(c, d),
        r.bufferData(c, l, u),
        a.onUploadCallback();
        let f;
        if (l instanceof Float32Array)
            f = r.FLOAT;
        else if (l instanceof Uint16Array)
            a.isFloat16BufferAttribute ? f = r.HALF_FLOAT : f = r.UNSIGNED_SHORT;
        else if (l instanceof Int16Array)
            f = r.SHORT;
        else if (l instanceof Uint32Array)
            f = r.UNSIGNED_INT;
        else if (l instanceof Int32Array)
            f = r.INT;
        else if (l instanceof Int8Array)
            f = r.BYTE;
        else if (l instanceof Uint8Array)
            f = r.UNSIGNED_BYTE;
        else if (l instanceof Uint8ClampedArray)
            f = r.UNSIGNED_BYTE;
        else
            throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + l);
        return {
            buffer: d,
            type: f,
            bytesPerElement: l.BYTES_PER_ELEMENT,
            version: a.version,
            size: h
        }
    }
    function n(a, c, l) {
        const u = c.array
          , h = c.updateRanges;
        if (r.bindBuffer(l, a),
        h.length === 0)
            r.bufferSubData(l, 0, u);
        else {
            h.sort( (f, m) => f.start - m.start);
            let d = 0;
            for (let f = 1; f < h.length; f++) {
                const m = h[d]
                  , g = h[f];
                g.start <= m.start + m.count + 1 ? m.count = Math.max(m.count, g.start + g.count - m.start) : (++d,
                h[d] = g)
            }
            h.length = d + 1;
            for (let f = 0, m = h.length; f < m; f++) {
                const g = h[f];
                r.bufferSubData(l, g.start * u.BYTES_PER_ELEMENT, u, g.start, g.count)
            }
            c.clearUpdateRanges()
        }
        c.onUploadCallback()
    }
    function i(a) {
        return a.isInterleavedBufferAttribute && (a = a.data),
        e.get(a)
    }
    function s(a) {
        a.isInterleavedBufferAttribute && (a = a.data);
        const c = e.get(a);
        c && (r.deleteBuffer(c.buffer),
        e.delete(a))
    }
    function o(a, c) {
        if (a.isInterleavedBufferAttribute && (a = a.data),
        a.isGLBufferAttribute) {
            const u = e.get(a);
            (!u || u.version < a.version) && e.set(a, {
                buffer: a.buffer,
                type: a.type,
                bytesPerElement: a.elementSize,
                version: a.version
            });
            return
        }
        const l = e.get(a);
        if (l === void 0)
            e.set(a, t(a, c));
        else if (l.version < a.version) {
            if (l.size !== a.array.byteLength)
                throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
            n(l.buffer, a, c),
            l.version = a.version
        }
    }
    return {
        get: i,
        remove: s,
        update: o
    }
}
var Sp = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`
  , Tp = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`
  , Ep = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`
  , Pp = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , Lp = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`
  , Cp = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`
  , Rp = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`
  , Dp = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`
  , Np = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`
  , Op = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`
  , zp = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`
  , Ip = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`
  , Up = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`
  , Bp = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`
  , Fp = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`
  , _p = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`
  , Hp = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`
  , Xp = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`
  , Gp = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`
  , Vp = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`
  , Wp = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`
  , jp = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`
  , kp = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`
  , Yp = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`
  , qp = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`
  , Zp = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`
  , Kp = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`
  , Qp = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`
  , Jp = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`
  , $p = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`
  , em = "gl_FragColor = linearToOutputTexel( gl_FragColor );"
  , tm = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`
  , nm = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`
  , im = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`
  , sm = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`
  , rm = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`
  , om = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`
  , am = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`
  , cm = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`
  , lm = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`
  , um = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`
  , hm = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`
  , dm = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`
  , fm = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`
  , pm = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`
  , mm = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`
  , Am = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`
  , gm = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`
  , vm = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`
  , xm = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`
  , ym = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`
  , bm = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`
  , Mm = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`
  , wm = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`
  , Sm = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`
  , Tm = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`
  , Em = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`
  , Pm = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`
  , Lm = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`
  , Cm = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`
  , Rm = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`
  , Dm = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`
  , Nm = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`
  , Om = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , zm = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`
  , Im = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`
  , Um = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`
  , Bm = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`
  , Fm = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`
  , _m = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`
  , Hm = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`
  , Xm = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`
  , Gm = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`
  , Vm = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , Wm = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , jm = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`
  , km = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`
  , Ym = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`
  , qm = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`
  , Zm = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`
  , Km = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`
  , Qm = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`
  , Jm = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`
  , $m = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`
  , eA = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`
  , tA = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`
  , nA = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`
  , iA = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`
  , sA = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`
  , rA = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`
  , oA = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`
  , aA = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`
  , cA = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`
  , lA = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`
  , uA = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`
  , hA = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`
  , dA = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`
  , fA = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`
  , pA = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`
  , mA = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`
  , AA = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`
  , gA = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`
  , vA = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`
  , xA = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`
  , yA = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`
  , bA = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`
  , MA = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const wA = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`
  , SA = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , TA = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
  , EA = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , PA = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
  , LA = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , CA = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`
  , RA = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`
  , DA = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`
  , NA = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`
  , OA = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`
  , zA = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , IA = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , UA = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , BA = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`
  , FA = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , _A = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , HA = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , XA = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`
  , GA = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , VA = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`
  , WA = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`
  , jA = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , kA = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , YA = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`
  , qA = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , ZA = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , KA = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , QA = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`
  , JA = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , $A = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , eg = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`
  , tg = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , ng = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`
  , Ze = {
    alphahash_fragment: Sp,
    alphahash_pars_fragment: Tp,
    alphamap_fragment: Ep,
    alphamap_pars_fragment: Pp,
    alphatest_fragment: Lp,
    alphatest_pars_fragment: Cp,
    aomap_fragment: Rp,
    aomap_pars_fragment: Dp,
    batching_pars_vertex: Np,
    batching_vertex: Op,
    begin_vertex: zp,
    beginnormal_vertex: Ip,
    bsdfs: Up,
    iridescence_fragment: Bp,
    bumpmap_pars_fragment: Fp,
    clipping_planes_fragment: _p,
    clipping_planes_pars_fragment: Hp,
    clipping_planes_pars_vertex: Xp,
    clipping_planes_vertex: Gp,
    color_fragment: Vp,
    color_pars_fragment: Wp,
    color_pars_vertex: jp,
    color_vertex: kp,
    common: Yp,
    cube_uv_reflection_fragment: qp,
    defaultnormal_vertex: Zp,
    displacementmap_pars_vertex: Kp,
    displacementmap_vertex: Qp,
    emissivemap_fragment: Jp,
    emissivemap_pars_fragment: $p,
    colorspace_fragment: em,
    colorspace_pars_fragment: tm,
    envmap_fragment: nm,
    envmap_common_pars_fragment: im,
    envmap_pars_fragment: sm,
    envmap_pars_vertex: rm,
    envmap_physical_pars_fragment: Am,
    envmap_vertex: om,
    fog_vertex: am,
    fog_pars_vertex: cm,
    fog_fragment: lm,
    fog_pars_fragment: um,
    gradientmap_pars_fragment: hm,
    lightmap_pars_fragment: dm,
    lights_lambert_fragment: fm,
    lights_lambert_pars_fragment: pm,
    lights_pars_begin: mm,
    lights_toon_fragment: gm,
    lights_toon_pars_fragment: vm,
    lights_phong_fragment: xm,
    lights_phong_pars_fragment: ym,
    lights_physical_fragment: bm,
    lights_physical_pars_fragment: Mm,
    lights_fragment_begin: wm,
    lights_fragment_maps: Sm,
    lights_fragment_end: Tm,
    logdepthbuf_fragment: Em,
    logdepthbuf_pars_fragment: Pm,
    logdepthbuf_pars_vertex: Lm,
    logdepthbuf_vertex: Cm,
    map_fragment: Rm,
    map_pars_fragment: Dm,
    map_particle_fragment: Nm,
    map_particle_pars_fragment: Om,
    metalnessmap_fragment: zm,
    metalnessmap_pars_fragment: Im,
    morphinstance_vertex: Um,
    morphcolor_vertex: Bm,
    morphnormal_vertex: Fm,
    morphtarget_pars_vertex: _m,
    morphtarget_vertex: Hm,
    normal_fragment_begin: Xm,
    normal_fragment_maps: Gm,
    normal_pars_fragment: Vm,
    normal_pars_vertex: Wm,
    normal_vertex: jm,
    normalmap_pars_fragment: km,
    clearcoat_normal_fragment_begin: Ym,
    clearcoat_normal_fragment_maps: qm,
    clearcoat_pars_fragment: Zm,
    iridescence_pars_fragment: Km,
    opaque_fragment: Qm,
    packing: Jm,
    premultiplied_alpha_fragment: $m,
    project_vertex: eA,
    dithering_fragment: tA,
    dithering_pars_fragment: nA,
    roughnessmap_fragment: iA,
    roughnessmap_pars_fragment: sA,
    shadowmap_pars_fragment: rA,
    shadowmap_pars_vertex: oA,
    shadowmap_vertex: aA,
    shadowmask_pars_fragment: cA,
    skinbase_vertex: lA,
    skinning_pars_vertex: uA,
    skinning_vertex: hA,
    skinnormal_vertex: dA,
    specularmap_fragment: fA,
    specularmap_pars_fragment: pA,
    tonemapping_fragment: mA,
    tonemapping_pars_fragment: AA,
    transmission_fragment: gA,
    transmission_pars_fragment: vA,
    uv_pars_fragment: xA,
    uv_pars_vertex: yA,
    uv_vertex: bA,
    worldpos_vertex: MA,
    background_vert: wA,
    background_frag: SA,
    backgroundCube_vert: TA,
    backgroundCube_frag: EA,
    cube_vert: PA,
    cube_frag: LA,
    depth_vert: CA,
    depth_frag: RA,
    distanceRGBA_vert: DA,
    distanceRGBA_frag: NA,
    equirect_vert: OA,
    equirect_frag: zA,
    linedashed_vert: IA,
    linedashed_frag: UA,
    meshbasic_vert: BA,
    meshbasic_frag: FA,
    meshlambert_vert: _A,
    meshlambert_frag: HA,
    meshmatcap_vert: XA,
    meshmatcap_frag: GA,
    meshnormal_vert: VA,
    meshnormal_frag: WA,
    meshphong_vert: jA,
    meshphong_frag: kA,
    meshphysical_vert: YA,
    meshphysical_frag: qA,
    meshtoon_vert: ZA,
    meshtoon_frag: KA,
    points_vert: QA,
    points_frag: JA,
    shadow_vert: $A,
    shadow_frag: eg,
    sprite_vert: tg,
    sprite_frag: ng
}
  , Se = {
    common: {
        diffuse: {
            value: new Ge(16777215)
        },
        opacity: {
            value: 1
        },
        map: {
            value: null
        },
        mapTransform: {
            value: new qe
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new qe
        },
        alphaTest: {
            value: 0
        }
    },
    specularmap: {
        specularMap: {
            value: null
        },
        specularMapTransform: {
            value: new qe
        }
    },
    envmap: {
        envMap: {
            value: null
        },
        envMapRotation: {
            value: new qe
        },
        flipEnvMap: {
            value: -1
        },
        reflectivity: {
            value: 1
        },
        ior: {
            value: 1.5
        },
        refractionRatio: {
            value: .98
        }
    },
    aomap: {
        aoMap: {
            value: null
        },
        aoMapIntensity: {
            value: 1
        },
        aoMapTransform: {
            value: new qe
        }
    },
    lightmap: {
        lightMap: {
            value: null
        },
        lightMapIntensity: {
            value: 1
        },
        lightMapTransform: {
            value: new qe
        }
    },
    bumpmap: {
        bumpMap: {
            value: null
        },
        bumpMapTransform: {
            value: new qe
        },
        bumpScale: {
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            value: null
        },
        normalMapTransform: {
            value: new qe
        },
        normalScale: {
            value: new Ae(1,1)
        }
    },
    displacementmap: {
        displacementMap: {
            value: null
        },
        displacementMapTransform: {
            value: new qe
        },
        displacementScale: {
            value: 1
        },
        displacementBias: {
            value: 0
        }
    },
    emissivemap: {
        emissiveMap: {
            value: null
        },
        emissiveMapTransform: {
            value: new qe
        }
    },
    metalnessmap: {
        metalnessMap: {
            value: null
        },
        metalnessMapTransform: {
            value: new qe
        }
    },
    roughnessmap: {
        roughnessMap: {
            value: null
        },
        roughnessMapTransform: {
            value: new qe
        }
    },
    gradientmap: {
        gradientMap: {
            value: null
        }
    },
    fog: {
        fogDensity: {
            value: 25e-5
        },
        fogNear: {
            value: 1
        },
        fogFar: {
            value: 2e3
        },
        fogColor: {
            value: new Ge(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            value: []
        },
        lightProbe: {
            value: []
        },
        directionalLights: {
            value: [],
            properties: {
                direction: {},
                color: {}
            }
        },
        directionalLightShadows: {
            value: [],
            properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        directionalShadowMap: {
            value: []
        },
        directionalShadowMatrix: {
            value: []
        },
        spotLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {}
            }
        },
        spotLightShadows: {
            value: [],
            properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        spotLightMap: {
            value: []
        },
        spotShadowMap: {
            value: []
        },
        spotLightMatrix: {
            value: []
        },
        pointLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                decay: {},
                distance: {}
            }
        },
        pointLightShadows: {
            value: [],
            properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {}
            }
        },
        pointShadowMap: {
            value: []
        },
        pointShadowMatrix: {
            value: []
        },
        hemisphereLights: {
            value: [],
            properties: {
                direction: {},
                skyColor: {},
                groundColor: {}
            }
        },
        rectAreaLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                width: {},
                height: {}
            }
        },
        ltc_1: {
            value: null
        },
        ltc_2: {
            value: null
        }
    },
    points: {
        diffuse: {
            value: new Ge(16777215)
        },
        opacity: {
            value: 1
        },
        size: {
            value: 1
        },
        scale: {
            value: 1
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new qe
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new qe
        }
    },
    sprite: {
        diffuse: {
            value: new Ge(16777215)
        },
        opacity: {
            value: 1
        },
        center: {
            value: new Ae(.5,.5)
        },
        rotation: {
            value: 0
        },
        map: {
            value: null
        },
        mapTransform: {
            value: new qe
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new qe
        },
        alphaTest: {
            value: 0
        }
    }
}
  , Gt = {
    basic: {
        uniforms: Ut([Se.common, Se.specularmap, Se.envmap, Se.aomap, Se.lightmap, Se.fog]),
        vertexShader: Ze.meshbasic_vert,
        fragmentShader: Ze.meshbasic_frag
    },
    lambert: {
        uniforms: Ut([Se.common, Se.specularmap, Se.envmap, Se.aomap, Se.lightmap, Se.emissivemap, Se.bumpmap, Se.normalmap, Se.displacementmap, Se.fog, Se.lights, {
            emissive: {
                value: new Ge(0)
            }
        }]),
        vertexShader: Ze.meshlambert_vert,
        fragmentShader: Ze.meshlambert_frag
    },
    phong: {
        uniforms: Ut([Se.common, Se.specularmap, Se.envmap, Se.aomap, Se.lightmap, Se.emissivemap, Se.bumpmap, Se.normalmap, Se.displacementmap, Se.fog, Se.lights, {
            emissive: {
                value: new Ge(0)
            },
            specular: {
                value: new Ge(1118481)
            },
            shininess: {
                value: 30
            }
        }]),
        vertexShader: Ze.meshphong_vert,
        fragmentShader: Ze.meshphong_frag
    },
    standard: {
        uniforms: Ut([Se.common, Se.envmap, Se.aomap, Se.lightmap, Se.emissivemap, Se.bumpmap, Se.normalmap, Se.displacementmap, Se.roughnessmap, Se.metalnessmap, Se.fog, Se.lights, {
            emissive: {
                value: new Ge(0)
            },
            roughness: {
                value: 1
            },
            metalness: {
                value: 0
            },
            envMapIntensity: {
                value: 1
            }
        }]),
        vertexShader: Ze.meshphysical_vert,
        fragmentShader: Ze.meshphysical_frag
    },
    toon: {
        uniforms: Ut([Se.common, Se.aomap, Se.lightmap, Se.emissivemap, Se.bumpmap, Se.normalmap, Se.displacementmap, Se.gradientmap, Se.fog, Se.lights, {
            emissive: {
                value: new Ge(0)
            }
        }]),
        vertexShader: Ze.meshtoon_vert,
        fragmentShader: Ze.meshtoon_frag
    },
    matcap: {
        uniforms: Ut([Se.common, Se.bumpmap, Se.normalmap, Se.displacementmap, Se.fog, {
            matcap: {
                value: null
            }
        }]),
        vertexShader: Ze.meshmatcap_vert,
        fragmentShader: Ze.meshmatcap_frag
    },
    points: {
        uniforms: Ut([Se.points, Se.fog]),
        vertexShader: Ze.points_vert,
        fragmentShader: Ze.points_frag
    },
    dashed: {
        uniforms: Ut([Se.common, Se.fog, {
            scale: {
                value: 1
            },
            dashSize: {
                value: 1
            },
            totalSize: {
                value: 2
            }
        }]),
        vertexShader: Ze.linedashed_vert,
        fragmentShader: Ze.linedashed_frag
    },
    depth: {
        uniforms: Ut([Se.common, Se.displacementmap]),
        vertexShader: Ze.depth_vert,
        fragmentShader: Ze.depth_frag
    },
    normal: {
        uniforms: Ut([Se.common, Se.bumpmap, Se.normalmap, Se.displacementmap, {
            opacity: {
                value: 1
            }
        }]),
        vertexShader: Ze.meshnormal_vert,
        fragmentShader: Ze.meshnormal_frag
    },
    sprite: {
        uniforms: Ut([Se.sprite, Se.fog]),
        vertexShader: Ze.sprite_vert,
        fragmentShader: Ze.sprite_frag
    },
    background: {
        uniforms: {
            uvTransform: {
                value: new qe
            },
            t2D: {
                value: null
            },
            backgroundIntensity: {
                value: 1
            }
        },
        vertexShader: Ze.background_vert,
        fragmentShader: Ze.background_frag
    },
    backgroundCube: {
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            backgroundBlurriness: {
                value: 0
            },
            backgroundIntensity: {
                value: 1
            },
            backgroundRotation: {
                value: new qe
            }
        },
        vertexShader: Ze.backgroundCube_vert,
        fragmentShader: Ze.backgroundCube_frag
    },
    cube: {
        uniforms: {
            tCube: {
                value: null
            },
            tFlip: {
                value: -1
            },
            opacity: {
                value: 1
            }
        },
        vertexShader: Ze.cube_vert,
        fragmentShader: Ze.cube_frag
    },
    equirect: {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: Ze.equirect_vert,
        fragmentShader: Ze.equirect_frag
    },
    distanceRGBA: {
        uniforms: Ut([Se.common, Se.displacementmap, {
            referencePosition: {
                value: new D
            },
            nearDistance: {
                value: 1
            },
            farDistance: {
                value: 1e3
            }
        }]),
        vertexShader: Ze.distanceRGBA_vert,
        fragmentShader: Ze.distanceRGBA_frag
    },
    shadow: {
        uniforms: Ut([Se.lights, Se.fog, {
            color: {
                value: new Ge(0)
            },
            opacity: {
                value: 1
            }
        }]),
        vertexShader: Ze.shadow_vert,
        fragmentShader: Ze.shadow_frag
    }
};
Gt.physical = {
    uniforms: Ut([Gt.standard.uniforms, {
        clearcoat: {
            value: 0
        },
        clearcoatMap: {
            value: null
        },
        clearcoatMapTransform: {
            value: new qe
        },
        clearcoatNormalMap: {
            value: null
        },
        clearcoatNormalMapTransform: {
            value: new qe
        },
        clearcoatNormalScale: {
            value: new Ae(1,1)
        },
        clearcoatRoughness: {
            value: 0
        },
        clearcoatRoughnessMap: {
            value: null
        },
        clearcoatRoughnessMapTransform: {
            value: new qe
        },
        dispersion: {
            value: 0
        },
        iridescence: {
            value: 0
        },
        iridescenceMap: {
            value: null
        },
        iridescenceMapTransform: {
            value: new qe
        },
        iridescenceIOR: {
            value: 1.3
        },
        iridescenceThicknessMinimum: {
            value: 100
        },
        iridescenceThicknessMaximum: {
            value: 400
        },
        iridescenceThicknessMap: {
            value: null
        },
        iridescenceThicknessMapTransform: {
            value: new qe
        },
        sheen: {
            value: 0
        },
        sheenColor: {
            value: new Ge(0)
        },
        sheenColorMap: {
            value: null
        },
        sheenColorMapTransform: {
            value: new qe
        },
        sheenRoughness: {
            value: 1
        },
        sheenRoughnessMap: {
            value: null
        },
        sheenRoughnessMapTransform: {
            value: new qe
        },
        transmission: {
            value: 0
        },
        transmissionMap: {
            value: null
        },
        transmissionMapTransform: {
            value: new qe
        },
        transmissionSamplerSize: {
            value: new Ae
        },
        transmissionSamplerMap: {
            value: null
        },
        thickness: {
            value: 0
        },
        thicknessMap: {
            value: null
        },
        thicknessMapTransform: {
            value: new qe
        },
        attenuationDistance: {
            value: 0
        },
        attenuationColor: {
            value: new Ge(0)
        },
        specularColor: {
            value: new Ge(1,1,1)
        },
        specularColorMap: {
            value: null
        },
        specularColorMapTransform: {
            value: new qe
        },
        specularIntensity: {
            value: 1
        },
        specularIntensityMap: {
            value: null
        },
        specularIntensityMapTransform: {
            value: new qe
        },
        anisotropyVector: {
            value: new Ae
        },
        anisotropyMap: {
            value: null
        },
        anisotropyMapTransform: {
            value: new qe
        }
    }]),
    vertexShader: Ze.meshphysical_vert,
    fragmentShader: Ze.meshphysical_frag
};
const Mr = {
    r: 0,
    b: 0,
    g: 0
}
  , ci = new Ft
  , ig = new We;
function sg(r, e, t, n, i, s, o) {
    const a = new Ge(0);
    let c = s === !0 ? 0 : 1, l, u, h = null, d = 0, f = null;
    function m(w) {
        let b = w.isScene === !0 ? w.background : null;
        return b && b.isTexture && (b = (w.backgroundBlurriness > 0 ? t : e).get(b)),
        b
    }
    function g(w) {
        let b = !1;
        const B = m(w);
        B === null ? p(a, c) : B && B.isColor && (p(B, 1),
        b = !0);
        const z = r.xr.getEnvironmentBlendMode();
        z === "additive" ? n.buffers.color.setClear(0, 0, 0, 1, o) : z === "alpha-blend" && n.buffers.color.setClear(0, 0, 0, 0, o),
        (r.autoClear || b) && (n.buffers.depth.setTest(!0),
        n.buffers.depth.setMask(!0),
        n.buffers.color.setMask(!0),
        r.clear(r.autoClearColor, r.autoClearDepth, r.autoClearStencil))
    }
    function A(w, b) {
        const B = m(b);
        B && (B.isCubeTexture || B.mapping === Wr) ? (u === void 0 && (u = new ct(new Hs(1,1,1),new wn({
            name: "BackgroundCubeMaterial",
            uniforms: qi(Gt.backgroundCube.uniforms),
            vertexShader: Gt.backgroundCube.vertexShader,
            fragmentShader: Gt.backgroundCube.fragmentShader,
            side: Vt,
            depthTest: !1,
            depthWrite: !1,
            fog: !1,
            allowOverride: !1
        })),
        u.geometry.deleteAttribute("normal"),
        u.geometry.deleteAttribute("uv"),
        u.onBeforeRender = function(z, I, H) {
            this.matrixWorld.copyPosition(H.matrixWorld)
        }
        ,
        Object.defineProperty(u.material, "envMap", {
            get: function() {
                return this.uniforms.envMap.value
            }
        }),
        i.update(u)),
        ci.copy(b.backgroundRotation),
        ci.x *= -1,
        ci.y *= -1,
        ci.z *= -1,
        B.isCubeTexture && B.isRenderTargetTexture === !1 && (ci.y *= -1,
        ci.z *= -1),
        u.material.uniforms.envMap.value = B,
        u.material.uniforms.flipEnvMap.value = B.isCubeTexture && B.isRenderTargetTexture === !1 ? -1 : 1,
        u.material.uniforms.backgroundBlurriness.value = b.backgroundBlurriness,
        u.material.uniforms.backgroundIntensity.value = b.backgroundIntensity,
        u.material.uniforms.backgroundRotation.value.setFromMatrix4(ig.makeRotationFromEuler(ci)),
        u.material.toneMapped = et.getTransfer(B.colorSpace) !== at,
        (h !== B || d !== B.version || f !== r.toneMapping) && (u.material.needsUpdate = !0,
        h = B,
        d = B.version,
        f = r.toneMapping),
        u.layers.enableAll(),
        w.unshift(u, u.geometry, u.material, 0, 0, null)) : B && B.isTexture && (l === void 0 && (l = new ct(new Xs(2,2),new wn({
            name: "BackgroundMaterial",
            uniforms: qi(Gt.background.uniforms),
            vertexShader: Gt.background.vertexShader,
            fragmentShader: Gt.background.fragmentShader,
            side: Hn,
            depthTest: !1,
            depthWrite: !1,
            fog: !1,
            allowOverride: !1
        })),
        l.geometry.deleteAttribute("normal"),
        Object.defineProperty(l.material, "map", {
            get: function() {
                return this.uniforms.t2D.value
            }
        }),
        i.update(l)),
        l.material.uniforms.t2D.value = B,
        l.material.uniforms.backgroundIntensity.value = b.backgroundIntensity,
        l.material.toneMapped = et.getTransfer(B.colorSpace) !== at,
        B.matrixAutoUpdate === !0 && B.updateMatrix(),
        l.material.uniforms.uvTransform.value.copy(B.matrix),
        (h !== B || d !== B.version || f !== r.toneMapping) && (l.material.needsUpdate = !0,
        h = B,
        d = B.version,
        f = r.toneMapping),
        l.layers.enableAll(),
        w.unshift(l, l.geometry, l.material, 0, 0, null))
    }
    function p(w, b) {
        w.getRGB(Mr, Ru(r)),
        n.buffers.color.setClear(Mr.r, Mr.g, Mr.b, b, o)
    }
    function S() {
        u !== void 0 && (u.geometry.dispose(),
        u.material.dispose(),
        u = void 0),
        l !== void 0 && (l.geometry.dispose(),
        l.material.dispose(),
        l = void 0)
    }
    return {
        getClearColor: function() {
            return a
        },
        setClearColor: function(w, b=1) {
            a.set(w),
            c = b,
            p(a, c)
        },
        getClearAlpha: function() {
            return c
        },
        setClearAlpha: function(w) {
            c = w,
            p(a, c)
        },
        render: g,
        addToRenderList: A,
        dispose: S
    }
}
function rg(r, e) {
    const t = r.getParameter(r.MAX_VERTEX_ATTRIBS)
      , n = {}
      , i = d(null);
    let s = i
      , o = !1;
    function a(T, _, re, k, U) {
        let F = !1;
        const O = h(k, re, _);
        s !== O && (s = O,
        l(s.object)),
        F = f(T, k, re, U),
        F && m(T, k, re, U),
        U !== null && e.update(U, r.ELEMENT_ARRAY_BUFFER),
        (F || o) && (o = !1,
        b(T, _, re, k),
        U !== null && r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, e.get(U).buffer))
    }
    function c() {
        return r.createVertexArray()
    }
    function l(T) {
        return r.bindVertexArray(T)
    }
    function u(T) {
        return r.deleteVertexArray(T)
    }
    function h(T, _, re) {
        const k = re.wireframe === !0;
        let U = n[T.id];
        U === void 0 && (U = {},
        n[T.id] = U);
        let F = U[_.id];
        F === void 0 && (F = {},
        U[_.id] = F);
        let O = F[k];
        return O === void 0 && (O = d(c()),
        F[k] = O),
        O
    }
    function d(T) {
        const _ = []
          , re = []
          , k = [];
        for (let U = 0; U < t; U++)
            _[U] = 0,
            re[U] = 0,
            k[U] = 0;
        return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: _,
            enabledAttributes: re,
            attributeDivisors: k,
            object: T,
            attributes: {},
            index: null
        }
    }
    function f(T, _, re, k) {
        const U = s.attributes
          , F = _.attributes;
        let O = 0;
        const y = re.getAttributes();
        for (const v in y)
            if (y[v].location >= 0) {
                const R = U[v];
                let C = F[v];
                if (C === void 0 && (v === "instanceMatrix" && T.instanceMatrix && (C = T.instanceMatrix),
                v === "instanceColor" && T.instanceColor && (C = T.instanceColor)),
                R === void 0 || R.attribute !== C || C && R.data !== C.data)
                    return !0;
                O++
            }
        return s.attributesNum !== O || s.index !== k
    }
    function m(T, _, re, k) {
        const U = {}
          , F = _.attributes;
        let O = 0;
        const y = re.getAttributes();
        for (const v in y)
            if (y[v].location >= 0) {
                let R = F[v];
                R === void 0 && (v === "instanceMatrix" && T.instanceMatrix && (R = T.instanceMatrix),
                v === "instanceColor" && T.instanceColor && (R = T.instanceColor));
                const C = {};
                C.attribute = R,
                R && R.data && (C.data = R.data),
                U[v] = C,
                O++
            }
        s.attributes = U,
        s.attributesNum = O,
        s.index = k
    }
    function g() {
        const T = s.newAttributes;
        for (let _ = 0, re = T.length; _ < re; _++)
            T[_] = 0
    }
    function A(T) {
        p(T, 0)
    }
    function p(T, _) {
        const re = s.newAttributes
          , k = s.enabledAttributes
          , U = s.attributeDivisors;
        re[T] = 1,
        k[T] === 0 && (r.enableVertexAttribArray(T),
        k[T] = 1),
        U[T] !== _ && (r.vertexAttribDivisor(T, _),
        U[T] = _)
    }
    function S() {
        const T = s.newAttributes
          , _ = s.enabledAttributes;
        for (let re = 0, k = _.length; re < k; re++)
            _[re] !== T[re] && (r.disableVertexAttribArray(re),
            _[re] = 0)
    }
    function w(T, _, re, k, U, F, O) {
        O === !0 ? r.vertexAttribIPointer(T, _, re, U, F) : r.vertexAttribPointer(T, _, re, k, U, F)
    }
    function b(T, _, re, k) {
        g();
        const U = k.attributes
          , F = re.getAttributes()
          , O = _.defaultAttributeValues;
        for (const y in F) {
            const v = F[y];
            if (v.location >= 0) {
                let L = U[y];
                if (L === void 0 && (y === "instanceMatrix" && T.instanceMatrix && (L = T.instanceMatrix),
                y === "instanceColor" && T.instanceColor && (L = T.instanceColor)),
                L !== void 0) {
                    const R = L.normalized
                      , C = L.itemSize
                      , Y = e.get(L);
                    if (Y === void 0)
                        continue;
                    const ue = Y.buffer
                      , X = Y.type
                      , ne = Y.bytesPerElement
                      , ae = X === r.INT || X === r.UNSIGNED_INT || L.gpuType === Ya;
                    if (L.isInterleavedBufferAttribute) {
                        const ce = L.data
                          , le = ce.stride
                          , xe = L.offset;
                        if (ce.isInstancedInterleavedBuffer) {
                            for (let ye = 0; ye < v.locationSize; ye++)
                                p(v.location + ye, ce.meshPerAttribute);
                            T.isInstancedMesh !== !0 && k._maxInstanceCount === void 0 && (k._maxInstanceCount = ce.meshPerAttribute * ce.count)
                        } else
                            for (let ye = 0; ye < v.locationSize; ye++)
                                A(v.location + ye);
                        r.bindBuffer(r.ARRAY_BUFFER, ue);
                        for (let ye = 0; ye < v.locationSize; ye++)
                            w(v.location + ye, C / v.locationSize, X, R, le * ne, (xe + C / v.locationSize * ye) * ne, ae)
                    } else {
                        if (L.isInstancedBufferAttribute) {
                            for (let ce = 0; ce < v.locationSize; ce++)
                                p(v.location + ce, L.meshPerAttribute);
                            T.isInstancedMesh !== !0 && k._maxInstanceCount === void 0 && (k._maxInstanceCount = L.meshPerAttribute * L.count)
                        } else
                            for (let ce = 0; ce < v.locationSize; ce++)
                                A(v.location + ce);
                        r.bindBuffer(r.ARRAY_BUFFER, ue);
                        for (let ce = 0; ce < v.locationSize; ce++)
                            w(v.location + ce, C / v.locationSize, X, R, C * ne, C / v.locationSize * ce * ne, ae)
                    }
                } else if (O !== void 0) {
                    const R = O[y];
                    if (R !== void 0)
                        switch (R.length) {
                        case 2:
                            r.vertexAttrib2fv(v.location, R);
                            break;
                        case 3:
                            r.vertexAttrib3fv(v.location, R);
                            break;
                        case 4:
                            r.vertexAttrib4fv(v.location, R);
                            break;
                        default:
                            r.vertexAttrib1fv(v.location, R)
                        }
                }
            }
        }
        S()
    }
    function B() {
        H();
        for (const T in n) {
            const _ = n[T];
            for (const re in _) {
                const k = _[re];
                for (const U in k)
                    u(k[U].object),
                    delete k[U];
                delete _[re]
            }
            delete n[T]
        }
    }
    function z(T) {
        if (n[T.id] === void 0)
            return;
        const _ = n[T.id];
        for (const re in _) {
            const k = _[re];
            for (const U in k)
                u(k[U].object),
                delete k[U];
            delete _[re]
        }
        delete n[T.id]
    }
    function I(T) {
        for (const _ in n) {
            const re = n[_];
            if (re[T.id] === void 0)
                continue;
            const k = re[T.id];
            for (const U in k)
                u(k[U].object),
                delete k[U];
            delete re[T.id]
        }
    }
    function H() {
        P(),
        o = !0,
        s !== i && (s = i,
        l(s.object))
    }
    function P() {
        i.geometry = null,
        i.program = null,
        i.wireframe = !1
    }
    return {
        setup: a,
        reset: H,
        resetDefaultState: P,
        dispose: B,
        releaseStatesOfGeometry: z,
        releaseStatesOfProgram: I,
        initAttributes: g,
        enableAttribute: A,
        disableUnusedAttributes: S
    }
}
function og(r, e, t) {
    let n;
    function i(l) {
        n = l
    }
    function s(l, u) {
        r.drawArrays(n, l, u),
        t.update(u, n, 1)
    }
    function o(l, u, h) {
        h !== 0 && (r.drawArraysInstanced(n, l, u, h),
        t.update(u, n, h))
    }
    function a(l, u, h) {
        if (h === 0)
            return;
        e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(n, l, 0, u, 0, h);
        let f = 0;
        for (let m = 0; m < h; m++)
            f += u[m];
        t.update(f, n, 1)
    }
    function c(l, u, h, d) {
        if (h === 0)
            return;
        const f = e.get("WEBGL_multi_draw");
        if (f === null)
            for (let m = 0; m < l.length; m++)
                o(l[m], u[m], d[m]);
        else {
            f.multiDrawArraysInstancedWEBGL(n, l, 0, u, 0, d, 0, h);
            let m = 0;
            for (let g = 0; g < h; g++)
                m += u[g] * d[g];
            t.update(m, n, 1)
        }
    }
    this.setMode = i,
    this.render = s,
    this.renderInstances = o,
    this.renderMultiDraw = a,
    this.renderMultiDrawInstances = c
}
function ag(r, e, t, n) {
    let i;
    function s() {
        if (i !== void 0)
            return i;
        if (e.has("EXT_texture_filter_anisotropic") === !0) {
            const I = e.get("EXT_texture_filter_anisotropic");
            i = r.getParameter(I.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
        } else
            i = 0;
        return i
    }
    function o(I) {
        return !(I !== tn && n.convert(I) !== r.getParameter(r.IMPLEMENTATION_COLOR_READ_FORMAT))
    }
    function a(I) {
        const H = I === Fs && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
        return !(I !== Mn && n.convert(I) !== r.getParameter(r.IMPLEMENTATION_COLOR_READ_TYPE) && I !== dn && !H)
    }
    function c(I) {
        if (I === "highp") {
            if (r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.HIGH_FLOAT).precision > 0 && r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.HIGH_FLOAT).precision > 0)
                return "highp";
            I = "mediump"
        }
        return I === "mediump" && r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.MEDIUM_FLOAT).precision > 0 && r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
    }
    let l = t.precision !== void 0 ? t.precision : "highp";
    const u = c(l);
    u !== l && (console.warn("THREE.WebGLRenderer:", l, "not supported, using", u, "instead."),
    l = u);
    const h = t.logarithmicDepthBuffer === !0
      , d = t.reverseDepthBuffer === !0 && e.has("EXT_clip_control")
      , f = r.getParameter(r.MAX_TEXTURE_IMAGE_UNITS)
      , m = r.getParameter(r.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
      , g = r.getParameter(r.MAX_TEXTURE_SIZE)
      , A = r.getParameter(r.MAX_CUBE_MAP_TEXTURE_SIZE)
      , p = r.getParameter(r.MAX_VERTEX_ATTRIBS)
      , S = r.getParameter(r.MAX_VERTEX_UNIFORM_VECTORS)
      , w = r.getParameter(r.MAX_VARYING_VECTORS)
      , b = r.getParameter(r.MAX_FRAGMENT_UNIFORM_VECTORS)
      , B = m > 0
      , z = r.getParameter(r.MAX_SAMPLES);
    return {
        isWebGL2: !0,
        getMaxAnisotropy: s,
        getMaxPrecision: c,
        textureFormatReadable: o,
        textureTypeReadable: a,
        precision: l,
        logarithmicDepthBuffer: h,
        reverseDepthBuffer: d,
        maxTextures: f,
        maxVertexTextures: m,
        maxTextureSize: g,
        maxCubemapSize: A,
        maxAttributes: p,
        maxVertexUniforms: S,
        maxVaryings: w,
        maxFragmentUniforms: b,
        vertexTextures: B,
        maxSamples: z
    }
}
function cg(r) {
    const e = this;
    let t = null
      , n = 0
      , i = !1
      , s = !1;
    const o = new xn
      , a = new qe
      , c = {
        value: null,
        needsUpdate: !1
    };
    this.uniform = c,
    this.numPlanes = 0,
    this.numIntersection = 0,
    this.init = function(h, d) {
        const f = h.length !== 0 || d || n !== 0 || i;
        return i = d,
        n = h.length,
        f
    }
    ,
    this.beginShadows = function() {
        s = !0,
        u(null)
    }
    ,
    this.endShadows = function() {
        s = !1
    }
    ,
    this.setGlobalState = function(h, d) {
        t = u(h, d, 0)
    }
    ,
    this.setState = function(h, d, f) {
        const m = h.clippingPlanes
          , g = h.clipIntersection
          , A = h.clipShadows
          , p = r.get(h);
        if (!i || m === null || m.length === 0 || s && !A)
            s ? u(null) : l();
        else {
            const S = s ? 0 : n
              , w = S * 4;
            let b = p.clippingState || null;
            c.value = b,
            b = u(m, d, w, f);
            for (let B = 0; B !== w; ++B)
                b[B] = t[B];
            p.clippingState = b,
            this.numIntersection = g ? this.numPlanes : 0,
            this.numPlanes += S
        }
    }
    ;
    function l() {
        c.value !== t && (c.value = t,
        c.needsUpdate = n > 0),
        e.numPlanes = n,
        e.numIntersection = 0
    }
    function u(h, d, f, m) {
        const g = h !== null ? h.length : 0;
        let A = null;
        if (g !== 0) {
            if (A = c.value,
            m !== !0 || A === null) {
                const p = f + g * 4
                  , S = d.matrixWorldInverse;
                a.getNormalMatrix(S),
                (A === null || A.length < p) && (A = new Float32Array(p));
                for (let w = 0, b = f; w !== g; ++w,
                b += 4)
                    o.copy(h[w]).applyMatrix4(S, a),
                    o.normal.toArray(A, b),
                    A[b + 3] = o.constant
            }
            c.value = A,
            c.needsUpdate = !0
        }
        return e.numPlanes = g,
        e.numIntersection = 0,
        A
    }
}
function lg(r) {
    let e = new WeakMap;
    function t(o, a) {
        return a === ea ? o.mapping = Wi : a === ta && (o.mapping = ji),
        o
    }
    function n(o) {
        if (o && o.isTexture) {
            const a = o.mapping;
            if (a === ea || a === ta)
                if (e.has(o)) {
                    const c = e.get(o).texture;
                    return t(c, o.mapping)
                } else {
                    const c = o.image;
                    if (c && c.height > 0) {
                        const l = new qd(c.height);
                        return l.fromEquirectangularTexture(r, o),
                        e.set(o, l),
                        o.addEventListener("dispose", i),
                        t(l.texture, o.mapping)
                    } else
                        return null
                }
        }
        return o
    }
    function i(o) {
        const a = o.target;
        a.removeEventListener("dispose", i);
        const c = e.get(a);
        c !== void 0 && (e.delete(a),
        c.dispose())
    }
    function s() {
        e = new WeakMap
    }
    return {
        get: n,
        dispose: s
    }
}
const Ui = 4
  , Pl = [.125, .215, .35, .446, .526, .582]
  , pi = 20
  , No = new Yr
  , Ll = new Ge;
let Oo = null
  , zo = 0
  , Io = 0
  , Uo = !1;
const hi = (1 + Math.sqrt(5)) / 2
  , Ii = 1 / hi
  , Cl = [new D(-hi,Ii,0), new D(hi,Ii,0), new D(-Ii,0,hi), new D(Ii,0,hi), new D(0,hi,-Ii), new D(0,hi,Ii), new D(-1,1,-1), new D(1,1,-1), new D(-1,1,1), new D(1,1,1)]
  , ug = new D;
class Rl {
    constructor(e) {
        this._renderer = e,
        this._pingPongRenderTarget = null,
        this._lodMax = 0,
        this._cubeSize = 0,
        this._lodPlanes = [],
        this._sizeLods = [],
        this._sigmas = [],
        this._blurMaterial = null,
        this._cubemapMaterial = null,
        this._equirectMaterial = null,
        this._compileMaterial(this._blurMaterial)
    }
    fromScene(e, t=0, n=.1, i=100, s={}) {
        const {size: o=256, position: a=ug} = s;
        Oo = this._renderer.getRenderTarget(),
        zo = this._renderer.getActiveCubeFace(),
        Io = this._renderer.getActiveMipmapLevel(),
        Uo = this._renderer.xr.enabled,
        this._renderer.xr.enabled = !1,
        this._setSize(o);
        const c = this._allocateTargets();
        return c.depthBuffer = !0,
        this._sceneToCubeUV(e, n, i, c, a),
        t > 0 && this._blur(c, 0, 0, t),
        this._applyPMREM(c),
        this._cleanup(c),
        c
    }
    fromEquirectangular(e, t=null) {
        return this._fromTexture(e, t)
    }
    fromCubemap(e, t=null) {
        return this._fromTexture(e, t)
    }
    compileCubemapShader() {
        this._cubemapMaterial === null && (this._cubemapMaterial = Ol(),
        this._compileMaterial(this._cubemapMaterial))
    }
    compileEquirectangularShader() {
        this._equirectMaterial === null && (this._equirectMaterial = Nl(),
        this._compileMaterial(this._equirectMaterial))
    }
    dispose() {
        this._dispose(),
        this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
        this._equirectMaterial !== null && this._equirectMaterial.dispose()
    }
    _setSize(e) {
        this._lodMax = Math.floor(Math.log2(e)),
        this._cubeSize = Math.pow(2, this._lodMax)
    }
    _dispose() {
        this._blurMaterial !== null && this._blurMaterial.dispose(),
        this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
        for (let e = 0; e < this._lodPlanes.length; e++)
            this._lodPlanes[e].dispose()
    }
    _cleanup(e) {
        this._renderer.setRenderTarget(Oo, zo, Io),
        this._renderer.xr.enabled = Uo,
        e.scissorTest = !1,
        wr(e, 0, 0, e.width, e.height)
    }
    _fromTexture(e, t) {
        e.mapping === Wi || e.mapping === ji ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4),
        Oo = this._renderer.getRenderTarget(),
        zo = this._renderer.getActiveCubeFace(),
        Io = this._renderer.getActiveMipmapLevel(),
        Uo = this._renderer.xr.enabled,
        this._renderer.xr.enabled = !1;
        const n = t || this._allocateTargets();
        return this._textureToCubeUV(e, n),
        this._applyPMREM(n),
        this._cleanup(n),
        n
    }
    _allocateTargets() {
        const e = 3 * Math.max(this._cubeSize, 112)
          , t = 4 * this._cubeSize
          , n = {
            magFilter: Yt,
            minFilter: Yt,
            generateMipmaps: !1,
            type: Fs,
            format: tn,
            colorSpace: Ht,
            depthBuffer: !1
        }
          , i = Dl(e, t, n);
        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
            this._pingPongRenderTarget !== null && this._dispose(),
            this._pingPongRenderTarget = Dl(e, t, n);
            const {_lodMax: s} = this;
            ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = hg(s)),
            this._blurMaterial = dg(s, e, t)
        }
        return i
    }
    _compileMaterial(e) {
        const t = new ct(this._lodPlanes[0],e);
        this._renderer.compile(t, No)
    }
    _sceneToCubeUV(e, t, n, i, s) {
        const c = new Bt(90,1,t,n)
          , l = [1, -1, 1, 1, 1, 1]
          , u = [1, 1, 1, -1, -1, -1]
          , h = this._renderer
          , d = h.autoClear
          , f = h.toneMapping;
        h.getClearColor(Ll),
        h.toneMapping = ti,
        h.autoClear = !1;
        const m = new Qn({
            name: "PMREM.Background",
            side: Vt,
            depthWrite: !1,
            depthTest: !1
        })
          , g = new ct(new Hs,m);
        let A = !1;
        const p = e.background;
        p ? p.isColor && (m.color.copy(p),
        e.background = null,
        A = !0) : (m.color.copy(Ll),
        A = !0);
        for (let S = 0; S < 6; S++) {
            const w = S % 3;
            w === 0 ? (c.up.set(0, l[S], 0),
            c.position.set(s.x, s.y, s.z),
            c.lookAt(s.x + u[S], s.y, s.z)) : w === 1 ? (c.up.set(0, 0, l[S]),
            c.position.set(s.x, s.y, s.z),
            c.lookAt(s.x, s.y + u[S], s.z)) : (c.up.set(0, l[S], 0),
            c.position.set(s.x, s.y, s.z),
            c.lookAt(s.x, s.y, s.z + u[S]));
            const b = this._cubeSize;
            wr(i, w * b, S > 2 ? b : 0, b, b),
            h.setRenderTarget(i),
            A && h.render(g, c),
            h.render(e, c)
        }
        g.geometry.dispose(),
        g.material.dispose(),
        h.toneMapping = f,
        h.autoClear = d,
        e.background = p
    }
    _textureToCubeUV(e, t) {
        const n = this._renderer
          , i = e.mapping === Wi || e.mapping === ji;
        i ? (this._cubemapMaterial === null && (this._cubemapMaterial = Ol()),
        this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = Nl());
        const s = i ? this._cubemapMaterial : this._equirectMaterial
          , o = new ct(this._lodPlanes[0],s)
          , a = s.uniforms;
        a.envMap.value = e;
        const c = this._cubeSize;
        wr(t, 0, 0, 3 * c, 2 * c),
        n.setRenderTarget(t),
        n.render(o, No)
    }
    _applyPMREM(e) {
        const t = this._renderer
          , n = t.autoClear;
        t.autoClear = !1;
        const i = this._lodPlanes.length;
        for (let s = 1; s < i; s++) {
            const o = Math.sqrt(this._sigmas[s] * this._sigmas[s] - this._sigmas[s - 1] * this._sigmas[s - 1])
              , a = Cl[(i - s - 1) % Cl.length];
            this._blur(e, s - 1, s, o, a)
        }
        t.autoClear = n
    }
    _blur(e, t, n, i, s) {
        const o = this._pingPongRenderTarget;
        this._halfBlur(e, o, t, n, i, "latitudinal", s),
        this._halfBlur(o, e, n, n, i, "longitudinal", s)
    }
    _halfBlur(e, t, n, i, s, o, a) {
        const c = this._renderer
          , l = this._blurMaterial;
        o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
        const u = 3
          , h = new ct(this._lodPlanes[i],l)
          , d = l.uniforms
          , f = this._sizeLods[n] - 1
          , m = isFinite(s) ? Math.PI / (2 * f) : 2 * Math.PI / (2 * pi - 1)
          , g = s / m
          , A = isFinite(s) ? 1 + Math.floor(u * g) : pi;
        A > pi && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${A} samples when the maximum is set to ${pi}`);
        const p = [];
        let S = 0;
        for (let I = 0; I < pi; ++I) {
            const H = I / g
              , P = Math.exp(-H * H / 2);
            p.push(P),
            I === 0 ? S += P : I < A && (S += 2 * P)
        }
        for (let I = 0; I < p.length; I++)
            p[I] = p[I] / S;
        d.envMap.value = e.texture,
        d.samples.value = A,
        d.weights.value = p,
        d.latitudinal.value = o === "latitudinal",
        a && (d.poleAxis.value = a);
        const {_lodMax: w} = this;
        d.dTheta.value = m,
        d.mipInt.value = w - n;
        const b = this._sizeLods[i]
          , B = 3 * b * (i > w - Ui ? i - w + Ui : 0)
          , z = 4 * (this._cubeSize - b);
        wr(t, B, z, 3 * b, 2 * b),
        c.setRenderTarget(t),
        c.render(h, No)
    }
}
function hg(r) {
    const e = []
      , t = []
      , n = [];
    let i = r;
    const s = r - Ui + 1 + Pl.length;
    for (let o = 0; o < s; o++) {
        const a = Math.pow(2, i);
        t.push(a);
        let c = 1 / a;
        o > r - Ui ? c = Pl[o - r + Ui - 1] : o === 0 && (c = 0),
        n.push(c);
        const l = 1 / (a - 2)
          , u = -l
          , h = 1 + l
          , d = [u, u, h, u, h, h, u, u, h, h, u, h]
          , f = 6
          , m = 6
          , g = 3
          , A = 2
          , p = 1
          , S = new Float32Array(g * m * f)
          , w = new Float32Array(A * m * f)
          , b = new Float32Array(p * m * f);
        for (let z = 0; z < f; z++) {
            const I = z % 3 * 2 / 3 - 1
              , H = z > 2 ? 0 : -1
              , P = [I, H, 0, I + 2 / 3, H, 0, I + 2 / 3, H + 1, 0, I, H, 0, I + 2 / 3, H + 1, 0, I, H + 1, 0];
            S.set(P, g * m * z),
            w.set(d, A * m * z);
            const T = [z, z, z, z, z, z];
            b.set(T, p * m * z)
        }
        const B = new At;
        B.setAttribute("position", new vt(S,g)),
        B.setAttribute("uv", new vt(w,A)),
        B.setAttribute("faceIndex", new vt(b,p)),
        e.push(B),
        i > Ui && i--
    }
    return {
        lodPlanes: e,
        sizeLods: t,
        sigmas: n
    }
}
function Dl(r, e, t) {
    const n = new gi(r,e,t);
    return n.texture.mapping = Wr,
    n.texture.name = "PMREM.cubeUv",
    n.scissorTest = !0,
    n
}
function wr(r, e, t, n, i) {
    r.viewport.set(e, t, n, i),
    r.scissor.set(e, t, n, i)
}
function dg(r, e, t) {
    const n = new Float32Array(pi)
      , i = new D(0,1,0);
    return new wn({
        name: "SphericalGaussianBlur",
        defines: {
            n: pi,
            CUBEUV_TEXEL_WIDTH: 1 / e,
            CUBEUV_TEXEL_HEIGHT: 1 / t,
            CUBEUV_MAX_MIP: `${r}.0`
        },
        uniforms: {
            envMap: {
                value: null
            },
            samples: {
                value: 1
            },
            weights: {
                value: n
            },
            latitudinal: {
                value: !1
            },
            dTheta: {
                value: 0
            },
            mipInt: {
                value: 0
            },
            poleAxis: {
                value: i
            }
        },
        vertexShader: mc(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
        blending: ei,
        depthTest: !1,
        depthWrite: !1
    })
}
function Nl() {
    return new wn({
        name: "EquirectangularToCubeUV",
        uniforms: {
            envMap: {
                value: null
            }
        },
        vertexShader: mc(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
        blending: ei,
        depthTest: !1,
        depthWrite: !1
    })
}
function Ol() {
    return new wn({
        name: "CubemapToCubeUV",
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            }
        },
        vertexShader: mc(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
        blending: ei,
        depthTest: !1,
        depthWrite: !1
    })
}
function mc() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
}
function fg(r) {
    let e = new WeakMap
      , t = null;
    function n(a) {
        if (a && a.isTexture) {
            const c = a.mapping
              , l = c === ea || c === ta
              , u = c === Wi || c === ji;
            if (l || u) {
                let h = e.get(a);
                const d = h !== void 0 ? h.texture.pmremVersion : 0;
                if (a.isRenderTargetTexture && a.pmremVersion !== d)
                    return t === null && (t = new Rl(r)),
                    h = l ? t.fromEquirectangular(a, h) : t.fromCubemap(a, h),
                    h.texture.pmremVersion = a.pmremVersion,
                    e.set(a, h),
                    h.texture;
                if (h !== void 0)
                    return h.texture;
                {
                    const f = a.image;
                    return l && f && f.height > 0 || u && f && i(f) ? (t === null && (t = new Rl(r)),
                    h = l ? t.fromEquirectangular(a) : t.fromCubemap(a),
                    h.texture.pmremVersion = a.pmremVersion,
                    e.set(a, h),
                    a.addEventListener("dispose", s),
                    h.texture) : null
                }
            }
        }
        return a
    }
    function i(a) {
        let c = 0;
        const l = 6;
        for (let u = 0; u < l; u++)
            a[u] !== void 0 && c++;
        return c === l
    }
    function s(a) {
        const c = a.target;
        c.removeEventListener("dispose", s);
        const l = e.get(c);
        l !== void 0 && (e.delete(c),
        l.dispose())
    }
    function o() {
        e = new WeakMap,
        t !== null && (t.dispose(),
        t = null)
    }
    return {
        get: n,
        dispose: o
    }
}
function pg(r) {
    const e = {};
    function t(n) {
        if (e[n] !== void 0)
            return e[n];
        let i;
        switch (n) {
        case "WEBGL_depth_texture":
            i = r.getExtension("WEBGL_depth_texture") || r.getExtension("MOZ_WEBGL_depth_texture") || r.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
        case "EXT_texture_filter_anisotropic":
            i = r.getExtension("EXT_texture_filter_anisotropic") || r.getExtension("MOZ_EXT_texture_filter_anisotropic") || r.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
        case "WEBGL_compressed_texture_s3tc":
            i = r.getExtension("WEBGL_compressed_texture_s3tc") || r.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
        case "WEBGL_compressed_texture_pvrtc":
            i = r.getExtension("WEBGL_compressed_texture_pvrtc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
        default:
            i = r.getExtension(n)
        }
        return e[n] = i,
        i
    }
    return {
        has: function(n) {
            return t(n) !== null
        },
        init: function() {
            t("EXT_color_buffer_float"),
            t("WEBGL_clip_cull_distance"),
            t("OES_texture_float_linear"),
            t("EXT_color_buffer_half_float"),
            t("WEBGL_multisampled_render_to_texture"),
            t("WEBGL_render_shared_exponent")
        },
        get: function(n) {
            const i = t(n);
            return i === null && _i("THREE.WebGLRenderer: " + n + " extension not supported."),
            i
        }
    }
}
function mg(r, e, t, n) {
    const i = {}
      , s = new WeakMap;
    function o(h) {
        const d = h.target;
        d.index !== null && e.remove(d.index);
        for (const m in d.attributes)
            e.remove(d.attributes[m]);
        d.removeEventListener("dispose", o),
        delete i[d.id];
        const f = s.get(d);
        f && (e.remove(f),
        s.delete(d)),
        n.releaseStatesOfGeometry(d),
        d.isInstancedBufferGeometry === !0 && delete d._maxInstanceCount,
        t.memory.geometries--
    }
    function a(h, d) {
        return i[d.id] === !0 || (d.addEventListener("dispose", o),
        i[d.id] = !0,
        t.memory.geometries++),
        d
    }
    function c(h) {
        const d = h.attributes;
        for (const f in d)
            e.update(d[f], r.ARRAY_BUFFER)
    }
    function l(h) {
        const d = []
          , f = h.index
          , m = h.attributes.position;
        let g = 0;
        if (f !== null) {
            const S = f.array;
            g = f.version;
            for (let w = 0, b = S.length; w < b; w += 3) {
                const B = S[w + 0]
                  , z = S[w + 1]
                  , I = S[w + 2];
                d.push(B, z, z, I, I, B)
            }
        } else if (m !== void 0) {
            const S = m.array;
            g = m.version;
            for (let w = 0, b = S.length / 3 - 1; w < b; w += 3) {
                const B = w + 0
                  , z = w + 1
                  , I = w + 2;
                d.push(B, z, z, I, I, B)
            }
        } else
            return;
        const A = new (Tu(d) ? Cu : Lu)(d,1);
        A.version = g;
        const p = s.get(h);
        p && e.remove(p),
        s.set(h, A)
    }
    function u(h) {
        const d = s.get(h);
        if (d) {
            const f = h.index;
            f !== null && d.version < f.version && l(h)
        } else
            l(h);
        return s.get(h)
    }
    return {
        get: a,
        update: c,
        getWireframeAttribute: u
    }
}
function Ag(r, e, t) {
    let n;
    function i(d) {
        n = d
    }
    let s, o;
    function a(d) {
        s = d.type,
        o = d.bytesPerElement
    }
    function c(d, f) {
        r.drawElements(n, f, s, d * o),
        t.update(f, n, 1)
    }
    function l(d, f, m) {
        m !== 0 && (r.drawElementsInstanced(n, f, s, d * o, m),
        t.update(f, n, m))
    }
    function u(d, f, m) {
        if (m === 0)
            return;
        e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(n, f, 0, s, d, 0, m);
        let A = 0;
        for (let p = 0; p < m; p++)
            A += f[p];
        t.update(A, n, 1)
    }
    function h(d, f, m, g) {
        if (m === 0)
            return;
        const A = e.get("WEBGL_multi_draw");
        if (A === null)
            for (let p = 0; p < d.length; p++)
                l(d[p] / o, f[p], g[p]);
        else {
            A.multiDrawElementsInstancedWEBGL(n, f, 0, s, d, 0, g, 0, m);
            let p = 0;
            for (let S = 0; S < m; S++)
                p += f[S] * g[S];
            t.update(p, n, 1)
        }
    }
    this.setMode = i,
    this.setIndex = a,
    this.render = c,
    this.renderInstances = l,
    this.renderMultiDraw = u,
    this.renderMultiDrawInstances = h
}
function gg(r) {
    const e = {
        geometries: 0,
        textures: 0
    }
      , t = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
    };
    function n(s, o, a) {
        switch (t.calls++,
        o) {
        case r.TRIANGLES:
            t.triangles += a * (s / 3);
            break;
        case r.LINES:
            t.lines += a * (s / 2);
            break;
        case r.LINE_STRIP:
            t.lines += a * (s - 1);
            break;
        case r.LINE_LOOP:
            t.lines += a * s;
            break;
        case r.POINTS:
            t.points += a * s;
            break;
        default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", o);
            break
        }
    }
    function i() {
        t.calls = 0,
        t.triangles = 0,
        t.points = 0,
        t.lines = 0
    }
    return {
        memory: e,
        render: t,
        programs: null,
        autoReset: !0,
        reset: i,
        update: n
    }
}
function vg(r, e, t) {
    const n = new WeakMap
      , i = new Je;
    function s(o, a, c) {
        const l = o.morphTargetInfluences
          , u = a.morphAttributes.position || a.morphAttributes.normal || a.morphAttributes.color
          , h = u !== void 0 ? u.length : 0;
        let d = n.get(a);
        if (d === void 0 || d.count !== h) {
            let P = function() {
                I.dispose(),
                n.delete(a),
                a.removeEventListener("dispose", P)
            };
            d !== void 0 && d.texture.dispose();
            const f = a.morphAttributes.position !== void 0
              , m = a.morphAttributes.normal !== void 0
              , g = a.morphAttributes.color !== void 0
              , A = a.morphAttributes.position || []
              , p = a.morphAttributes.normal || []
              , S = a.morphAttributes.color || [];
            let w = 0;
            f === !0 && (w = 1),
            m === !0 && (w = 2),
            g === !0 && (w = 3);
            let b = a.attributes.position.count * w
              , B = 1;
            b > e.maxTextureSize && (B = Math.ceil(b / e.maxTextureSize),
            b = e.maxTextureSize);
            const z = new Float32Array(b * B * 4 * h)
              , I = new Eu(z,b,B,h);
            I.type = dn,
            I.needsUpdate = !0;
            const H = w * 4;
            for (let T = 0; T < h; T++) {
                const _ = A[T]
                  , re = p[T]
                  , k = S[T]
                  , U = b * B * 4 * T;
                for (let F = 0; F < _.count; F++) {
                    const O = F * H;
                    f === !0 && (i.fromBufferAttribute(_, F),
                    z[U + O + 0] = i.x,
                    z[U + O + 1] = i.y,
                    z[U + O + 2] = i.z,
                    z[U + O + 3] = 0),
                    m === !0 && (i.fromBufferAttribute(re, F),
                    z[U + O + 4] = i.x,
                    z[U + O + 5] = i.y,
                    z[U + O + 6] = i.z,
                    z[U + O + 7] = 0),
                    g === !0 && (i.fromBufferAttribute(k, F),
                    z[U + O + 8] = i.x,
                    z[U + O + 9] = i.y,
                    z[U + O + 10] = i.z,
                    z[U + O + 11] = k.itemSize === 4 ? i.w : 1)
                }
            }
            d = {
                count: h,
                texture: I,
                size: new Ae(b,B)
            },
            n.set(a, d),
            a.addEventListener("dispose", P)
        }
        if (o.isInstancedMesh === !0 && o.morphTexture !== null)
            c.getUniforms().setValue(r, "morphTexture", o.morphTexture, t);
        else {
            let f = 0;
            for (let g = 0; g < l.length; g++)
                f += l[g];
            const m = a.morphTargetsRelative ? 1 : 1 - f;
            c.getUniforms().setValue(r, "morphTargetBaseInfluence", m),
            c.getUniforms().setValue(r, "morphTargetInfluences", l)
        }
        c.getUniforms().setValue(r, "morphTargetsTexture", d.texture, t),
        c.getUniforms().setValue(r, "morphTargetsTextureSize", d.size)
    }
    return {
        update: s
    }
}
function xg(r, e, t, n) {
    let i = new WeakMap;
    function s(c) {
        const l = n.render.frame
          , u = c.geometry
          , h = e.get(c, u);
        if (i.get(h) !== l && (e.update(h),
        i.set(h, l)),
        c.isInstancedMesh && (c.hasEventListener("dispose", a) === !1 && c.addEventListener("dispose", a),
        i.get(c) !== l && (t.update(c.instanceMatrix, r.ARRAY_BUFFER),
        c.instanceColor !== null && t.update(c.instanceColor, r.ARRAY_BUFFER),
        i.set(c, l))),
        c.isSkinnedMesh) {
            const d = c.skeleton;
            i.get(d) !== l && (d.update(),
            i.set(d, l))
        }
        return h
    }
    function o() {
        i = new WeakMap
    }
    function a(c) {
        const l = c.target;
        l.removeEventListener("dispose", a),
        t.remove(l.instanceMatrix),
        l.instanceColor !== null && t.remove(l.instanceColor)
    }
    return {
        update: s,
        dispose: o
    }
}
const $u = new Tt
  , zl = new _u(1,1)
  , eh = new Eu
  , th = new Nd
  , nh = new Nu
  , Il = []
  , Ul = []
  , Bl = new Float32Array(16)
  , Fl = new Float32Array(9)
  , _l = new Float32Array(4);
function is(r, e, t) {
    const n = r[0];
    if (n <= 0 || n > 0)
        return r;
    const i = e * t;
    let s = Il[i];
    if (s === void 0 && (s = new Float32Array(i),
    Il[i] = s),
    e !== 0) {
        n.toArray(s, 0);
        for (let o = 1, a = 0; o !== e; ++o)
            a += t,
            r[o].toArray(s, a)
    }
    return s
}
function bt(r, e) {
    if (r.length !== e.length)
        return !1;
    for (let t = 0, n = r.length; t < n; t++)
        if (r[t] !== e[t])
            return !1;
    return !0
}
function Mt(r, e) {
    for (let t = 0, n = e.length; t < n; t++)
        r[t] = e[t]
}
function qr(r, e) {
    let t = Ul[e];
    t === void 0 && (t = new Int32Array(e),
    Ul[e] = t);
    for (let n = 0; n !== e; ++n)
        t[n] = r.allocateTextureUnit();
    return t
}
function yg(r, e) {
    const t = this.cache;
    t[0] !== e && (r.uniform1f(this.addr, e),
    t[0] = e)
}
function bg(r, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (r.uniform2f(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (bt(t, e))
            return;
        r.uniform2fv(this.addr, e),
        Mt(t, e)
    }
}
function Mg(r, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (r.uniform3f(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else if (e.r !== void 0)
        (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (r.uniform3f(this.addr, e.r, e.g, e.b),
        t[0] = e.r,
        t[1] = e.g,
        t[2] = e.b);
    else {
        if (bt(t, e))
            return;
        r.uniform3fv(this.addr, e),
        Mt(t, e)
    }
}
function wg(r, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (r.uniform4f(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (bt(t, e))
            return;
        r.uniform4fv(this.addr, e),
        Mt(t, e)
    }
}
function Sg(r, e) {
    const t = this.cache
      , n = e.elements;
    if (n === void 0) {
        if (bt(t, e))
            return;
        r.uniformMatrix2fv(this.addr, !1, e),
        Mt(t, e)
    } else {
        if (bt(t, n))
            return;
        _l.set(n),
        r.uniformMatrix2fv(this.addr, !1, _l),
        Mt(t, n)
    }
}
function Tg(r, e) {
    const t = this.cache
      , n = e.elements;
    if (n === void 0) {
        if (bt(t, e))
            return;
        r.uniformMatrix3fv(this.addr, !1, e),
        Mt(t, e)
    } else {
        if (bt(t, n))
            return;
        Fl.set(n),
        r.uniformMatrix3fv(this.addr, !1, Fl),
        Mt(t, n)
    }
}
function Eg(r, e) {
    const t = this.cache
      , n = e.elements;
    if (n === void 0) {
        if (bt(t, e))
            return;
        r.uniformMatrix4fv(this.addr, !1, e),
        Mt(t, e)
    } else {
        if (bt(t, n))
            return;
        Bl.set(n),
        r.uniformMatrix4fv(this.addr, !1, Bl),
        Mt(t, n)
    }
}
function Pg(r, e) {
    const t = this.cache;
    t[0] !== e && (r.uniform1i(this.addr, e),
    t[0] = e)
}
function Lg(r, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (r.uniform2i(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (bt(t, e))
            return;
        r.uniform2iv(this.addr, e),
        Mt(t, e)
    }
}
function Cg(r, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (r.uniform3i(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else {
        if (bt(t, e))
            return;
        r.uniform3iv(this.addr, e),
        Mt(t, e)
    }
}
function Rg(r, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (r.uniform4i(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (bt(t, e))
            return;
        r.uniform4iv(this.addr, e),
        Mt(t, e)
    }
}
function Dg(r, e) {
    const t = this.cache;
    t[0] !== e && (r.uniform1ui(this.addr, e),
    t[0] = e)
}
function Ng(r, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (r.uniform2ui(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (bt(t, e))
            return;
        r.uniform2uiv(this.addr, e),
        Mt(t, e)
    }
}
function Og(r, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (r.uniform3ui(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else {
        if (bt(t, e))
            return;
        r.uniform3uiv(this.addr, e),
        Mt(t, e)
    }
}
function zg(r, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (r.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (bt(t, e))
            return;
        r.uniform4uiv(this.addr, e),
        Mt(t, e)
    }
}
function Ig(r, e, t) {
    const n = this.cache
      , i = t.allocateTextureUnit();
    n[0] !== i && (r.uniform1i(this.addr, i),
    n[0] = i);
    let s;
    this.type === r.SAMPLER_2D_SHADOW ? (zl.compareFunction = Su,
    s = zl) : s = $u,
    t.setTexture2D(e || s, i)
}
function Ug(r, e, t) {
    const n = this.cache
      , i = t.allocateTextureUnit();
    n[0] !== i && (r.uniform1i(this.addr, i),
    n[0] = i),
    t.setTexture3D(e || th, i)
}
function Bg(r, e, t) {
    const n = this.cache
      , i = t.allocateTextureUnit();
    n[0] !== i && (r.uniform1i(this.addr, i),
    n[0] = i),
    t.setTextureCube(e || nh, i)
}
function Fg(r, e, t) {
    const n = this.cache
      , i = t.allocateTextureUnit();
    n[0] !== i && (r.uniform1i(this.addr, i),
    n[0] = i),
    t.setTexture2DArray(e || eh, i)
}
function _g(r) {
    switch (r) {
    case 5126:
        return yg;
    case 35664:
        return bg;
    case 35665:
        return Mg;
    case 35666:
        return wg;
    case 35674:
        return Sg;
    case 35675:
        return Tg;
    case 35676:
        return Eg;
    case 5124:
    case 35670:
        return Pg;
    case 35667:
    case 35671:
        return Lg;
    case 35668:
    case 35672:
        return Cg;
    case 35669:
    case 35673:
        return Rg;
    case 5125:
        return Dg;
    case 36294:
        return Ng;
    case 36295:
        return Og;
    case 36296:
        return zg;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return Ig;
    case 35679:
    case 36299:
    case 36307:
        return Ug;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return Bg;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return Fg
    }
}
function Hg(r, e) {
    r.uniform1fv(this.addr, e)
}
function Xg(r, e) {
    const t = is(e, this.size, 2);
    r.uniform2fv(this.addr, t)
}
function Gg(r, e) {
    const t = is(e, this.size, 3);
    r.uniform3fv(this.addr, t)
}
function Vg(r, e) {
    const t = is(e, this.size, 4);
    r.uniform4fv(this.addr, t)
}
function Wg(r, e) {
    const t = is(e, this.size, 4);
    r.uniformMatrix2fv(this.addr, !1, t)
}
function jg(r, e) {
    const t = is(e, this.size, 9);
    r.uniformMatrix3fv(this.addr, !1, t)
}
function kg(r, e) {
    const t = is(e, this.size, 16);
    r.uniformMatrix4fv(this.addr, !1, t)
}
function Yg(r, e) {
    r.uniform1iv(this.addr, e)
}
function qg(r, e) {
    r.uniform2iv(this.addr, e)
}
function Zg(r, e) {
    r.uniform3iv(this.addr, e)
}
function Kg(r, e) {
    r.uniform4iv(this.addr, e)
}
function Qg(r, e) {
    r.uniform1uiv(this.addr, e)
}
function Jg(r, e) {
    r.uniform2uiv(this.addr, e)
}
function $g(r, e) {
    r.uniform3uiv(this.addr, e)
}
function ev(r, e) {
    r.uniform4uiv(this.addr, e)
}
function tv(r, e, t) {
    const n = this.cache
      , i = e.length
      , s = qr(t, i);
    bt(n, s) || (r.uniform1iv(this.addr, s),
    Mt(n, s));
    for (let o = 0; o !== i; ++o)
        t.setTexture2D(e[o] || $u, s[o])
}
function nv(r, e, t) {
    const n = this.cache
      , i = e.length
      , s = qr(t, i);
    bt(n, s) || (r.uniform1iv(this.addr, s),
    Mt(n, s));
    for (let o = 0; o !== i; ++o)
        t.setTexture3D(e[o] || th, s[o])
}
function iv(r, e, t) {
    const n = this.cache
      , i = e.length
      , s = qr(t, i);
    bt(n, s) || (r.uniform1iv(this.addr, s),
    Mt(n, s));
    for (let o = 0; o !== i; ++o)
        t.setTextureCube(e[o] || nh, s[o])
}
function sv(r, e, t) {
    const n = this.cache
      , i = e.length
      , s = qr(t, i);
    bt(n, s) || (r.uniform1iv(this.addr, s),
    Mt(n, s));
    for (let o = 0; o !== i; ++o)
        t.setTexture2DArray(e[o] || eh, s[o])
}
function rv(r) {
    switch (r) {
    case 5126:
        return Hg;
    case 35664:
        return Xg;
    case 35665:
        return Gg;
    case 35666:
        return Vg;
    case 35674:
        return Wg;
    case 35675:
        return jg;
    case 35676:
        return kg;
    case 5124:
    case 35670:
        return Yg;
    case 35667:
    case 35671:
        return qg;
    case 35668:
    case 35672:
        return Zg;
    case 35669:
    case 35673:
        return Kg;
    case 5125:
        return Qg;
    case 36294:
        return Jg;
    case 36295:
        return $g;
    case 36296:
        return ev;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return tv;
    case 35679:
    case 36299:
    case 36307:
        return nv;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return iv;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return sv
    }
}
class ov {
    constructor(e, t, n) {
        this.id = e,
        this.addr = n,
        this.cache = [],
        this.type = t.type,
        this.setValue = _g(t.type)
    }
}
class av {
    constructor(e, t, n) {
        this.id = e,
        this.addr = n,
        this.cache = [],
        this.type = t.type,
        this.size = t.size,
        this.setValue = rv(t.type)
    }
}
class cv {
    constructor(e) {
        this.id = e,
        this.seq = [],
        this.map = {}
    }
    setValue(e, t, n) {
        const i = this.seq;
        for (let s = 0, o = i.length; s !== o; ++s) {
            const a = i[s];
            a.setValue(e, t[a.id], n)
        }
    }
}
const Bo = /(\w+)(\])?(\[|\.)?/g;
function Hl(r, e) {
    r.seq.push(e),
    r.map[e.id] = e
}
function lv(r, e, t) {
    const n = r.name
      , i = n.length;
    for (Bo.lastIndex = 0; ; ) {
        const s = Bo.exec(n)
          , o = Bo.lastIndex;
        let a = s[1];
        const c = s[2] === "]"
          , l = s[3];
        if (c && (a = a | 0),
        l === void 0 || l === "[" && o + 2 === i) {
            Hl(t, l === void 0 ? new ov(a,r,e) : new av(a,r,e));
            break
        } else {
            let h = t.map[a];
            h === void 0 && (h = new cv(a),
            Hl(t, h)),
            t = h
        }
    }
}
class Ir {
    constructor(e, t) {
        this.seq = [],
        this.map = {};
        const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
        for (let i = 0; i < n; ++i) {
            const s = e.getActiveUniform(t, i)
              , o = e.getUniformLocation(t, s.name);
            lv(s, o, this)
        }
    }
    setValue(e, t, n, i) {
        const s = this.map[t];
        s !== void 0 && s.setValue(e, n, i)
    }
    setOptional(e, t, n) {
        const i = t[n];
        i !== void 0 && this.setValue(e, n, i)
    }
    static upload(e, t, n, i) {
        for (let s = 0, o = t.length; s !== o; ++s) {
            const a = t[s]
              , c = n[a.id];
            c.needsUpdate !== !1 && a.setValue(e, c.value, i)
        }
    }
    static seqWithValue(e, t) {
        const n = [];
        for (let i = 0, s = e.length; i !== s; ++i) {
            const o = e[i];
            o.id in t && n.push(o)
        }
        return n
    }
}
function Xl(r, e, t) {
    const n = r.createShader(e);
    return r.shaderSource(n, t),
    r.compileShader(n),
    n
}
const uv = 37297;
let hv = 0;
function dv(r, e) {
    const t = r.split(`
`)
      , n = []
      , i = Math.max(e - 6, 0)
      , s = Math.min(e + 6, t.length);
    for (let o = i; o < s; o++) {
        const a = o + 1;
        n.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`)
    }
    return n.join(`
`)
}
const Gl = new qe;
function fv(r) {
    et._getMatrix(Gl, et.workingColorSpace, r);
    const e = `mat3( ${Gl.elements.map(t => t.toFixed(4))} )`;
    switch (et.getTransfer(r)) {
    case _r:
        return [e, "LinearTransferOETF"];
    case at:
        return [e, "sRGBTransferOETF"];
    default:
        return console.warn("THREE.WebGLProgram: Unsupported color space: ", r),
        [e, "LinearTransferOETF"]
    }
}
function Vl(r, e, t) {
    const n = r.getShaderParameter(e, r.COMPILE_STATUS)
      , i = r.getShaderInfoLog(e).trim();
    if (n && i === "")
        return "";
    const s = /ERROR: 0:(\d+)/.exec(i);
    if (s) {
        const o = parseInt(s[1]);
        return t.toUpperCase() + `

` + i + `

` + dv(r.getShaderSource(e), o)
    } else
        return i
}
function pv(r, e) {
    const t = fv(e);
    return [`vec4 ${r}( vec4 value ) {`, `	return ${t[1]}( vec4( value.rgb * ${t[0]}, value.a ) );`, "}"].join(`
`)
}
function mv(r, e) {
    let t;
    switch (e) {
    case Xh:
        t = "Linear";
        break;
    case Gh:
        t = "Reinhard";
        break;
    case Vh:
        t = "Cineon";
        break;
    case Wh:
        t = "ACESFilmic";
        break;
    case kh:
        t = "AgX";
        break;
    case Yh:
        t = "Neutral";
        break;
    case jh:
        t = "Custom";
        break;
    default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        t = "Linear"
    }
    return "vec3 " + r + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
}
const Sr = new D;
function Av() {
    et.getLuminanceCoefficients(Sr);
    const r = Sr.x.toFixed(4)
      , e = Sr.y.toFixed(4)
      , t = Sr.z.toFixed(4);
    return ["float luminance( const in vec3 rgb ) {", `	const vec3 weights = vec3( ${r}, ${e}, ${t} );`, "	return dot( weights, rgb );", "}"].join(`
`)
}
function gv(r) {
    return [r.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", r.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(vs).join(`
`)
}
function vv(r) {
    const e = [];
    for (const t in r) {
        const n = r[t];
        n !== !1 && e.push("#define " + t + " " + n)
    }
    return e.join(`
`)
}
function xv(r, e) {
    const t = {}
      , n = r.getProgramParameter(e, r.ACTIVE_ATTRIBUTES);
    for (let i = 0; i < n; i++) {
        const s = r.getActiveAttrib(e, i)
          , o = s.name;
        let a = 1;
        s.type === r.FLOAT_MAT2 && (a = 2),
        s.type === r.FLOAT_MAT3 && (a = 3),
        s.type === r.FLOAT_MAT4 && (a = 4),
        t[o] = {
            type: s.type,
            location: r.getAttribLocation(e, o),
            locationSize: a
        }
    }
    return t
}
function vs(r) {
    return r !== ""
}
function Wl(r, e) {
    const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
    return r.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
}
function jl(r, e) {
    return r.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
}
const yv = /^[ \t]*#include +<([\w\d./]+)>/gm;
function _a(r) {
    return r.replace(yv, Mv)
}
const bv = new Map;
function Mv(r, e) {
    let t = Ze[e];
    if (t === void 0) {
        const n = bv.get(e);
        if (n !== void 0)
            t = Ze[n],
            console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, n);
        else
            throw new Error("Can not resolve #include <" + e + ">")
    }
    return _a(t)
}
const wv = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function kl(r) {
    return r.replace(wv, Sv)
}
function Sv(r, e, t, n) {
    let i = "";
    for (let s = parseInt(e); s < parseInt(t); s++)
        i += n.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
    return i
}
function Yl(r) {
    let e = `precision ${r.precision} float;
	precision ${r.precision} int;
	precision ${r.precision} sampler2D;
	precision ${r.precision} samplerCube;
	precision ${r.precision} sampler3D;
	precision ${r.precision} sampler2DArray;
	precision ${r.precision} sampler2DShadow;
	precision ${r.precision} samplerCubeShadow;
	precision ${r.precision} sampler2DArrayShadow;
	precision ${r.precision} isampler2D;
	precision ${r.precision} isampler3D;
	precision ${r.precision} isamplerCube;
	precision ${r.precision} isampler2DArray;
	precision ${r.precision} usampler2D;
	precision ${r.precision} usampler3D;
	precision ${r.precision} usamplerCube;
	precision ${r.precision} usampler2DArray;
	`;
    return r.precision === "highp" ? e += `
#define HIGH_PRECISION` : r.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : r.precision === "lowp" && (e += `
#define LOW_PRECISION`),
    e
}
function Tv(r) {
    let e = "SHADOWMAP_TYPE_BASIC";
    return r.shadowMapType === ja ? e = "SHADOWMAP_TYPE_PCF" : r.shadowMapType === yh ? e = "SHADOWMAP_TYPE_PCF_SOFT" : r.shadowMapType === Nn && (e = "SHADOWMAP_TYPE_VSM"),
    e
}
function Ev(r) {
    let e = "ENVMAP_TYPE_CUBE";
    if (r.envMap)
        switch (r.envMapMode) {
        case Wi:
        case ji:
            e = "ENVMAP_TYPE_CUBE";
            break;
        case Wr:
            e = "ENVMAP_TYPE_CUBE_UV";
            break
        }
    return e
}
function Pv(r) {
    let e = "ENVMAP_MODE_REFLECTION";
    if (r.envMap)
        switch (r.envMapMode) {
        case ji:
            e = "ENVMAP_MODE_REFRACTION";
            break
        }
    return e
}
function Lv(r) {
    let e = "ENVMAP_BLENDING_NONE";
    if (r.envMap)
        switch (r.combine) {
        case ka:
            e = "ENVMAP_BLENDING_MULTIPLY";
            break;
        case _h:
            e = "ENVMAP_BLENDING_MIX";
            break;
        case Hh:
            e = "ENVMAP_BLENDING_ADD";
            break
        }
    return e
}
function Cv(r) {
    const e = r.envMapCubeUVHeight;
    if (e === null)
        return null;
    const t = Math.log2(e) - 2
      , n = 1 / e;
    return {
        texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
        texelHeight: n,
        maxMip: t
    }
}
function Rv(r, e, t, n) {
    const i = r.getContext()
      , s = t.defines;
    let o = t.vertexShader
      , a = t.fragmentShader;
    const c = Tv(t)
      , l = Ev(t)
      , u = Pv(t)
      , h = Lv(t)
      , d = Cv(t)
      , f = gv(t)
      , m = vv(s)
      , g = i.createProgram();
    let A, p, S = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
    t.isRawShaderMaterial ? (A = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, m].filter(vs).join(`
`),
    A.length > 0 && (A += `
`),
    p = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, m].filter(vs).join(`
`),
    p.length > 0 && (p += `
`)) : (A = [Yl(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, m, t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", t.batching ? "#define USE_BATCHING" : "", t.batchingColor ? "#define USE_BATCHING_COLOR" : "", t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + u : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.mapUv ? "#define MAP_UV " + t.mapUv : "", t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "", t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "", t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "", t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "", t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "", t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "", t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "", t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "", t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "", t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "", t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "", t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "", t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "", t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "", t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "", t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "", t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "", t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "", t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "", t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "", t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "", t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", t.morphColors ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + c : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "	uniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(vs).join(`
`),
    p = [Yl(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, m, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + l : "", t.envMap ? "#define " + u : "", t.envMap ? "#define " + h : "", d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "", d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "", d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.dispersion ? "#define USE_DISPERSION" : "", t.iridescence ? "#define USE_IRIDESCENCE" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor || t.batchingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + c : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", t.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== ti ? "#define TONE_MAPPING" : "", t.toneMapping !== ti ? Ze.tonemapping_pars_fragment : "", t.toneMapping !== ti ? mv("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", Ze.colorspace_pars_fragment, pv("linearToOutputTexel", t.outputColorSpace), Av(), t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", `
`].filter(vs).join(`
`)),
    o = _a(o),
    o = Wl(o, t),
    o = jl(o, t),
    a = _a(a),
    a = Wl(a, t),
    a = jl(a, t),
    o = kl(o),
    a = kl(a),
    t.isRawShaderMaterial !== !0 && (S = `#version 300 es
`,
    A = [f, "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + A,
    p = ["#define varying in", t.glslVersion === Nc ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === Nc ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + p);
    const w = S + A + o
      , b = S + p + a
      , B = Xl(i, i.VERTEX_SHADER, w)
      , z = Xl(i, i.FRAGMENT_SHADER, b);
    i.attachShader(g, B),
    i.attachShader(g, z),
    t.index0AttributeName !== void 0 ? i.bindAttribLocation(g, 0, t.index0AttributeName) : t.morphTargets === !0 && i.bindAttribLocation(g, 0, "position"),
    i.linkProgram(g);
    function I(_) {
        if (r.debug.checkShaderErrors) {
            const re = i.getProgramInfoLog(g).trim()
              , k = i.getShaderInfoLog(B).trim()
              , U = i.getShaderInfoLog(z).trim();
            let F = !0
              , O = !0;
            if (i.getProgramParameter(g, i.LINK_STATUS) === !1)
                if (F = !1,
                typeof r.debug.onShaderError == "function")
                    r.debug.onShaderError(i, g, B, z);
                else {
                    const y = Vl(i, B, "vertex")
                      , v = Vl(i, z, "fragment");
                    console.error("THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(g, i.VALIDATE_STATUS) + `

Material Name: ` + _.name + `
Material Type: ` + _.type + `

Program Info Log: ` + re + `
` + y + `
` + v)
                }
            else
                re !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", re) : (k === "" || U === "") && (O = !1);
            O && (_.diagnostics = {
                runnable: F,
                programLog: re,
                vertexShader: {
                    log: k,
                    prefix: A
                },
                fragmentShader: {
                    log: U,
                    prefix: p
                }
            })
        }
        i.deleteShader(B),
        i.deleteShader(z),
        H = new Ir(i,g),
        P = xv(i, g)
    }
    let H;
    this.getUniforms = function() {
        return H === void 0 && I(this),
        H
    }
    ;
    let P;
    this.getAttributes = function() {
        return P === void 0 && I(this),
        P
    }
    ;
    let T = t.rendererExtensionParallelShaderCompile === !1;
    return this.isReady = function() {
        return T === !1 && (T = i.getProgramParameter(g, uv)),
        T
    }
    ,
    this.destroy = function() {
        n.releaseStatesOfProgram(this),
        i.deleteProgram(g),
        this.program = void 0
    }
    ,
    this.type = t.shaderType,
    this.name = t.shaderName,
    this.id = hv++,
    this.cacheKey = e,
    this.usedTimes = 1,
    this.program = g,
    this.vertexShader = B,
    this.fragmentShader = z,
    this
}
let Dv = 0;
class Nv {
    constructor() {
        this.shaderCache = new Map,
        this.materialCache = new Map
    }
    update(e) {
        const t = e.vertexShader
          , n = e.fragmentShader
          , i = this._getShaderStage(t)
          , s = this._getShaderStage(n)
          , o = this._getShaderCacheForMaterial(e);
        return o.has(i) === !1 && (o.add(i),
        i.usedTimes++),
        o.has(s) === !1 && (o.add(s),
        s.usedTimes++),
        this
    }
    remove(e) {
        const t = this.materialCache.get(e);
        for (const n of t)
            n.usedTimes--,
            n.usedTimes === 0 && this.shaderCache.delete(n.code);
        return this.materialCache.delete(e),
        this
    }
    getVertexShaderID(e) {
        return this._getShaderStage(e.vertexShader).id
    }
    getFragmentShaderID(e) {
        return this._getShaderStage(e.fragmentShader).id
    }
    dispose() {
        this.shaderCache.clear(),
        this.materialCache.clear()
    }
    _getShaderCacheForMaterial(e) {
        const t = this.materialCache;
        let n = t.get(e);
        return n === void 0 && (n = new Set,
        t.set(e, n)),
        n
    }
    _getShaderStage(e) {
        const t = this.shaderCache;
        let n = t.get(e);
        return n === void 0 && (n = new Ov(e),
        t.set(e, n)),
        n
    }
}
class Ov {
    constructor(e) {
        this.id = Dv++,
        this.code = e,
        this.usedTimes = 0
    }
}
function zv(r, e, t, n, i, s, o) {
    const a = new ic
      , c = new Nv
      , l = new Set
      , u = []
      , h = i.logarithmicDepthBuffer
      , d = i.vertexTextures;
    let f = i.precision;
    const m = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
    };
    function g(P) {
        return l.add(P),
        P === 0 ? "uv" : `uv${P}`
    }
    function A(P, T, _, re, k) {
        const U = re.fog
          , F = k.geometry
          , O = P.isMeshStandardMaterial ? re.environment : null
          , y = (P.isMeshStandardMaterial ? t : e).get(P.envMap || O)
          , v = y && y.mapping === Wr ? y.image.height : null
          , L = m[P.type];
        P.precision !== null && (f = i.getMaxPrecision(P.precision),
        f !== P.precision && console.warn("THREE.WebGLProgram.getParameters:", P.precision, "not supported, using", f, "instead."));
        const R = F.morphAttributes.position || F.morphAttributes.normal || F.morphAttributes.color
          , C = R !== void 0 ? R.length : 0;
        let Y = 0;
        F.morphAttributes.position !== void 0 && (Y = 1),
        F.morphAttributes.normal !== void 0 && (Y = 2),
        F.morphAttributes.color !== void 0 && (Y = 3);
        let ue, X, ne, ae;
        if (L) {
            const it = Gt[L];
            ue = it.vertexShader,
            X = it.fragmentShader
        } else
            ue = P.vertexShader,
            X = P.fragmentShader,
            c.update(P),
            ne = c.getVertexShaderID(P),
            ae = c.getFragmentShaderID(P);
        const ce = r.getRenderTarget()
          , le = r.state.buffers.depth.getReversed()
          , xe = k.isInstancedMesh === !0
          , ye = k.isBatchedMesh === !0
          , Te = !!P.map
          , G = !!P.matcap
          , K = !!y
          , x = !!P.aoMap
          , V = !!P.lightMap
          , W = !!P.bumpMap
          , oe = !!P.normalMap
          , $ = !!P.displacementMap
          , me = !!P.emissiveMap
          , he = !!P.metalnessMap
          , ge = !!P.roughnessMap
          , De = P.anisotropy > 0
          , N = P.clearcoat > 0
          , M = P.dispersion > 0
          , q = P.iridescence > 0
          , J = P.sheen > 0
          , ee = P.transmission > 0
          , te = De && !!P.anisotropyMap
          , we = N && !!P.clearcoatMap
          , de = N && !!P.clearcoatNormalMap
          , Ee = N && !!P.clearcoatRoughnessMap
          , Pe = q && !!P.iridescenceMap
          , fe = q && !!P.iridescenceThicknessMap
          , Ne = J && !!P.sheenColorMap
          , _e = J && !!P.sheenRoughnessMap
          , Ue = !!P.specularMap
          , Le = !!P.specularColorMap
          , ke = !!P.specularIntensityMap
          , j = ee && !!P.transmissionMap
          , Ce = ee && !!P.thicknessMap
          , ve = !!P.gradientMap
          , ze = !!P.alphaMap
          , be = P.alphaTest > 0
          , pe = !!P.alphaHash
          , Be = !!P.extensions;
        let Ye = ti;
        P.toneMapped && (ce === null || ce.isXRRenderTarget === !0) && (Ye = r.toneMapping);
        const ut = {
            shaderID: L,
            shaderType: P.type,
            shaderName: P.name,
            vertexShader: ue,
            fragmentShader: X,
            defines: P.defines,
            customVertexShaderID: ne,
            customFragmentShaderID: ae,
            isRawShaderMaterial: P.isRawShaderMaterial === !0,
            glslVersion: P.glslVersion,
            precision: f,
            batching: ye,
            batchingColor: ye && k._colorsTexture !== null,
            instancing: xe,
            instancingColor: xe && k.instanceColor !== null,
            instancingMorph: xe && k.morphTexture !== null,
            supportsVertexTextures: d,
            outputColorSpace: ce === null ? r.outputColorSpace : ce.isXRRenderTarget === !0 ? ce.texture.colorSpace : Ht,
            alphaToCoverage: !!P.alphaToCoverage,
            map: Te,
            matcap: G,
            envMap: K,
            envMapMode: K && y.mapping,
            envMapCubeUVHeight: v,
            aoMap: x,
            lightMap: V,
            bumpMap: W,
            normalMap: oe,
            displacementMap: d && $,
            emissiveMap: me,
            normalMapObjectSpace: oe && P.normalMapType === $h,
            normalMapTangentSpace: oe && P.normalMapType === ec,
            metalnessMap: he,
            roughnessMap: ge,
            anisotropy: De,
            anisotropyMap: te,
            clearcoat: N,
            clearcoatMap: we,
            clearcoatNormalMap: de,
            clearcoatRoughnessMap: Ee,
            dispersion: M,
            iridescence: q,
            iridescenceMap: Pe,
            iridescenceThicknessMap: fe,
            sheen: J,
            sheenColorMap: Ne,
            sheenRoughnessMap: _e,
            specularMap: Ue,
            specularColorMap: Le,
            specularIntensityMap: ke,
            transmission: ee,
            transmissionMap: j,
            thicknessMap: Ce,
            gradientMap: ve,
            opaque: P.transparent === !1 && P.blending === Bi && P.alphaToCoverage === !1,
            alphaMap: ze,
            alphaTest: be,
            alphaHash: pe,
            combine: P.combine,
            mapUv: Te && g(P.map.channel),
            aoMapUv: x && g(P.aoMap.channel),
            lightMapUv: V && g(P.lightMap.channel),
            bumpMapUv: W && g(P.bumpMap.channel),
            normalMapUv: oe && g(P.normalMap.channel),
            displacementMapUv: $ && g(P.displacementMap.channel),
            emissiveMapUv: me && g(P.emissiveMap.channel),
            metalnessMapUv: he && g(P.metalnessMap.channel),
            roughnessMapUv: ge && g(P.roughnessMap.channel),
            anisotropyMapUv: te && g(P.anisotropyMap.channel),
            clearcoatMapUv: we && g(P.clearcoatMap.channel),
            clearcoatNormalMapUv: de && g(P.clearcoatNormalMap.channel),
            clearcoatRoughnessMapUv: Ee && g(P.clearcoatRoughnessMap.channel),
            iridescenceMapUv: Pe && g(P.iridescenceMap.channel),
            iridescenceThicknessMapUv: fe && g(P.iridescenceThicknessMap.channel),
            sheenColorMapUv: Ne && g(P.sheenColorMap.channel),
            sheenRoughnessMapUv: _e && g(P.sheenRoughnessMap.channel),
            specularMapUv: Ue && g(P.specularMap.channel),
            specularColorMapUv: Le && g(P.specularColorMap.channel),
            specularIntensityMapUv: ke && g(P.specularIntensityMap.channel),
            transmissionMapUv: j && g(P.transmissionMap.channel),
            thicknessMapUv: Ce && g(P.thicknessMap.channel),
            alphaMapUv: ze && g(P.alphaMap.channel),
            vertexTangents: !!F.attributes.tangent && (oe || De),
            vertexColors: P.vertexColors,
            vertexAlphas: P.vertexColors === !0 && !!F.attributes.color && F.attributes.color.itemSize === 4,
            pointsUvs: k.isPoints === !0 && !!F.attributes.uv && (Te || ze),
            fog: !!U,
            useFog: P.fog === !0,
            fogExp2: !!U && U.isFogExp2,
            flatShading: P.flatShading === !0,
            sizeAttenuation: P.sizeAttenuation === !0,
            logarithmicDepthBuffer: h,
            reverseDepthBuffer: le,
            skinning: k.isSkinnedMesh === !0,
            morphTargets: F.morphAttributes.position !== void 0,
            morphNormals: F.morphAttributes.normal !== void 0,
            morphColors: F.morphAttributes.color !== void 0,
            morphTargetsCount: C,
            morphTextureStride: Y,
            numDirLights: T.directional.length,
            numPointLights: T.point.length,
            numSpotLights: T.spot.length,
            numSpotLightMaps: T.spotLightMap.length,
            numRectAreaLights: T.rectArea.length,
            numHemiLights: T.hemi.length,
            numDirLightShadows: T.directionalShadowMap.length,
            numPointLightShadows: T.pointShadowMap.length,
            numSpotLightShadows: T.spotShadowMap.length,
            numSpotLightShadowsWithMaps: T.numSpotLightShadowsWithMaps,
            numLightProbes: T.numLightProbes,
            numClippingPlanes: o.numPlanes,
            numClipIntersection: o.numIntersection,
            dithering: P.dithering,
            shadowMapEnabled: r.shadowMap.enabled && _.length > 0,
            shadowMapType: r.shadowMap.type,
            toneMapping: Ye,
            decodeVideoTexture: Te && P.map.isVideoTexture === !0 && et.getTransfer(P.map.colorSpace) === at,
            decodeVideoTextureEmissive: me && P.emissiveMap.isVideoTexture === !0 && et.getTransfer(P.emissiveMap.colorSpace) === at,
            premultipliedAlpha: P.premultipliedAlpha,
            doubleSided: P.side === $t,
            flipSided: P.side === Vt,
            useDepthPacking: P.depthPacking >= 0,
            depthPacking: P.depthPacking || 0,
            index0AttributeName: P.index0AttributeName,
            extensionClipCullDistance: Be && P.extensions.clipCullDistance === !0 && n.has("WEBGL_clip_cull_distance"),
            extensionMultiDraw: (Be && P.extensions.multiDraw === !0 || ye) && n.has("WEBGL_multi_draw"),
            rendererExtensionParallelShaderCompile: n.has("KHR_parallel_shader_compile"),
            customProgramCacheKey: P.customProgramCacheKey()
        };
        return ut.vertexUv1s = l.has(1),
        ut.vertexUv2s = l.has(2),
        ut.vertexUv3s = l.has(3),
        l.clear(),
        ut
    }
    function p(P) {
        const T = [];
        if (P.shaderID ? T.push(P.shaderID) : (T.push(P.customVertexShaderID),
        T.push(P.customFragmentShaderID)),
        P.defines !== void 0)
            for (const _ in P.defines)
                T.push(_),
                T.push(P.defines[_]);
        return P.isRawShaderMaterial === !1 && (S(T, P),
        w(T, P),
        T.push(r.outputColorSpace)),
        T.push(P.customProgramCacheKey),
        T.join()
    }
    function S(P, T) {
        P.push(T.precision),
        P.push(T.outputColorSpace),
        P.push(T.envMapMode),
        P.push(T.envMapCubeUVHeight),
        P.push(T.mapUv),
        P.push(T.alphaMapUv),
        P.push(T.lightMapUv),
        P.push(T.aoMapUv),
        P.push(T.bumpMapUv),
        P.push(T.normalMapUv),
        P.push(T.displacementMapUv),
        P.push(T.emissiveMapUv),
        P.push(T.metalnessMapUv),
        P.push(T.roughnessMapUv),
        P.push(T.anisotropyMapUv),
        P.push(T.clearcoatMapUv),
        P.push(T.clearcoatNormalMapUv),
        P.push(T.clearcoatRoughnessMapUv),
        P.push(T.iridescenceMapUv),
        P.push(T.iridescenceThicknessMapUv),
        P.push(T.sheenColorMapUv),
        P.push(T.sheenRoughnessMapUv),
        P.push(T.specularMapUv),
        P.push(T.specularColorMapUv),
        P.push(T.specularIntensityMapUv),
        P.push(T.transmissionMapUv),
        P.push(T.thicknessMapUv),
        P.push(T.combine),
        P.push(T.fogExp2),
        P.push(T.sizeAttenuation),
        P.push(T.morphTargetsCount),
        P.push(T.morphAttributeCount),
        P.push(T.numDirLights),
        P.push(T.numPointLights),
        P.push(T.numSpotLights),
        P.push(T.numSpotLightMaps),
        P.push(T.numHemiLights),
        P.push(T.numRectAreaLights),
        P.push(T.numDirLightShadows),
        P.push(T.numPointLightShadows),
        P.push(T.numSpotLightShadows),
        P.push(T.numSpotLightShadowsWithMaps),
        P.push(T.numLightProbes),
        P.push(T.shadowMapType),
        P.push(T.toneMapping),
        P.push(T.numClippingPlanes),
        P.push(T.numClipIntersection),
        P.push(T.depthPacking)
    }
    function w(P, T) {
        a.disableAll(),
        T.supportsVertexTextures && a.enable(0),
        T.instancing && a.enable(1),
        T.instancingColor && a.enable(2),
        T.instancingMorph && a.enable(3),
        T.matcap && a.enable(4),
        T.envMap && a.enable(5),
        T.normalMapObjectSpace && a.enable(6),
        T.normalMapTangentSpace && a.enable(7),
        T.clearcoat && a.enable(8),
        T.iridescence && a.enable(9),
        T.alphaTest && a.enable(10),
        T.vertexColors && a.enable(11),
        T.vertexAlphas && a.enable(12),
        T.vertexUv1s && a.enable(13),
        T.vertexUv2s && a.enable(14),
        T.vertexUv3s && a.enable(15),
        T.vertexTangents && a.enable(16),
        T.anisotropy && a.enable(17),
        T.alphaHash && a.enable(18),
        T.batching && a.enable(19),
        T.dispersion && a.enable(20),
        T.batchingColor && a.enable(21),
        P.push(a.mask),
        a.disableAll(),
        T.fog && a.enable(0),
        T.useFog && a.enable(1),
        T.flatShading && a.enable(2),
        T.logarithmicDepthBuffer && a.enable(3),
        T.reverseDepthBuffer && a.enable(4),
        T.skinning && a.enable(5),
        T.morphTargets && a.enable(6),
        T.morphNormals && a.enable(7),
        T.morphColors && a.enable(8),
        T.premultipliedAlpha && a.enable(9),
        T.shadowMapEnabled && a.enable(10),
        T.doubleSided && a.enable(11),
        T.flipSided && a.enable(12),
        T.useDepthPacking && a.enable(13),
        T.dithering && a.enable(14),
        T.transmission && a.enable(15),
        T.sheen && a.enable(16),
        T.opaque && a.enable(17),
        T.pointsUvs && a.enable(18),
        T.decodeVideoTexture && a.enable(19),
        T.decodeVideoTextureEmissive && a.enable(20),
        T.alphaToCoverage && a.enable(21),
        P.push(a.mask)
    }
    function b(P) {
        const T = m[P.type];
        let _;
        if (T) {
            const re = Gt[T];
            _ = sc.clone(re.uniforms)
        } else
            _ = P.uniforms;
        return _
    }
    function B(P, T) {
        let _;
        for (let re = 0, k = u.length; re < k; re++) {
            const U = u[re];
            if (U.cacheKey === T) {
                _ = U,
                ++_.usedTimes;
                break
            }
        }
        return _ === void 0 && (_ = new Rv(r,T,P,s),
        u.push(_)),
        _
    }
    function z(P) {
        if (--P.usedTimes === 0) {
            const T = u.indexOf(P);
            u[T] = u[u.length - 1],
            u.pop(),
            P.destroy()
        }
    }
    function I(P) {
        c.remove(P)
    }
    function H() {
        c.dispose()
    }
    return {
        getParameters: A,
        getProgramCacheKey: p,
        getUniforms: b,
        acquireProgram: B,
        releaseProgram: z,
        releaseShaderCache: I,
        programs: u,
        dispose: H
    }
}
function Iv() {
    let r = new WeakMap;
    function e(o) {
        return r.has(o)
    }
    function t(o) {
        let a = r.get(o);
        return a === void 0 && (a = {},
        r.set(o, a)),
        a
    }
    function n(o) {
        r.delete(o)
    }
    function i(o, a, c) {
        r.get(o)[a] = c
    }
    function s() {
        r = new WeakMap
    }
    return {
        has: e,
        get: t,
        remove: n,
        update: i,
        dispose: s
    }
}
function Uv(r, e) {
    return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.material.id !== e.material.id ? r.material.id - e.material.id : r.z !== e.z ? r.z - e.z : r.id - e.id
}
function ql(r, e) {
    return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.z !== e.z ? e.z - r.z : r.id - e.id
}
function Zl() {
    const r = [];
    let e = 0;
    const t = []
      , n = []
      , i = [];
    function s() {
        e = 0,
        t.length = 0,
        n.length = 0,
        i.length = 0
    }
    function o(h, d, f, m, g, A) {
        let p = r[e];
        return p === void 0 ? (p = {
            id: h.id,
            object: h,
            geometry: d,
            material: f,
            groupOrder: m,
            renderOrder: h.renderOrder,
            z: g,
            group: A
        },
        r[e] = p) : (p.id = h.id,
        p.object = h,
        p.geometry = d,
        p.material = f,
        p.groupOrder = m,
        p.renderOrder = h.renderOrder,
        p.z = g,
        p.group = A),
        e++,
        p
    }
    function a(h, d, f, m, g, A) {
        const p = o(h, d, f, m, g, A);
        f.transmission > 0 ? n.push(p) : f.transparent === !0 ? i.push(p) : t.push(p)
    }
    function c(h, d, f, m, g, A) {
        const p = o(h, d, f, m, g, A);
        f.transmission > 0 ? n.unshift(p) : f.transparent === !0 ? i.unshift(p) : t.unshift(p)
    }
    function l(h, d) {
        t.length > 1 && t.sort(h || Uv),
        n.length > 1 && n.sort(d || ql),
        i.length > 1 && i.sort(d || ql)
    }
    function u() {
        for (let h = e, d = r.length; h < d; h++) {
            const f = r[h];
            if (f.id === null)
                break;
            f.id = null,
            f.object = null,
            f.geometry = null,
            f.material = null,
            f.group = null
        }
    }
    return {
        opaque: t,
        transmissive: n,
        transparent: i,
        init: s,
        push: a,
        unshift: c,
        finish: u,
        sort: l
    }
}
function Bv() {
    let r = new WeakMap;
    function e(n, i) {
        const s = r.get(n);
        let o;
        return s === void 0 ? (o = new Zl,
        r.set(n, [o])) : i >= s.length ? (o = new Zl,
        s.push(o)) : o = s[i],
        o
    }
    function t() {
        r = new WeakMap
    }
    return {
        get: e,
        dispose: t
    }
}
function Fv() {
    const r = {};
    return {
        get: function(e) {
            if (r[e.id] !== void 0)
                return r[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    direction: new D,
                    color: new Ge
                };
                break;
            case "SpotLight":
                t = {
                    position: new D,
                    direction: new D,
                    color: new Ge,
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0
                };
                break;
            case "PointLight":
                t = {
                    position: new D,
                    color: new Ge,
                    distance: 0,
                    decay: 0
                };
                break;
            case "HemisphereLight":
                t = {
                    direction: new D,
                    skyColor: new Ge,
                    groundColor: new Ge
                };
                break;
            case "RectAreaLight":
                t = {
                    color: new Ge,
                    position: new D,
                    halfWidth: new D,
                    halfHeight: new D
                };
                break
            }
            return r[e.id] = t,
            t
        }
    }
}
function _v() {
    const r = {};
    return {
        get: function(e) {
            if (r[e.id] !== void 0)
                return r[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    shadowIntensity: 1,
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new Ae
                };
                break;
            case "SpotLight":
                t = {
                    shadowIntensity: 1,
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new Ae
                };
                break;
            case "PointLight":
                t = {
                    shadowIntensity: 1,
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new Ae,
                    shadowCameraNear: 1,
                    shadowCameraFar: 1e3
                };
                break
            }
            return r[e.id] = t,
            t
        }
    }
}
let Hv = 0;
function Xv(r, e) {
    return (e.castShadow ? 2 : 0) - (r.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (r.map ? 1 : 0)
}
function Gv(r) {
    const e = new Fv
      , t = _v()
      , n = {
        version: 0,
        hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1,
            numSpotMaps: -1,
            numLightProbes: -1
        },
        ambient: [0, 0, 0],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotLightMap: [],
        spotShadow: [],
        spotShadowMap: [],
        spotLightMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: [],
        numSpotLightShadowsWithMaps: 0,
        numLightProbes: 0
    };
    for (let l = 0; l < 9; l++)
        n.probe.push(new D);
    const i = new D
      , s = new We
      , o = new We;
    function a(l) {
        let u = 0
          , h = 0
          , d = 0;
        for (let P = 0; P < 9; P++)
            n.probe[P].set(0, 0, 0);
        let f = 0
          , m = 0
          , g = 0
          , A = 0
          , p = 0
          , S = 0
          , w = 0
          , b = 0
          , B = 0
          , z = 0
          , I = 0;
        l.sort(Xv);
        for (let P = 0, T = l.length; P < T; P++) {
            const _ = l[P]
              , re = _.color
              , k = _.intensity
              , U = _.distance
              , F = _.shadow && _.shadow.map ? _.shadow.map.texture : null;
            if (_.isAmbientLight)
                u += re.r * k,
                h += re.g * k,
                d += re.b * k;
            else if (_.isLightProbe) {
                for (let O = 0; O < 9; O++)
                    n.probe[O].addScaledVector(_.sh.coefficients[O], k);
                I++
            } else if (_.isDirectionalLight) {
                const O = e.get(_);
                if (O.color.copy(_.color).multiplyScalar(_.intensity),
                _.castShadow) {
                    const y = _.shadow
                      , v = t.get(_);
                    v.shadowIntensity = y.intensity,
                    v.shadowBias = y.bias,
                    v.shadowNormalBias = y.normalBias,
                    v.shadowRadius = y.radius,
                    v.shadowMapSize = y.mapSize,
                    n.directionalShadow[f] = v,
                    n.directionalShadowMap[f] = F,
                    n.directionalShadowMatrix[f] = _.shadow.matrix,
                    S++
                }
                n.directional[f] = O,
                f++
            } else if (_.isSpotLight) {
                const O = e.get(_);
                O.position.setFromMatrixPosition(_.matrixWorld),
                O.color.copy(re).multiplyScalar(k),
                O.distance = U,
                O.coneCos = Math.cos(_.angle),
                O.penumbraCos = Math.cos(_.angle * (1 - _.penumbra)),
                O.decay = _.decay,
                n.spot[g] = O;
                const y = _.shadow;
                if (_.map && (n.spotLightMap[B] = _.map,
                B++,
                y.updateMatrices(_),
                _.castShadow && z++),
                n.spotLightMatrix[g] = y.matrix,
                _.castShadow) {
                    const v = t.get(_);
                    v.shadowIntensity = y.intensity,
                    v.shadowBias = y.bias,
                    v.shadowNormalBias = y.normalBias,
                    v.shadowRadius = y.radius,
                    v.shadowMapSize = y.mapSize,
                    n.spotShadow[g] = v,
                    n.spotShadowMap[g] = F,
                    b++
                }
                g++
            } else if (_.isRectAreaLight) {
                const O = e.get(_);
                O.color.copy(re).multiplyScalar(k),
                O.halfWidth.set(_.width * .5, 0, 0),
                O.halfHeight.set(0, _.height * .5, 0),
                n.rectArea[A] = O,
                A++
            } else if (_.isPointLight) {
                const O = e.get(_);
                if (O.color.copy(_.color).multiplyScalar(_.intensity),
                O.distance = _.distance,
                O.decay = _.decay,
                _.castShadow) {
                    const y = _.shadow
                      , v = t.get(_);
                    v.shadowIntensity = y.intensity,
                    v.shadowBias = y.bias,
                    v.shadowNormalBias = y.normalBias,
                    v.shadowRadius = y.radius,
                    v.shadowMapSize = y.mapSize,
                    v.shadowCameraNear = y.camera.near,
                    v.shadowCameraFar = y.camera.far,
                    n.pointShadow[m] = v,
                    n.pointShadowMap[m] = F,
                    n.pointShadowMatrix[m] = _.shadow.matrix,
                    w++
                }
                n.point[m] = O,
                m++
            } else if (_.isHemisphereLight) {
                const O = e.get(_);
                O.skyColor.copy(_.color).multiplyScalar(k),
                O.groundColor.copy(_.groundColor).multiplyScalar(k),
                n.hemi[p] = O,
                p++
            }
        }
        A > 0 && (r.has("OES_texture_float_linear") === !0 ? (n.rectAreaLTC1 = Se.LTC_FLOAT_1,
        n.rectAreaLTC2 = Se.LTC_FLOAT_2) : (n.rectAreaLTC1 = Se.LTC_HALF_1,
        n.rectAreaLTC2 = Se.LTC_HALF_2)),
        n.ambient[0] = u,
        n.ambient[1] = h,
        n.ambient[2] = d;
        const H = n.hash;
        (H.directionalLength !== f || H.pointLength !== m || H.spotLength !== g || H.rectAreaLength !== A || H.hemiLength !== p || H.numDirectionalShadows !== S || H.numPointShadows !== w || H.numSpotShadows !== b || H.numSpotMaps !== B || H.numLightProbes !== I) && (n.directional.length = f,
        n.spot.length = g,
        n.rectArea.length = A,
        n.point.length = m,
        n.hemi.length = p,
        n.directionalShadow.length = S,
        n.directionalShadowMap.length = S,
        n.pointShadow.length = w,
        n.pointShadowMap.length = w,
        n.spotShadow.length = b,
        n.spotShadowMap.length = b,
        n.directionalShadowMatrix.length = S,
        n.pointShadowMatrix.length = w,
        n.spotLightMatrix.length = b + B - z,
        n.spotLightMap.length = B,
        n.numSpotLightShadowsWithMaps = z,
        n.numLightProbes = I,
        H.directionalLength = f,
        H.pointLength = m,
        H.spotLength = g,
        H.rectAreaLength = A,
        H.hemiLength = p,
        H.numDirectionalShadows = S,
        H.numPointShadows = w,
        H.numSpotShadows = b,
        H.numSpotMaps = B,
        H.numLightProbes = I,
        n.version = Hv++)
    }
    function c(l, u) {
        let h = 0
          , d = 0
          , f = 0
          , m = 0
          , g = 0;
        const A = u.matrixWorldInverse;
        for (let p = 0, S = l.length; p < S; p++) {
            const w = l[p];
            if (w.isDirectionalLight) {
                const b = n.directional[h];
                b.direction.setFromMatrixPosition(w.matrixWorld),
                i.setFromMatrixPosition(w.target.matrixWorld),
                b.direction.sub(i),
                b.direction.transformDirection(A),
                h++
            } else if (w.isSpotLight) {
                const b = n.spot[f];
                b.position.setFromMatrixPosition(w.matrixWorld),
                b.position.applyMatrix4(A),
                b.direction.setFromMatrixPosition(w.matrixWorld),
                i.setFromMatrixPosition(w.target.matrixWorld),
                b.direction.sub(i),
                b.direction.transformDirection(A),
                f++
            } else if (w.isRectAreaLight) {
                const b = n.rectArea[m];
                b.position.setFromMatrixPosition(w.matrixWorld),
                b.position.applyMatrix4(A),
                o.identity(),
                s.copy(w.matrixWorld),
                s.premultiply(A),
                o.extractRotation(s),
                b.halfWidth.set(w.width * .5, 0, 0),
                b.halfHeight.set(0, w.height * .5, 0),
                b.halfWidth.applyMatrix4(o),
                b.halfHeight.applyMatrix4(o),
                m++
            } else if (w.isPointLight) {
                const b = n.point[d];
                b.position.setFromMatrixPosition(w.matrixWorld),
                b.position.applyMatrix4(A),
                d++
            } else if (w.isHemisphereLight) {
                const b = n.hemi[g];
                b.direction.setFromMatrixPosition(w.matrixWorld),
                b.direction.transformDirection(A),
                g++
            }
        }
    }
    return {
        setup: a,
        setupView: c,
        state: n
    }
}
function Kl(r) {
    const e = new Gv(r)
      , t = []
      , n = [];
    function i(u) {
        l.camera = u,
        t.length = 0,
        n.length = 0
    }
    function s(u) {
        t.push(u)
    }
    function o(u) {
        n.push(u)
    }
    function a() {
        e.setup(t)
    }
    function c(u) {
        e.setupView(t, u)
    }
    const l = {
        lightsArray: t,
        shadowsArray: n,
        camera: null,
        lights: e,
        transmissionRenderTarget: {}
    };
    return {
        init: i,
        state: l,
        setupLights: a,
        setupLightsView: c,
        pushLight: s,
        pushShadow: o
    }
}
function Vv(r) {
    let e = new WeakMap;
    function t(i, s=0) {
        const o = e.get(i);
        let a;
        return o === void 0 ? (a = new Kl(r),
        e.set(i, [a])) : s >= o.length ? (a = new Kl(r),
        o.push(a)) : a = o[s],
        a
    }
    function n() {
        e = new WeakMap
    }
    return {
        get: t,
        dispose: n
    }
}
const Wv = `void main() {
	gl_Position = vec4( position, 1.0 );
}`
  , jv = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function kv(r, e, t) {
    let n = new oc;
    const i = new Ae
      , s = new Ae
      , o = new Je
      , a = new Hf({
        depthPacking: Jh
    })
      , c = new Xf
      , l = {}
      , u = t.maxTextureSize
      , h = {
        [Hn]: Vt,
        [Vt]: Hn,
        [$t]: $t
    }
      , d = new wn({
        defines: {
            VSM_SAMPLES: 8
        },
        uniforms: {
            shadow_pass: {
                value: null
            },
            resolution: {
                value: new Ae
            },
            radius: {
                value: 4
            }
        },
        vertexShader: Wv,
        fragmentShader: jv
    })
      , f = d.clone();
    f.defines.HORIZONTAL_PASS = 1;
    const m = new At;
    m.setAttribute("position", new vt(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
    const g = new ct(m,d)
      , A = this;
    this.enabled = !1,
    this.autoUpdate = !0,
    this.needsUpdate = !1,
    this.type = ja;
    let p = this.type;
    this.render = function(z, I, H) {
        if (A.enabled === !1 || A.autoUpdate === !1 && A.needsUpdate === !1 || z.length === 0)
            return;
        const P = r.getRenderTarget()
          , T = r.getActiveCubeFace()
          , _ = r.getActiveMipmapLevel()
          , re = r.state;
        re.setBlending(ei),
        re.buffers.color.setClear(1, 1, 1, 1),
        re.buffers.depth.setTest(!0),
        re.setScissorTest(!1);
        const k = p !== Nn && this.type === Nn
          , U = p === Nn && this.type !== Nn;
        for (let F = 0, O = z.length; F < O; F++) {
            const y = z[F]
              , v = y.shadow;
            if (v === void 0) {
                console.warn("THREE.WebGLShadowMap:", y, "has no shadow.");
                continue
            }
            if (v.autoUpdate === !1 && v.needsUpdate === !1)
                continue;
            i.copy(v.mapSize);
            const L = v.getFrameExtents();
            if (i.multiply(L),
            s.copy(v.mapSize),
            (i.x > u || i.y > u) && (i.x > u && (s.x = Math.floor(u / L.x),
            i.x = s.x * L.x,
            v.mapSize.x = s.x),
            i.y > u && (s.y = Math.floor(u / L.y),
            i.y = s.y * L.y,
            v.mapSize.y = s.y)),
            v.map === null || k === !0 || U === !0) {
                const C = this.type !== Nn ? {
                    minFilter: _t,
                    magFilter: _t
                } : {};
                v.map !== null && v.map.dispose(),
                v.map = new gi(i.x,i.y,C),
                v.map.texture.name = y.name + ".shadowMap",
                v.camera.updateProjectionMatrix()
            }
            r.setRenderTarget(v.map),
            r.clear();
            const R = v.getViewportCount();
            for (let C = 0; C < R; C++) {
                const Y = v.getViewport(C);
                o.set(s.x * Y.x, s.y * Y.y, s.x * Y.z, s.y * Y.w),
                re.viewport(o),
                v.updateMatrices(y, C),
                n = v.getFrustum(),
                b(I, H, v.camera, y, this.type)
            }
            v.isPointLightShadow !== !0 && this.type === Nn && S(v, H),
            v.needsUpdate = !1
        }
        p = this.type,
        A.needsUpdate = !1,
        r.setRenderTarget(P, T, _)
    }
    ;
    function S(z, I) {
        const H = e.update(g);
        d.defines.VSM_SAMPLES !== z.blurSamples && (d.defines.VSM_SAMPLES = z.blurSamples,
        f.defines.VSM_SAMPLES = z.blurSamples,
        d.needsUpdate = !0,
        f.needsUpdate = !0),
        z.mapPass === null && (z.mapPass = new gi(i.x,i.y)),
        d.uniforms.shadow_pass.value = z.map.texture,
        d.uniforms.resolution.value = z.mapSize,
        d.uniforms.radius.value = z.radius,
        r.setRenderTarget(z.mapPass),
        r.clear(),
        r.renderBufferDirect(I, null, H, d, g, null),
        f.uniforms.shadow_pass.value = z.mapPass.texture,
        f.uniforms.resolution.value = z.mapSize,
        f.uniforms.radius.value = z.radius,
        r.setRenderTarget(z.map),
        r.clear(),
        r.renderBufferDirect(I, null, H, f, g, null)
    }
    function w(z, I, H, P) {
        let T = null;
        const _ = H.isPointLight === !0 ? z.customDistanceMaterial : z.customDepthMaterial;
        if (_ !== void 0)
            T = _;
        else if (T = H.isPointLight === !0 ? c : a,
        r.localClippingEnabled && I.clipShadows === !0 && Array.isArray(I.clippingPlanes) && I.clippingPlanes.length !== 0 || I.displacementMap && I.displacementScale !== 0 || I.alphaMap && I.alphaTest > 0 || I.map && I.alphaTest > 0 || I.alphaToCoverage === !0) {
            const re = T.uuid
              , k = I.uuid;
            let U = l[re];
            U === void 0 && (U = {},
            l[re] = U);
            let F = U[k];
            F === void 0 && (F = T.clone(),
            U[k] = F,
            I.addEventListener("dispose", B)),
            T = F
        }
        if (T.visible = I.visible,
        T.wireframe = I.wireframe,
        P === Nn ? T.side = I.shadowSide !== null ? I.shadowSide : I.side : T.side = I.shadowSide !== null ? I.shadowSide : h[I.side],
        T.alphaMap = I.alphaMap,
        T.alphaTest = I.alphaToCoverage === !0 ? .5 : I.alphaTest,
        T.map = I.map,
        T.clipShadows = I.clipShadows,
        T.clippingPlanes = I.clippingPlanes,
        T.clipIntersection = I.clipIntersection,
        T.displacementMap = I.displacementMap,
        T.displacementScale = I.displacementScale,
        T.displacementBias = I.displacementBias,
        T.wireframeLinewidth = I.wireframeLinewidth,
        T.linewidth = I.linewidth,
        H.isPointLight === !0 && T.isMeshDistanceMaterial === !0) {
            const re = r.properties.get(T);
            re.light = H
        }
        return T
    }
    function b(z, I, H, P, T) {
        if (z.visible === !1)
            return;
        if (z.layers.test(I.layers) && (z.isMesh || z.isLine || z.isPoints) && (z.castShadow || z.receiveShadow && T === Nn) && (!z.frustumCulled || n.intersectsObject(z))) {
            z.modelViewMatrix.multiplyMatrices(H.matrixWorldInverse, z.matrixWorld);
            const k = e.update(z)
              , U = z.material;
            if (Array.isArray(U)) {
                const F = k.groups;
                for (let O = 0, y = F.length; O < y; O++) {
                    const v = F[O]
                      , L = U[v.materialIndex];
                    if (L && L.visible) {
                        const R = w(z, L, P, T);
                        z.onBeforeShadow(r, z, I, H, k, R, v),
                        r.renderBufferDirect(H, null, k, R, z, v),
                        z.onAfterShadow(r, z, I, H, k, R, v)
                    }
                }
            } else if (U.visible) {
                const F = w(z, U, P, T);
                z.onBeforeShadow(r, z, I, H, k, F, null),
                r.renderBufferDirect(H, null, k, F, z, null),
                z.onAfterShadow(r, z, I, H, k, F, null)
            }
        }
        const re = z.children;
        for (let k = 0, U = re.length; k < U; k++)
            b(re[k], I, H, P, T)
    }
    function B(z) {
        z.target.removeEventListener("dispose", B);
        for (const H in l) {
            const P = l[H]
              , T = z.target.uuid;
            T in P && (P[T].dispose(),
            delete P[T])
        }
    }
}
const Yv = {
    [Yo]: qo,
    [Zo]: Jo,
    [Ko]: $o,
    [Vi]: Qo,
    [qo]: Yo,
    [Jo]: Zo,
    [$o]: Ko,
    [Qo]: Vi
};
function qv(r, e) {
    function t() {
        let j = !1;
        const Ce = new Je;
        let ve = null;
        const ze = new Je(0,0,0,0);
        return {
            setMask: function(be) {
                ve !== be && !j && (r.colorMask(be, be, be, be),
                ve = be)
            },
            setLocked: function(be) {
                j = be
            },
            setClear: function(be, pe, Be, Ye, ut) {
                ut === !0 && (be *= Ye,
                pe *= Ye,
                Be *= Ye),
                Ce.set(be, pe, Be, Ye),
                ze.equals(Ce) === !1 && (r.clearColor(be, pe, Be, Ye),
                ze.copy(Ce))
            },
            reset: function() {
                j = !1,
                ve = null,
                ze.set(-1, 0, 0, 0)
            }
        }
    }
    function n() {
        let j = !1
          , Ce = !1
          , ve = null
          , ze = null
          , be = null;
        return {
            setReversed: function(pe) {
                if (Ce !== pe) {
                    const Be = e.get("EXT_clip_control");
                    pe ? Be.clipControlEXT(Be.LOWER_LEFT_EXT, Be.ZERO_TO_ONE_EXT) : Be.clipControlEXT(Be.LOWER_LEFT_EXT, Be.NEGATIVE_ONE_TO_ONE_EXT),
                    Ce = pe;
                    const Ye = be;
                    be = null,
                    this.setClear(Ye)
                }
            },
            getReversed: function() {
                return Ce
            },
            setTest: function(pe) {
                pe ? ce(r.DEPTH_TEST) : le(r.DEPTH_TEST)
            },
            setMask: function(pe) {
                ve !== pe && !j && (r.depthMask(pe),
                ve = pe)
            },
            setFunc: function(pe) {
                if (Ce && (pe = Yv[pe]),
                ze !== pe) {
                    switch (pe) {
                    case Yo:
                        r.depthFunc(r.NEVER);
                        break;
                    case qo:
                        r.depthFunc(r.ALWAYS);
                        break;
                    case Zo:
                        r.depthFunc(r.LESS);
                        break;
                    case Vi:
                        r.depthFunc(r.LEQUAL);
                        break;
                    case Ko:
                        r.depthFunc(r.EQUAL);
                        break;
                    case Qo:
                        r.depthFunc(r.GEQUAL);
                        break;
                    case Jo:
                        r.depthFunc(r.GREATER);
                        break;
                    case $o:
                        r.depthFunc(r.NOTEQUAL);
                        break;
                    default:
                        r.depthFunc(r.LEQUAL)
                    }
                    ze = pe
                }
            },
            setLocked: function(pe) {
                j = pe
            },
            setClear: function(pe) {
                be !== pe && (Ce && (pe = 1 - pe),
                r.clearDepth(pe),
                be = pe)
            },
            reset: function() {
                j = !1,
                ve = null,
                ze = null,
                be = null,
                Ce = !1
            }
        }
    }
    function i() {
        let j = !1
          , Ce = null
          , ve = null
          , ze = null
          , be = null
          , pe = null
          , Be = null
          , Ye = null
          , ut = null;
        return {
            setTest: function(it) {
                j || (it ? ce(r.STENCIL_TEST) : le(r.STENCIL_TEST))
            },
            setMask: function(it) {
                Ce !== it && !j && (r.stencilMask(it),
                Ce = it)
            },
            setFunc: function(it, on, Tn) {
                (ve !== it || ze !== on || be !== Tn) && (r.stencilFunc(it, on, Tn),
                ve = it,
                ze = on,
                be = Tn)
            },
            setOp: function(it, on, Tn) {
                (pe !== it || Be !== on || Ye !== Tn) && (r.stencilOp(it, on, Tn),
                pe = it,
                Be = on,
                Ye = Tn)
            },
            setLocked: function(it) {
                j = it
            },
            setClear: function(it) {
                ut !== it && (r.clearStencil(it),
                ut = it)
            },
            reset: function() {
                j = !1,
                Ce = null,
                ve = null,
                ze = null,
                be = null,
                pe = null,
                Be = null,
                Ye = null,
                ut = null
            }
        }
    }
    const s = new t
      , o = new n
      , a = new i
      , c = new WeakMap
      , l = new WeakMap;
    let u = {}
      , h = {}
      , d = new WeakMap
      , f = []
      , m = null
      , g = !1
      , A = null
      , p = null
      , S = null
      , w = null
      , b = null
      , B = null
      , z = null
      , I = new Ge(0,0,0)
      , H = 0
      , P = !1
      , T = null
      , _ = null
      , re = null
      , k = null
      , U = null;
    const F = r.getParameter(r.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    let O = !1
      , y = 0;
    const v = r.getParameter(r.VERSION);
    v.indexOf("WebGL") !== -1 ? (y = parseFloat(/^WebGL (\d)/.exec(v)[1]),
    O = y >= 1) : v.indexOf("OpenGL ES") !== -1 && (y = parseFloat(/^OpenGL ES (\d)/.exec(v)[1]),
    O = y >= 2);
    let L = null
      , R = {};
    const C = r.getParameter(r.SCISSOR_BOX)
      , Y = r.getParameter(r.VIEWPORT)
      , ue = new Je().fromArray(C)
      , X = new Je().fromArray(Y);
    function ne(j, Ce, ve, ze) {
        const be = new Uint8Array(4)
          , pe = r.createTexture();
        r.bindTexture(j, pe),
        r.texParameteri(j, r.TEXTURE_MIN_FILTER, r.NEAREST),
        r.texParameteri(j, r.TEXTURE_MAG_FILTER, r.NEAREST);
        for (let Be = 0; Be < ve; Be++)
            j === r.TEXTURE_3D || j === r.TEXTURE_2D_ARRAY ? r.texImage3D(Ce, 0, r.RGBA, 1, 1, ze, 0, r.RGBA, r.UNSIGNED_BYTE, be) : r.texImage2D(Ce + Be, 0, r.RGBA, 1, 1, 0, r.RGBA, r.UNSIGNED_BYTE, be);
        return pe
    }
    const ae = {};
    ae[r.TEXTURE_2D] = ne(r.TEXTURE_2D, r.TEXTURE_2D, 1),
    ae[r.TEXTURE_CUBE_MAP] = ne(r.TEXTURE_CUBE_MAP, r.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
    ae[r.TEXTURE_2D_ARRAY] = ne(r.TEXTURE_2D_ARRAY, r.TEXTURE_2D_ARRAY, 1, 1),
    ae[r.TEXTURE_3D] = ne(r.TEXTURE_3D, r.TEXTURE_3D, 1, 1),
    s.setClear(0, 0, 0, 1),
    o.setClear(1),
    a.setClear(0),
    ce(r.DEPTH_TEST),
    o.setFunc(Vi),
    W(!1),
    oe(wc),
    ce(r.CULL_FACE),
    x(ei);
    function ce(j) {
        u[j] !== !0 && (r.enable(j),
        u[j] = !0)
    }
    function le(j) {
        u[j] !== !1 && (r.disable(j),
        u[j] = !1)
    }
    function xe(j, Ce) {
        return h[j] !== Ce ? (r.bindFramebuffer(j, Ce),
        h[j] = Ce,
        j === r.DRAW_FRAMEBUFFER && (h[r.FRAMEBUFFER] = Ce),
        j === r.FRAMEBUFFER && (h[r.DRAW_FRAMEBUFFER] = Ce),
        !0) : !1
    }
    function ye(j, Ce) {
        let ve = f
          , ze = !1;
        if (j) {
            ve = d.get(Ce),
            ve === void 0 && (ve = [],
            d.set(Ce, ve));
            const be = j.textures;
            if (ve.length !== be.length || ve[0] !== r.COLOR_ATTACHMENT0) {
                for (let pe = 0, Be = be.length; pe < Be; pe++)
                    ve[pe] = r.COLOR_ATTACHMENT0 + pe;
                ve.length = be.length,
                ze = !0
            }
        } else
            ve[0] !== r.BACK && (ve[0] = r.BACK,
            ze = !0);
        ze && r.drawBuffers(ve)
    }
    function Te(j) {
        return m !== j ? (r.useProgram(j),
        m = j,
        !0) : !1
    }
    const G = {
        [fi]: r.FUNC_ADD,
        [Mh]: r.FUNC_SUBTRACT,
        [wh]: r.FUNC_REVERSE_SUBTRACT
    };
    G[Sh] = r.MIN,
    G[Th] = r.MAX;
    const K = {
        [Eh]: r.ZERO,
        [Ph]: r.ONE,
        [Lh]: r.SRC_COLOR,
        [jo]: r.SRC_ALPHA,
        [zh]: r.SRC_ALPHA_SATURATE,
        [Nh]: r.DST_COLOR,
        [Rh]: r.DST_ALPHA,
        [Ch]: r.ONE_MINUS_SRC_COLOR,
        [ko]: r.ONE_MINUS_SRC_ALPHA,
        [Oh]: r.ONE_MINUS_DST_COLOR,
        [Dh]: r.ONE_MINUS_DST_ALPHA,
        [Ih]: r.CONSTANT_COLOR,
        [Uh]: r.ONE_MINUS_CONSTANT_COLOR,
        [Bh]: r.CONSTANT_ALPHA,
        [Fh]: r.ONE_MINUS_CONSTANT_ALPHA
    };
    function x(j, Ce, ve, ze, be, pe, Be, Ye, ut, it) {
        if (j === ei) {
            g === !0 && (le(r.BLEND),
            g = !1);
            return
        }
        if (g === !1 && (ce(r.BLEND),
        g = !0),
        j !== bh) {
            if (j !== A || it !== P) {
                if ((p !== fi || b !== fi) && (r.blendEquation(r.FUNC_ADD),
                p = fi,
                b = fi),
                it)
                    switch (j) {
                    case Bi:
                        r.blendFuncSeparate(r.ONE, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA);
                        break;
                    case Sc:
                        r.blendFunc(r.ONE, r.ONE);
                        break;
                    case Tc:
                        r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
                        break;
                    case Ec:
                        r.blendFuncSeparate(r.ZERO, r.SRC_COLOR, r.ZERO, r.SRC_ALPHA);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", j);
                        break
                    }
                else
                    switch (j) {
                    case Bi:
                        r.blendFuncSeparate(r.SRC_ALPHA, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA);
                        break;
                    case Sc:
                        r.blendFunc(r.SRC_ALPHA, r.ONE);
                        break;
                    case Tc:
                        r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
                        break;
                    case Ec:
                        r.blendFunc(r.ZERO, r.SRC_COLOR);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", j);
                        break
                    }
                S = null,
                w = null,
                B = null,
                z = null,
                I.set(0, 0, 0),
                H = 0,
                A = j,
                P = it
            }
            return
        }
        be = be || Ce,
        pe = pe || ve,
        Be = Be || ze,
        (Ce !== p || be !== b) && (r.blendEquationSeparate(G[Ce], G[be]),
        p = Ce,
        b = be),
        (ve !== S || ze !== w || pe !== B || Be !== z) && (r.blendFuncSeparate(K[ve], K[ze], K[pe], K[Be]),
        S = ve,
        w = ze,
        B = pe,
        z = Be),
        (Ye.equals(I) === !1 || ut !== H) && (r.blendColor(Ye.r, Ye.g, Ye.b, ut),
        I.copy(Ye),
        H = ut),
        A = j,
        P = !1
    }
    function V(j, Ce) {
        j.side === $t ? le(r.CULL_FACE) : ce(r.CULL_FACE);
        let ve = j.side === Vt;
        Ce && (ve = !ve),
        W(ve),
        j.blending === Bi && j.transparent === !1 ? x(ei) : x(j.blending, j.blendEquation, j.blendSrc, j.blendDst, j.blendEquationAlpha, j.blendSrcAlpha, j.blendDstAlpha, j.blendColor, j.blendAlpha, j.premultipliedAlpha),
        o.setFunc(j.depthFunc),
        o.setTest(j.depthTest),
        o.setMask(j.depthWrite),
        s.setMask(j.colorWrite);
        const ze = j.stencilWrite;
        a.setTest(ze),
        ze && (a.setMask(j.stencilWriteMask),
        a.setFunc(j.stencilFunc, j.stencilRef, j.stencilFuncMask),
        a.setOp(j.stencilFail, j.stencilZFail, j.stencilZPass)),
        me(j.polygonOffset, j.polygonOffsetFactor, j.polygonOffsetUnits),
        j.alphaToCoverage === !0 ? ce(r.SAMPLE_ALPHA_TO_COVERAGE) : le(r.SAMPLE_ALPHA_TO_COVERAGE)
    }
    function W(j) {
        T !== j && (j ? r.frontFace(r.CW) : r.frontFace(r.CCW),
        T = j)
    }
    function oe(j) {
        j !== vh ? (ce(r.CULL_FACE),
        j !== _ && (j === wc ? r.cullFace(r.BACK) : j === xh ? r.cullFace(r.FRONT) : r.cullFace(r.FRONT_AND_BACK))) : le(r.CULL_FACE),
        _ = j
    }
    function $(j) {
        j !== re && (O && r.lineWidth(j),
        re = j)
    }
    function me(j, Ce, ve) {
        j ? (ce(r.POLYGON_OFFSET_FILL),
        (k !== Ce || U !== ve) && (r.polygonOffset(Ce, ve),
        k = Ce,
        U = ve)) : le(r.POLYGON_OFFSET_FILL)
    }
    function he(j) {
        j ? ce(r.SCISSOR_TEST) : le(r.SCISSOR_TEST)
    }
    function ge(j) {
        j === void 0 && (j = r.TEXTURE0 + F - 1),
        L !== j && (r.activeTexture(j),
        L = j)
    }
    function De(j, Ce, ve) {
        ve === void 0 && (L === null ? ve = r.TEXTURE0 + F - 1 : ve = L);
        let ze = R[ve];
        ze === void 0 && (ze = {
            type: void 0,
            texture: void 0
        },
        R[ve] = ze),
        (ze.type !== j || ze.texture !== Ce) && (L !== ve && (r.activeTexture(ve),
        L = ve),
        r.bindTexture(j, Ce || ae[j]),
        ze.type = j,
        ze.texture = Ce)
    }
    function N() {
        const j = R[L];
        j !== void 0 && j.type !== void 0 && (r.bindTexture(j.type, null),
        j.type = void 0,
        j.texture = void 0)
    }
    function M() {
        try {
            r.compressedTexImage2D(...arguments)
        } catch (j) {
            console.error("THREE.WebGLState:", j)
        }
    }
    function q() {
        try {
            r.compressedTexImage3D(...arguments)
        } catch (j) {
            console.error("THREE.WebGLState:", j)
        }
    }
    function J() {
        try {
            r.texSubImage2D(...arguments)
        } catch (j) {
            console.error("THREE.WebGLState:", j)
        }
    }
    function ee() {
        try {
            r.texSubImage3D(...arguments)
        } catch (j) {
            console.error("THREE.WebGLState:", j)
        }
    }
    function te() {
        try {
            r.compressedTexSubImage2D(...arguments)
        } catch (j) {
            console.error("THREE.WebGLState:", j)
        }
    }
    function we() {
        try {
            r.compressedTexSubImage3D(...arguments)
        } catch (j) {
            console.error("THREE.WebGLState:", j)
        }
    }
    function de() {
        try {
            r.texStorage2D(...arguments)
        } catch (j) {
            console.error("THREE.WebGLState:", j)
        }
    }
    function Ee() {
        try {
            r.texStorage3D(...arguments)
        } catch (j) {
            console.error("THREE.WebGLState:", j)
        }
    }
    function Pe() {
        try {
            r.texImage2D(...arguments)
        } catch (j) {
            console.error("THREE.WebGLState:", j)
        }
    }
    function fe() {
        try {
            r.texImage3D(...arguments)
        } catch (j) {
            console.error("THREE.WebGLState:", j)
        }
    }
    function Ne(j) {
        ue.equals(j) === !1 && (r.scissor(j.x, j.y, j.z, j.w),
        ue.copy(j))
    }
    function _e(j) {
        X.equals(j) === !1 && (r.viewport(j.x, j.y, j.z, j.w),
        X.copy(j))
    }
    function Ue(j, Ce) {
        let ve = l.get(Ce);
        ve === void 0 && (ve = new WeakMap,
        l.set(Ce, ve));
        let ze = ve.get(j);
        ze === void 0 && (ze = r.getUniformBlockIndex(Ce, j.name),
        ve.set(j, ze))
    }
    function Le(j, Ce) {
        const ze = l.get(Ce).get(j);
        c.get(Ce) !== ze && (r.uniformBlockBinding(Ce, ze, j.__bindingPointIndex),
        c.set(Ce, ze))
    }
    function ke() {
        r.disable(r.BLEND),
        r.disable(r.CULL_FACE),
        r.disable(r.DEPTH_TEST),
        r.disable(r.POLYGON_OFFSET_FILL),
        r.disable(r.SCISSOR_TEST),
        r.disable(r.STENCIL_TEST),
        r.disable(r.SAMPLE_ALPHA_TO_COVERAGE),
        r.blendEquation(r.FUNC_ADD),
        r.blendFunc(r.ONE, r.ZERO),
        r.blendFuncSeparate(r.ONE, r.ZERO, r.ONE, r.ZERO),
        r.blendColor(0, 0, 0, 0),
        r.colorMask(!0, !0, !0, !0),
        r.clearColor(0, 0, 0, 0),
        r.depthMask(!0),
        r.depthFunc(r.LESS),
        o.setReversed(!1),
        r.clearDepth(1),
        r.stencilMask(4294967295),
        r.stencilFunc(r.ALWAYS, 0, 4294967295),
        r.stencilOp(r.KEEP, r.KEEP, r.KEEP),
        r.clearStencil(0),
        r.cullFace(r.BACK),
        r.frontFace(r.CCW),
        r.polygonOffset(0, 0),
        r.activeTexture(r.TEXTURE0),
        r.bindFramebuffer(r.FRAMEBUFFER, null),
        r.bindFramebuffer(r.DRAW_FRAMEBUFFER, null),
        r.bindFramebuffer(r.READ_FRAMEBUFFER, null),
        r.useProgram(null),
        r.lineWidth(1),
        r.scissor(0, 0, r.canvas.width, r.canvas.height),
        r.viewport(0, 0, r.canvas.width, r.canvas.height),
        u = {},
        L = null,
        R = {},
        h = {},
        d = new WeakMap,
        f = [],
        m = null,
        g = !1,
        A = null,
        p = null,
        S = null,
        w = null,
        b = null,
        B = null,
        z = null,
        I = new Ge(0,0,0),
        H = 0,
        P = !1,
        T = null,
        _ = null,
        re = null,
        k = null,
        U = null,
        ue.set(0, 0, r.canvas.width, r.canvas.height),
        X.set(0, 0, r.canvas.width, r.canvas.height),
        s.reset(),
        o.reset(),
        a.reset()
    }
    return {
        buffers: {
            color: s,
            depth: o,
            stencil: a
        },
        enable: ce,
        disable: le,
        bindFramebuffer: xe,
        drawBuffers: ye,
        useProgram: Te,
        setBlending: x,
        setMaterial: V,
        setFlipSided: W,
        setCullFace: oe,
        setLineWidth: $,
        setPolygonOffset: me,
        setScissorTest: he,
        activeTexture: ge,
        bindTexture: De,
        unbindTexture: N,
        compressedTexImage2D: M,
        compressedTexImage3D: q,
        texImage2D: Pe,
        texImage3D: fe,
        updateUBOMapping: Ue,
        uniformBlockBinding: Le,
        texStorage2D: de,
        texStorage3D: Ee,
        texSubImage2D: J,
        texSubImage3D: ee,
        compressedTexSubImage2D: te,
        compressedTexSubImage3D: we,
        scissor: Ne,
        viewport: _e,
        reset: ke
    }
}
function Zv(r, e, t, n, i, s, o) {
    const a = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null
      , c = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent)
      , l = new Ae
      , u = new WeakMap;
    let h;
    const d = new WeakMap;
    let f = !1;
    try {
        f = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1,1).getContext("2d") !== null
    } catch {}
    function m(N, M) {
        return f ? new OffscreenCanvas(N,M) : Ns("canvas")
    }
    function g(N, M, q) {
        let J = 1;
        const ee = De(N);
        if ((ee.width > q || ee.height > q) && (J = q / Math.max(ee.width, ee.height)),
        J < 1)
            if (typeof HTMLImageElement < "u" && N instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && N instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && N instanceof ImageBitmap || typeof VideoFrame < "u" && N instanceof VideoFrame) {
                const te = Math.floor(J * ee.width)
                  , we = Math.floor(J * ee.height);
                h === void 0 && (h = m(te, we));
                const de = M ? m(te, we) : h;
                return de.width = te,
                de.height = we,
                de.getContext("2d").drawImage(N, 0, 0, te, we),
                console.warn("THREE.WebGLRenderer: Texture has been resized from (" + ee.width + "x" + ee.height + ") to (" + te + "x" + we + ")."),
                de
            } else
                return "data"in N && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + ee.width + "x" + ee.height + ")."),
                N;
        return N
    }
    function A(N) {
        return N.generateMipmaps
    }
    function p(N) {
        r.generateMipmap(N)
    }
    function S(N) {
        return N.isWebGLCubeRenderTarget ? r.TEXTURE_CUBE_MAP : N.isWebGL3DRenderTarget ? r.TEXTURE_3D : N.isWebGLArrayRenderTarget || N.isCompressedArrayTexture ? r.TEXTURE_2D_ARRAY : r.TEXTURE_2D
    }
    function w(N, M, q, J, ee=!1) {
        if (N !== null) {
            if (r[N] !== void 0)
                return r[N];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + N + "'")
        }
        let te = M;
        if (M === r.RED && (q === r.FLOAT && (te = r.R32F),
        q === r.HALF_FLOAT && (te = r.R16F),
        q === r.UNSIGNED_BYTE && (te = r.R8)),
        M === r.RED_INTEGER && (q === r.UNSIGNED_BYTE && (te = r.R8UI),
        q === r.UNSIGNED_SHORT && (te = r.R16UI),
        q === r.UNSIGNED_INT && (te = r.R32UI),
        q === r.BYTE && (te = r.R8I),
        q === r.SHORT && (te = r.R16I),
        q === r.INT && (te = r.R32I)),
        M === r.RG && (q === r.FLOAT && (te = r.RG32F),
        q === r.HALF_FLOAT && (te = r.RG16F),
        q === r.UNSIGNED_BYTE && (te = r.RG8)),
        M === r.RG_INTEGER && (q === r.UNSIGNED_BYTE && (te = r.RG8UI),
        q === r.UNSIGNED_SHORT && (te = r.RG16UI),
        q === r.UNSIGNED_INT && (te = r.RG32UI),
        q === r.BYTE && (te = r.RG8I),
        q === r.SHORT && (te = r.RG16I),
        q === r.INT && (te = r.RG32I)),
        M === r.RGB_INTEGER && (q === r.UNSIGNED_BYTE && (te = r.RGB8UI),
        q === r.UNSIGNED_SHORT && (te = r.RGB16UI),
        q === r.UNSIGNED_INT && (te = r.RGB32UI),
        q === r.BYTE && (te = r.RGB8I),
        q === r.SHORT && (te = r.RGB16I),
        q === r.INT && (te = r.RGB32I)),
        M === r.RGBA_INTEGER && (q === r.UNSIGNED_BYTE && (te = r.RGBA8UI),
        q === r.UNSIGNED_SHORT && (te = r.RGBA16UI),
        q === r.UNSIGNED_INT && (te = r.RGBA32UI),
        q === r.BYTE && (te = r.RGBA8I),
        q === r.SHORT && (te = r.RGBA16I),
        q === r.INT && (te = r.RGBA32I)),
        M === r.RGB && q === r.UNSIGNED_INT_5_9_9_9_REV && (te = r.RGB9_E5),
        M === r.RGBA) {
            const we = ee ? _r : et.getTransfer(J);
            q === r.FLOAT && (te = r.RGBA32F),
            q === r.HALF_FLOAT && (te = r.RGBA16F),
            q === r.UNSIGNED_BYTE && (te = we === at ? r.SRGB8_ALPHA8 : r.RGBA8),
            q === r.UNSIGNED_SHORT_4_4_4_4 && (te = r.RGBA4),
            q === r.UNSIGNED_SHORT_5_5_5_1 && (te = r.RGB5_A1)
        }
        return (te === r.R16F || te === r.R32F || te === r.RG16F || te === r.RG32F || te === r.RGBA16F || te === r.RGBA32F) && e.get("EXT_color_buffer_float"),
        te
    }
    function b(N, M) {
        let q;
        return N ? M === null || M === Ai || M === Ps ? q = r.DEPTH24_STENCIL8 : M === dn ? q = r.DEPTH32F_STENCIL8 : M === Es && (q = r.DEPTH24_STENCIL8,
        console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : M === null || M === Ai || M === Ps ? q = r.DEPTH_COMPONENT24 : M === dn ? q = r.DEPTH_COMPONENT32F : M === Es && (q = r.DEPTH_COMPONENT16),
        q
    }
    function B(N, M) {
        return A(N) === !0 || N.isFramebufferTexture && N.minFilter !== _t && N.minFilter !== Yt ? Math.log2(Math.max(M.width, M.height)) + 1 : N.mipmaps !== void 0 && N.mipmaps.length > 0 ? N.mipmaps.length : N.isCompressedTexture && Array.isArray(N.image) ? M.mipmaps.length : 1
    }
    function z(N) {
        const M = N.target;
        M.removeEventListener("dispose", z),
        H(M),
        M.isVideoTexture && u.delete(M)
    }
    function I(N) {
        const M = N.target;
        M.removeEventListener("dispose", I),
        T(M)
    }
    function H(N) {
        const M = n.get(N);
        if (M.__webglInit === void 0)
            return;
        const q = N.source
          , J = d.get(q);
        if (J) {
            const ee = J[M.__cacheKey];
            ee.usedTimes--,
            ee.usedTimes === 0 && P(N),
            Object.keys(J).length === 0 && d.delete(q)
        }
        n.remove(N)
    }
    function P(N) {
        const M = n.get(N);
        r.deleteTexture(M.__webglTexture);
        const q = N.source
          , J = d.get(q);
        delete J[M.__cacheKey],
        o.memory.textures--
    }
    function T(N) {
        const M = n.get(N);
        if (N.depthTexture && (N.depthTexture.dispose(),
        n.remove(N.depthTexture)),
        N.isWebGLCubeRenderTarget)
            for (let J = 0; J < 6; J++) {
                if (Array.isArray(M.__webglFramebuffer[J]))
                    for (let ee = 0; ee < M.__webglFramebuffer[J].length; ee++)
                        r.deleteFramebuffer(M.__webglFramebuffer[J][ee]);
                else
                    r.deleteFramebuffer(M.__webglFramebuffer[J]);
                M.__webglDepthbuffer && r.deleteRenderbuffer(M.__webglDepthbuffer[J])
            }
        else {
            if (Array.isArray(M.__webglFramebuffer))
                for (let J = 0; J < M.__webglFramebuffer.length; J++)
                    r.deleteFramebuffer(M.__webglFramebuffer[J]);
            else
                r.deleteFramebuffer(M.__webglFramebuffer);
            if (M.__webglDepthbuffer && r.deleteRenderbuffer(M.__webglDepthbuffer),
            M.__webglMultisampledFramebuffer && r.deleteFramebuffer(M.__webglMultisampledFramebuffer),
            M.__webglColorRenderbuffer)
                for (let J = 0; J < M.__webglColorRenderbuffer.length; J++)
                    M.__webglColorRenderbuffer[J] && r.deleteRenderbuffer(M.__webglColorRenderbuffer[J]);
            M.__webglDepthRenderbuffer && r.deleteRenderbuffer(M.__webglDepthRenderbuffer)
        }
        const q = N.textures;
        for (let J = 0, ee = q.length; J < ee; J++) {
            const te = n.get(q[J]);
            te.__webglTexture && (r.deleteTexture(te.__webglTexture),
            o.memory.textures--),
            n.remove(q[J])
        }
        n.remove(N)
    }
    let _ = 0;
    function re() {
        _ = 0
    }
    function k() {
        const N = _;
        return N >= i.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + N + " texture units while this GPU supports only " + i.maxTextures),
        _ += 1,
        N
    }
    function U(N) {
        const M = [];
        return M.push(N.wrapS),
        M.push(N.wrapT),
        M.push(N.wrapR || 0),
        M.push(N.magFilter),
        M.push(N.minFilter),
        M.push(N.anisotropy),
        M.push(N.internalFormat),
        M.push(N.format),
        M.push(N.type),
        M.push(N.generateMipmaps),
        M.push(N.premultiplyAlpha),
        M.push(N.flipY),
        M.push(N.unpackAlignment),
        M.push(N.colorSpace),
        M.join()
    }
    function F(N, M) {
        const q = n.get(N);
        if (N.isVideoTexture && he(N),
        N.isRenderTargetTexture === !1 && N.version > 0 && q.__version !== N.version) {
            const J = N.image;
            if (J === null)
                console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else if (J.complete === !1)
                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
                ae(q, N, M);
                return
            }
        }
        t.bindTexture(r.TEXTURE_2D, q.__webglTexture, r.TEXTURE0 + M)
    }
    function O(N, M) {
        const q = n.get(N);
        if (N.version > 0 && q.__version !== N.version) {
            ae(q, N, M);
            return
        }
        t.bindTexture(r.TEXTURE_2D_ARRAY, q.__webglTexture, r.TEXTURE0 + M)
    }
    function y(N, M) {
        const q = n.get(N);
        if (N.version > 0 && q.__version !== N.version) {
            ae(q, N, M);
            return
        }
        t.bindTexture(r.TEXTURE_3D, q.__webglTexture, r.TEXTURE0 + M)
    }
    function v(N, M) {
        const q = n.get(N);
        if (N.version > 0 && q.__version !== N.version) {
            ce(q, N, M);
            return
        }
        t.bindTexture(r.TEXTURE_CUBE_MAP, q.__webglTexture, r.TEXTURE0 + M)
    }
    const L = {
        [ki]: r.REPEAT,
        [Kn]: r.CLAMP_TO_EDGE,
        [Fr]: r.MIRRORED_REPEAT
    }
      , R = {
        [_t]: r.NEAREST,
        [mu]: r.NEAREST_MIPMAP_NEAREST,
        [As]: r.NEAREST_MIPMAP_LINEAR,
        [Yt]: r.LINEAR,
        [Cr]: r.LINEAR_MIPMAP_NEAREST,
        [In]: r.LINEAR_MIPMAP_LINEAR
    }
      , C = {
        [ed]: r.NEVER,
        [od]: r.ALWAYS,
        [td]: r.LESS,
        [Su]: r.LEQUAL,
        [nd]: r.EQUAL,
        [rd]: r.GEQUAL,
        [id]: r.GREATER,
        [sd]: r.NOTEQUAL
    };
    function Y(N, M) {
        if (M.type === dn && e.has("OES_texture_float_linear") === !1 && (M.magFilter === Yt || M.magFilter === Cr || M.magFilter === As || M.magFilter === In || M.minFilter === Yt || M.minFilter === Cr || M.minFilter === As || M.minFilter === In) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),
        r.texParameteri(N, r.TEXTURE_WRAP_S, L[M.wrapS]),
        r.texParameteri(N, r.TEXTURE_WRAP_T, L[M.wrapT]),
        (N === r.TEXTURE_3D || N === r.TEXTURE_2D_ARRAY) && r.texParameteri(N, r.TEXTURE_WRAP_R, L[M.wrapR]),
        r.texParameteri(N, r.TEXTURE_MAG_FILTER, R[M.magFilter]),
        r.texParameteri(N, r.TEXTURE_MIN_FILTER, R[M.minFilter]),
        M.compareFunction && (r.texParameteri(N, r.TEXTURE_COMPARE_MODE, r.COMPARE_REF_TO_TEXTURE),
        r.texParameteri(N, r.TEXTURE_COMPARE_FUNC, C[M.compareFunction])),
        e.has("EXT_texture_filter_anisotropic") === !0) {
            if (M.magFilter === _t || M.minFilter !== As && M.minFilter !== In || M.type === dn && e.has("OES_texture_float_linear") === !1)
                return;
            if (M.anisotropy > 1 || n.get(M).__currentAnisotropy) {
                const q = e.get("EXT_texture_filter_anisotropic");
                r.texParameterf(N, q.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(M.anisotropy, i.getMaxAnisotropy())),
                n.get(M).__currentAnisotropy = M.anisotropy
            }
        }
    }
    function ue(N, M) {
        let q = !1;
        N.__webglInit === void 0 && (N.__webglInit = !0,
        M.addEventListener("dispose", z));
        const J = M.source;
        let ee = d.get(J);
        ee === void 0 && (ee = {},
        d.set(J, ee));
        const te = U(M);
        if (te !== N.__cacheKey) {
            ee[te] === void 0 && (ee[te] = {
                texture: r.createTexture(),
                usedTimes: 0
            },
            o.memory.textures++,
            q = !0),
            ee[te].usedTimes++;
            const we = ee[N.__cacheKey];
            we !== void 0 && (ee[N.__cacheKey].usedTimes--,
            we.usedTimes === 0 && P(M)),
            N.__cacheKey = te,
            N.__webglTexture = ee[te].texture
        }
        return q
    }
    function X(N, M, q) {
        return Math.floor(Math.floor(N / q) / M)
    }
    function ne(N, M, q, J) {
        const te = N.updateRanges;
        if (te.length === 0)
            t.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, M.width, M.height, q, J, M.data);
        else {
            te.sort( (fe, Ne) => fe.start - Ne.start);
            let we = 0;
            for (let fe = 1; fe < te.length; fe++) {
                const Ne = te[we]
                  , _e = te[fe]
                  , Ue = Ne.start + Ne.count
                  , Le = X(_e.start, M.width, 4)
                  , ke = X(Ne.start, M.width, 4);
                _e.start <= Ue + 1 && Le === ke && X(_e.start + _e.count - 1, M.width, 4) === Le ? Ne.count = Math.max(Ne.count, _e.start + _e.count - Ne.start) : (++we,
                te[we] = _e)
            }
            te.length = we + 1;
            const de = r.getParameter(r.UNPACK_ROW_LENGTH)
              , Ee = r.getParameter(r.UNPACK_SKIP_PIXELS)
              , Pe = r.getParameter(r.UNPACK_SKIP_ROWS);
            r.pixelStorei(r.UNPACK_ROW_LENGTH, M.width);
            for (let fe = 0, Ne = te.length; fe < Ne; fe++) {
                const _e = te[fe]
                  , Ue = Math.floor(_e.start / 4)
                  , Le = Math.ceil(_e.count / 4)
                  , ke = Ue % M.width
                  , j = Math.floor(Ue / M.width)
                  , Ce = Le
                  , ve = 1;
                r.pixelStorei(r.UNPACK_SKIP_PIXELS, ke),
                r.pixelStorei(r.UNPACK_SKIP_ROWS, j),
                t.texSubImage2D(r.TEXTURE_2D, 0, ke, j, Ce, ve, q, J, M.data)
            }
            N.clearUpdateRanges(),
            r.pixelStorei(r.UNPACK_ROW_LENGTH, de),
            r.pixelStorei(r.UNPACK_SKIP_PIXELS, Ee),
            r.pixelStorei(r.UNPACK_SKIP_ROWS, Pe)
        }
    }
    function ae(N, M, q) {
        let J = r.TEXTURE_2D;
        (M.isDataArrayTexture || M.isCompressedArrayTexture) && (J = r.TEXTURE_2D_ARRAY),
        M.isData3DTexture && (J = r.TEXTURE_3D);
        const ee = ue(N, M)
          , te = M.source;
        t.bindTexture(J, N.__webglTexture, r.TEXTURE0 + q);
        const we = n.get(te);
        if (te.version !== we.__version || ee === !0) {
            t.activeTexture(r.TEXTURE0 + q);
            const de = et.getPrimaries(et.workingColorSpace)
              , Ee = M.colorSpace === Zn ? null : et.getPrimaries(M.colorSpace)
              , Pe = M.colorSpace === Zn || de === Ee ? r.NONE : r.BROWSER_DEFAULT_WEBGL;
            r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, M.flipY),
            r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, M.premultiplyAlpha),
            r.pixelStorei(r.UNPACK_ALIGNMENT, M.unpackAlignment),
            r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, Pe);
            let fe = g(M.image, !1, i.maxTextureSize);
            fe = ge(M, fe);
            const Ne = s.convert(M.format, M.colorSpace)
              , _e = s.convert(M.type);
            let Ue = w(M.internalFormat, Ne, _e, M.colorSpace, M.isVideoTexture);
            Y(J, M);
            let Le;
            const ke = M.mipmaps
              , j = M.isVideoTexture !== !0
              , Ce = we.__version === void 0 || ee === !0
              , ve = te.dataReady
              , ze = B(M, fe);
            if (M.isDepthTexture)
                Ue = b(M.format === Cs, M.type),
                Ce && (j ? t.texStorage2D(r.TEXTURE_2D, 1, Ue, fe.width, fe.height) : t.texImage2D(r.TEXTURE_2D, 0, Ue, fe.width, fe.height, 0, Ne, _e, null));
            else if (M.isDataTexture)
                if (ke.length > 0) {
                    j && Ce && t.texStorage2D(r.TEXTURE_2D, ze, Ue, ke[0].width, ke[0].height);
                    for (let be = 0, pe = ke.length; be < pe; be++)
                        Le = ke[be],
                        j ? ve && t.texSubImage2D(r.TEXTURE_2D, be, 0, 0, Le.width, Le.height, Ne, _e, Le.data) : t.texImage2D(r.TEXTURE_2D, be, Ue, Le.width, Le.height, 0, Ne, _e, Le.data);
                    M.generateMipmaps = !1
                } else
                    j ? (Ce && t.texStorage2D(r.TEXTURE_2D, ze, Ue, fe.width, fe.height),
                    ve && ne(M, fe, Ne, _e)) : t.texImage2D(r.TEXTURE_2D, 0, Ue, fe.width, fe.height, 0, Ne, _e, fe.data);
            else if (M.isCompressedTexture)
                if (M.isCompressedArrayTexture) {
                    j && Ce && t.texStorage3D(r.TEXTURE_2D_ARRAY, ze, Ue, ke[0].width, ke[0].height, fe.depth);
                    for (let be = 0, pe = ke.length; be < pe; be++)
                        if (Le = ke[be],
                        M.format !== tn)
                            if (Ne !== null)
                                if (j) {
                                    if (ve)
                                        if (M.layerUpdates.size > 0) {
                                            const Be = El(Le.width, Le.height, M.format, M.type);
                                            for (const Ye of M.layerUpdates) {
                                                const ut = Le.data.subarray(Ye * Be / Le.data.BYTES_PER_ELEMENT, (Ye + 1) * Be / Le.data.BYTES_PER_ELEMENT);
                                                t.compressedTexSubImage3D(r.TEXTURE_2D_ARRAY, be, 0, 0, Ye, Le.width, Le.height, 1, Ne, ut)
                                            }
                                            M.clearLayerUpdates()
                                        } else
                                            t.compressedTexSubImage3D(r.TEXTURE_2D_ARRAY, be, 0, 0, 0, Le.width, Le.height, fe.depth, Ne, Le.data)
                                } else
                                    t.compressedTexImage3D(r.TEXTURE_2D_ARRAY, be, Ue, Le.width, Le.height, fe.depth, 0, Le.data, 0, 0);
                            else
                                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                        else
                            j ? ve && t.texSubImage3D(r.TEXTURE_2D_ARRAY, be, 0, 0, 0, Le.width, Le.height, fe.depth, Ne, _e, Le.data) : t.texImage3D(r.TEXTURE_2D_ARRAY, be, Ue, Le.width, Le.height, fe.depth, 0, Ne, _e, Le.data)
                } else {
                    j && Ce && t.texStorage2D(r.TEXTURE_2D, ze, Ue, ke[0].width, ke[0].height);
                    for (let be = 0, pe = ke.length; be < pe; be++)
                        Le = ke[be],
                        M.format !== tn ? Ne !== null ? j ? ve && t.compressedTexSubImage2D(r.TEXTURE_2D, be, 0, 0, Le.width, Le.height, Ne, Le.data) : t.compressedTexImage2D(r.TEXTURE_2D, be, Ue, Le.width, Le.height, 0, Le.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : j ? ve && t.texSubImage2D(r.TEXTURE_2D, be, 0, 0, Le.width, Le.height, Ne, _e, Le.data) : t.texImage2D(r.TEXTURE_2D, be, Ue, Le.width, Le.height, 0, Ne, _e, Le.data)
                }
            else if (M.isDataArrayTexture)
                if (j) {
                    if (Ce && t.texStorage3D(r.TEXTURE_2D_ARRAY, ze, Ue, fe.width, fe.height, fe.depth),
                    ve)
                        if (M.layerUpdates.size > 0) {
                            const be = El(fe.width, fe.height, M.format, M.type);
                            for (const pe of M.layerUpdates) {
                                const Be = fe.data.subarray(pe * be / fe.data.BYTES_PER_ELEMENT, (pe + 1) * be / fe.data.BYTES_PER_ELEMENT);
                                t.texSubImage3D(r.TEXTURE_2D_ARRAY, 0, 0, 0, pe, fe.width, fe.height, 1, Ne, _e, Be)
                            }
                            M.clearLayerUpdates()
                        } else
                            t.texSubImage3D(r.TEXTURE_2D_ARRAY, 0, 0, 0, 0, fe.width, fe.height, fe.depth, Ne, _e, fe.data)
                } else
                    t.texImage3D(r.TEXTURE_2D_ARRAY, 0, Ue, fe.width, fe.height, fe.depth, 0, Ne, _e, fe.data);
            else if (M.isData3DTexture)
                j ? (Ce && t.texStorage3D(r.TEXTURE_3D, ze, Ue, fe.width, fe.height, fe.depth),
                ve && t.texSubImage3D(r.TEXTURE_3D, 0, 0, 0, 0, fe.width, fe.height, fe.depth, Ne, _e, fe.data)) : t.texImage3D(r.TEXTURE_3D, 0, Ue, fe.width, fe.height, fe.depth, 0, Ne, _e, fe.data);
            else if (M.isFramebufferTexture) {
                if (Ce)
                    if (j)
                        t.texStorage2D(r.TEXTURE_2D, ze, Ue, fe.width, fe.height);
                    else {
                        let be = fe.width
                          , pe = fe.height;
                        for (let Be = 0; Be < ze; Be++)
                            t.texImage2D(r.TEXTURE_2D, Be, Ue, be, pe, 0, Ne, _e, null),
                            be >>= 1,
                            pe >>= 1
                    }
            } else if (ke.length > 0) {
                if (j && Ce) {
                    const be = De(ke[0]);
                    t.texStorage2D(r.TEXTURE_2D, ze, Ue, be.width, be.height)
                }
                for (let be = 0, pe = ke.length; be < pe; be++)
                    Le = ke[be],
                    j ? ve && t.texSubImage2D(r.TEXTURE_2D, be, 0, 0, Ne, _e, Le) : t.texImage2D(r.TEXTURE_2D, be, Ue, Ne, _e, Le);
                M.generateMipmaps = !1
            } else if (j) {
                if (Ce) {
                    const be = De(fe);
                    t.texStorage2D(r.TEXTURE_2D, ze, Ue, be.width, be.height)
                }
                ve && t.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, Ne, _e, fe)
            } else
                t.texImage2D(r.TEXTURE_2D, 0, Ue, Ne, _e, fe);
            A(M) && p(J),
            we.__version = te.version,
            M.onUpdate && M.onUpdate(M)
        }
        N.__version = M.version
    }
    function ce(N, M, q) {
        if (M.image.length !== 6)
            return;
        const J = ue(N, M)
          , ee = M.source;
        t.bindTexture(r.TEXTURE_CUBE_MAP, N.__webglTexture, r.TEXTURE0 + q);
        const te = n.get(ee);
        if (ee.version !== te.__version || J === !0) {
            t.activeTexture(r.TEXTURE0 + q);
            const we = et.getPrimaries(et.workingColorSpace)
              , de = M.colorSpace === Zn ? null : et.getPrimaries(M.colorSpace)
              , Ee = M.colorSpace === Zn || we === de ? r.NONE : r.BROWSER_DEFAULT_WEBGL;
            r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, M.flipY),
            r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, M.premultiplyAlpha),
            r.pixelStorei(r.UNPACK_ALIGNMENT, M.unpackAlignment),
            r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ee);
            const Pe = M.isCompressedTexture || M.image[0].isCompressedTexture
              , fe = M.image[0] && M.image[0].isDataTexture
              , Ne = [];
            for (let pe = 0; pe < 6; pe++)
                !Pe && !fe ? Ne[pe] = g(M.image[pe], !0, i.maxCubemapSize) : Ne[pe] = fe ? M.image[pe].image : M.image[pe],
                Ne[pe] = ge(M, Ne[pe]);
            const _e = Ne[0]
              , Ue = s.convert(M.format, M.colorSpace)
              , Le = s.convert(M.type)
              , ke = w(M.internalFormat, Ue, Le, M.colorSpace)
              , j = M.isVideoTexture !== !0
              , Ce = te.__version === void 0 || J === !0
              , ve = ee.dataReady;
            let ze = B(M, _e);
            Y(r.TEXTURE_CUBE_MAP, M);
            let be;
            if (Pe) {
                j && Ce && t.texStorage2D(r.TEXTURE_CUBE_MAP, ze, ke, _e.width, _e.height);
                for (let pe = 0; pe < 6; pe++) {
                    be = Ne[pe].mipmaps;
                    for (let Be = 0; Be < be.length; Be++) {
                        const Ye = be[Be];
                        M.format !== tn ? Ue !== null ? j ? ve && t.compressedTexSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + pe, Be, 0, 0, Ye.width, Ye.height, Ue, Ye.data) : t.compressedTexImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + pe, Be, ke, Ye.width, Ye.height, 0, Ye.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : j ? ve && t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + pe, Be, 0, 0, Ye.width, Ye.height, Ue, Le, Ye.data) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + pe, Be, ke, Ye.width, Ye.height, 0, Ue, Le, Ye.data)
                    }
                }
            } else {
                if (be = M.mipmaps,
                j && Ce) {
                    be.length > 0 && ze++;
                    const pe = De(Ne[0]);
                    t.texStorage2D(r.TEXTURE_CUBE_MAP, ze, ke, pe.width, pe.height)
                }
                for (let pe = 0; pe < 6; pe++)
                    if (fe) {
                        j ? ve && t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + pe, 0, 0, 0, Ne[pe].width, Ne[pe].height, Ue, Le, Ne[pe].data) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + pe, 0, ke, Ne[pe].width, Ne[pe].height, 0, Ue, Le, Ne[pe].data);
                        for (let Be = 0; Be < be.length; Be++) {
                            const ut = be[Be].image[pe].image;
                            j ? ve && t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + pe, Be + 1, 0, 0, ut.width, ut.height, Ue, Le, ut.data) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + pe, Be + 1, ke, ut.width, ut.height, 0, Ue, Le, ut.data)
                        }
                    } else {
                        j ? ve && t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + pe, 0, 0, 0, Ue, Le, Ne[pe]) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + pe, 0, ke, Ue, Le, Ne[pe]);
                        for (let Be = 0; Be < be.length; Be++) {
                            const Ye = be[Be];
                            j ? ve && t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + pe, Be + 1, 0, 0, Ue, Le, Ye.image[pe]) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + pe, Be + 1, ke, Ue, Le, Ye.image[pe])
                        }
                    }
            }
            A(M) && p(r.TEXTURE_CUBE_MAP),
            te.__version = ee.version,
            M.onUpdate && M.onUpdate(M)
        }
        N.__version = M.version
    }
    function le(N, M, q, J, ee, te) {
        const we = s.convert(q.format, q.colorSpace)
          , de = s.convert(q.type)
          , Ee = w(q.internalFormat, we, de, q.colorSpace)
          , Pe = n.get(M)
          , fe = n.get(q);
        if (fe.__renderTarget = M,
        !Pe.__hasExternalTextures) {
            const Ne = Math.max(1, M.width >> te)
              , _e = Math.max(1, M.height >> te);
            ee === r.TEXTURE_3D || ee === r.TEXTURE_2D_ARRAY ? t.texImage3D(ee, te, Ee, Ne, _e, M.depth, 0, we, de, null) : t.texImage2D(ee, te, Ee, Ne, _e, 0, we, de, null)
        }
        t.bindFramebuffer(r.FRAMEBUFFER, N),
        me(M) ? a.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, J, ee, fe.__webglTexture, 0, $(M)) : (ee === r.TEXTURE_2D || ee >= r.TEXTURE_CUBE_MAP_POSITIVE_X && ee <= r.TEXTURE_CUBE_MAP_NEGATIVE_Z) && r.framebufferTexture2D(r.FRAMEBUFFER, J, ee, fe.__webglTexture, te),
        t.bindFramebuffer(r.FRAMEBUFFER, null)
    }
    function xe(N, M, q) {
        if (r.bindRenderbuffer(r.RENDERBUFFER, N),
        M.depthBuffer) {
            const J = M.depthTexture
              , ee = J && J.isDepthTexture ? J.type : null
              , te = b(M.stencilBuffer, ee)
              , we = M.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT
              , de = $(M);
            me(M) ? a.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, de, te, M.width, M.height) : q ? r.renderbufferStorageMultisample(r.RENDERBUFFER, de, te, M.width, M.height) : r.renderbufferStorage(r.RENDERBUFFER, te, M.width, M.height),
            r.framebufferRenderbuffer(r.FRAMEBUFFER, we, r.RENDERBUFFER, N)
        } else {
            const J = M.textures;
            for (let ee = 0; ee < J.length; ee++) {
                const te = J[ee]
                  , we = s.convert(te.format, te.colorSpace)
                  , de = s.convert(te.type)
                  , Ee = w(te.internalFormat, we, de, te.colorSpace)
                  , Pe = $(M);
                q && me(M) === !1 ? r.renderbufferStorageMultisample(r.RENDERBUFFER, Pe, Ee, M.width, M.height) : me(M) ? a.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, Pe, Ee, M.width, M.height) : r.renderbufferStorage(r.RENDERBUFFER, Ee, M.width, M.height)
            }
        }
        r.bindRenderbuffer(r.RENDERBUFFER, null)
    }
    function ye(N, M) {
        if (M && M.isWebGLCubeRenderTarget)
            throw new Error("Depth Texture with cube render targets is not supported");
        if (t.bindFramebuffer(r.FRAMEBUFFER, N),
        !(M.depthTexture && M.depthTexture.isDepthTexture))
            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        const J = n.get(M.depthTexture);
        J.__renderTarget = M,
        (!J.__webglTexture || M.depthTexture.image.width !== M.width || M.depthTexture.image.height !== M.height) && (M.depthTexture.image.width = M.width,
        M.depthTexture.image.height = M.height,
        M.depthTexture.needsUpdate = !0),
        F(M.depthTexture, 0);
        const ee = J.__webglTexture
          , te = $(M);
        if (M.depthTexture.format === Ls)
            me(M) ? a.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, ee, 0, te) : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, ee, 0);
        else if (M.depthTexture.format === Cs)
            me(M) ? a.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, ee, 0, te) : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, ee, 0);
        else
            throw new Error("Unknown depthTexture format")
    }
    function Te(N) {
        const M = n.get(N)
          , q = N.isWebGLCubeRenderTarget === !0;
        if (M.__boundDepthTexture !== N.depthTexture) {
            const J = N.depthTexture;
            if (M.__depthDisposeCallback && M.__depthDisposeCallback(),
            J) {
                const ee = () => {
                    delete M.__boundDepthTexture,
                    delete M.__depthDisposeCallback,
                    J.removeEventListener("dispose", ee)
                }
                ;
                J.addEventListener("dispose", ee),
                M.__depthDisposeCallback = ee
            }
            M.__boundDepthTexture = J
        }
        if (N.depthTexture && !M.__autoAllocateDepthBuffer) {
            if (q)
                throw new Error("target.depthTexture not supported in Cube render targets");
            const J = N.texture.mipmaps;
            J && J.length > 0 ? ye(M.__webglFramebuffer[0], N) : ye(M.__webglFramebuffer, N)
        } else if (q) {
            M.__webglDepthbuffer = [];
            for (let J = 0; J < 6; J++)
                if (t.bindFramebuffer(r.FRAMEBUFFER, M.__webglFramebuffer[J]),
                M.__webglDepthbuffer[J] === void 0)
                    M.__webglDepthbuffer[J] = r.createRenderbuffer(),
                    xe(M.__webglDepthbuffer[J], N, !1);
                else {
                    const ee = N.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT
                      , te = M.__webglDepthbuffer[J];
                    r.bindRenderbuffer(r.RENDERBUFFER, te),
                    r.framebufferRenderbuffer(r.FRAMEBUFFER, ee, r.RENDERBUFFER, te)
                }
        } else {
            const J = N.texture.mipmaps;
            if (J && J.length > 0 ? t.bindFramebuffer(r.FRAMEBUFFER, M.__webglFramebuffer[0]) : t.bindFramebuffer(r.FRAMEBUFFER, M.__webglFramebuffer),
            M.__webglDepthbuffer === void 0)
                M.__webglDepthbuffer = r.createRenderbuffer(),
                xe(M.__webglDepthbuffer, N, !1);
            else {
                const ee = N.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT
                  , te = M.__webglDepthbuffer;
                r.bindRenderbuffer(r.RENDERBUFFER, te),
                r.framebufferRenderbuffer(r.FRAMEBUFFER, ee, r.RENDERBUFFER, te)
            }
        }
        t.bindFramebuffer(r.FRAMEBUFFER, null)
    }
    function G(N, M, q) {
        const J = n.get(N);
        M !== void 0 && le(J.__webglFramebuffer, N, N.texture, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, 0),
        q !== void 0 && Te(N)
    }
    function K(N) {
        const M = N.texture
          , q = n.get(N)
          , J = n.get(M);
        N.addEventListener("dispose", I);
        const ee = N.textures
          , te = N.isWebGLCubeRenderTarget === !0
          , we = ee.length > 1;
        if (we || (J.__webglTexture === void 0 && (J.__webglTexture = r.createTexture()),
        J.__version = M.version,
        o.memory.textures++),
        te) {
            q.__webglFramebuffer = [];
            for (let de = 0; de < 6; de++)
                if (M.mipmaps && M.mipmaps.length > 0) {
                    q.__webglFramebuffer[de] = [];
                    for (let Ee = 0; Ee < M.mipmaps.length; Ee++)
                        q.__webglFramebuffer[de][Ee] = r.createFramebuffer()
                } else
                    q.__webglFramebuffer[de] = r.createFramebuffer()
        } else {
            if (M.mipmaps && M.mipmaps.length > 0) {
                q.__webglFramebuffer = [];
                for (let de = 0; de < M.mipmaps.length; de++)
                    q.__webglFramebuffer[de] = r.createFramebuffer()
            } else
                q.__webglFramebuffer = r.createFramebuffer();
            if (we)
                for (let de = 0, Ee = ee.length; de < Ee; de++) {
                    const Pe = n.get(ee[de]);
                    Pe.__webglTexture === void 0 && (Pe.__webglTexture = r.createTexture(),
                    o.memory.textures++)
                }
            if (N.samples > 0 && me(N) === !1) {
                q.__webglMultisampledFramebuffer = r.createFramebuffer(),
                q.__webglColorRenderbuffer = [],
                t.bindFramebuffer(r.FRAMEBUFFER, q.__webglMultisampledFramebuffer);
                for (let de = 0; de < ee.length; de++) {
                    const Ee = ee[de];
                    q.__webglColorRenderbuffer[de] = r.createRenderbuffer(),
                    r.bindRenderbuffer(r.RENDERBUFFER, q.__webglColorRenderbuffer[de]);
                    const Pe = s.convert(Ee.format, Ee.colorSpace)
                      , fe = s.convert(Ee.type)
                      , Ne = w(Ee.internalFormat, Pe, fe, Ee.colorSpace, N.isXRRenderTarget === !0)
                      , _e = $(N);
                    r.renderbufferStorageMultisample(r.RENDERBUFFER, _e, Ne, N.width, N.height),
                    r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + de, r.RENDERBUFFER, q.__webglColorRenderbuffer[de])
                }
                r.bindRenderbuffer(r.RENDERBUFFER, null),
                N.depthBuffer && (q.__webglDepthRenderbuffer = r.createRenderbuffer(),
                xe(q.__webglDepthRenderbuffer, N, !0)),
                t.bindFramebuffer(r.FRAMEBUFFER, null)
            }
        }
        if (te) {
            t.bindTexture(r.TEXTURE_CUBE_MAP, J.__webglTexture),
            Y(r.TEXTURE_CUBE_MAP, M);
            for (let de = 0; de < 6; de++)
                if (M.mipmaps && M.mipmaps.length > 0)
                    for (let Ee = 0; Ee < M.mipmaps.length; Ee++)
                        le(q.__webglFramebuffer[de][Ee], N, M, r.COLOR_ATTACHMENT0, r.TEXTURE_CUBE_MAP_POSITIVE_X + de, Ee);
                else
                    le(q.__webglFramebuffer[de], N, M, r.COLOR_ATTACHMENT0, r.TEXTURE_CUBE_MAP_POSITIVE_X + de, 0);
            A(M) && p(r.TEXTURE_CUBE_MAP),
            t.unbindTexture()
        } else if (we) {
            for (let de = 0, Ee = ee.length; de < Ee; de++) {
                const Pe = ee[de]
                  , fe = n.get(Pe);
                t.bindTexture(r.TEXTURE_2D, fe.__webglTexture),
                Y(r.TEXTURE_2D, Pe),
                le(q.__webglFramebuffer, N, Pe, r.COLOR_ATTACHMENT0 + de, r.TEXTURE_2D, 0),
                A(Pe) && p(r.TEXTURE_2D)
            }
            t.unbindTexture()
        } else {
            let de = r.TEXTURE_2D;
            if ((N.isWebGL3DRenderTarget || N.isWebGLArrayRenderTarget) && (de = N.isWebGL3DRenderTarget ? r.TEXTURE_3D : r.TEXTURE_2D_ARRAY),
            t.bindTexture(de, J.__webglTexture),
            Y(de, M),
            M.mipmaps && M.mipmaps.length > 0)
                for (let Ee = 0; Ee < M.mipmaps.length; Ee++)
                    le(q.__webglFramebuffer[Ee], N, M, r.COLOR_ATTACHMENT0, de, Ee);
            else
                le(q.__webglFramebuffer, N, M, r.COLOR_ATTACHMENT0, de, 0);
            A(M) && p(de),
            t.unbindTexture()
        }
        N.depthBuffer && Te(N)
    }
    function x(N) {
        const M = N.textures;
        for (let q = 0, J = M.length; q < J; q++) {
            const ee = M[q];
            if (A(ee)) {
                const te = S(N)
                  , we = n.get(ee).__webglTexture;
                t.bindTexture(te, we),
                p(te),
                t.unbindTexture()
            }
        }
    }
    const V = []
      , W = [];
    function oe(N) {
        if (N.samples > 0) {
            if (me(N) === !1) {
                const M = N.textures
                  , q = N.width
                  , J = N.height;
                let ee = r.COLOR_BUFFER_BIT;
                const te = N.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT
                  , we = n.get(N)
                  , de = M.length > 1;
                if (de)
                    for (let Pe = 0; Pe < M.length; Pe++)
                        t.bindFramebuffer(r.FRAMEBUFFER, we.__webglMultisampledFramebuffer),
                        r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + Pe, r.RENDERBUFFER, null),
                        t.bindFramebuffer(r.FRAMEBUFFER, we.__webglFramebuffer),
                        r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0 + Pe, r.TEXTURE_2D, null, 0);
                t.bindFramebuffer(r.READ_FRAMEBUFFER, we.__webglMultisampledFramebuffer);
                const Ee = N.texture.mipmaps;
                Ee && Ee.length > 0 ? t.bindFramebuffer(r.DRAW_FRAMEBUFFER, we.__webglFramebuffer[0]) : t.bindFramebuffer(r.DRAW_FRAMEBUFFER, we.__webglFramebuffer);
                for (let Pe = 0; Pe < M.length; Pe++) {
                    if (N.resolveDepthBuffer && (N.depthBuffer && (ee |= r.DEPTH_BUFFER_BIT),
                    N.stencilBuffer && N.resolveStencilBuffer && (ee |= r.STENCIL_BUFFER_BIT)),
                    de) {
                        r.framebufferRenderbuffer(r.READ_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.RENDERBUFFER, we.__webglColorRenderbuffer[Pe]);
                        const fe = n.get(M[Pe]).__webglTexture;
                        r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, fe, 0)
                    }
                    r.blitFramebuffer(0, 0, q, J, 0, 0, q, J, ee, r.NEAREST),
                    c === !0 && (V.length = 0,
                    W.length = 0,
                    V.push(r.COLOR_ATTACHMENT0 + Pe),
                    N.depthBuffer && N.resolveDepthBuffer === !1 && (V.push(te),
                    W.push(te),
                    r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, W)),
                    r.invalidateFramebuffer(r.READ_FRAMEBUFFER, V))
                }
                if (t.bindFramebuffer(r.READ_FRAMEBUFFER, null),
                t.bindFramebuffer(r.DRAW_FRAMEBUFFER, null),
                de)
                    for (let Pe = 0; Pe < M.length; Pe++) {
                        t.bindFramebuffer(r.FRAMEBUFFER, we.__webglMultisampledFramebuffer),
                        r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + Pe, r.RENDERBUFFER, we.__webglColorRenderbuffer[Pe]);
                        const fe = n.get(M[Pe]).__webglTexture;
                        t.bindFramebuffer(r.FRAMEBUFFER, we.__webglFramebuffer),
                        r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0 + Pe, r.TEXTURE_2D, fe, 0)
                    }
                t.bindFramebuffer(r.DRAW_FRAMEBUFFER, we.__webglMultisampledFramebuffer)
            } else if (N.depthBuffer && N.resolveDepthBuffer === !1 && c) {
                const M = N.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT;
                r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, [M])
            }
        }
    }
    function $(N) {
        return Math.min(i.maxSamples, N.samples)
    }
    function me(N) {
        const M = n.get(N);
        return N.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && M.__useRenderToTexture !== !1
    }
    function he(N) {
        const M = o.render.frame;
        u.get(N) !== M && (u.set(N, M),
        N.update())
    }
    function ge(N, M) {
        const q = N.colorSpace
          , J = N.format
          , ee = N.type;
        return N.isCompressedTexture === !0 || N.isVideoTexture === !0 || q !== Ht && q !== Zn && (et.getTransfer(q) === at ? (J !== tn || ee !== Mn) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", q)),
        M
    }
    function De(N) {
        return typeof HTMLImageElement < "u" && N instanceof HTMLImageElement ? (l.width = N.naturalWidth || N.width,
        l.height = N.naturalHeight || N.height) : typeof VideoFrame < "u" && N instanceof VideoFrame ? (l.width = N.displayWidth,
        l.height = N.displayHeight) : (l.width = N.width,
        l.height = N.height),
        l
    }
    this.allocateTextureUnit = k,
    this.resetTextureUnits = re,
    this.setTexture2D = F,
    this.setTexture2DArray = O,
    this.setTexture3D = y,
    this.setTextureCube = v,
    this.rebindTextures = G,
    this.setupRenderTarget = K,
    this.updateRenderTargetMipmap = x,
    this.updateMultisampleRenderTarget = oe,
    this.setupDepthRenderbuffer = Te,
    this.setupFrameBufferTexture = le,
    this.useMultisampledRTT = me
}
function Kv(r, e) {
    function t(n, i=Zn) {
        let s;
        const o = et.getTransfer(i);
        if (n === Mn)
            return r.UNSIGNED_BYTE;
        if (n === qa)
            return r.UNSIGNED_SHORT_4_4_4_4;
        if (n === Za)
            return r.UNSIGNED_SHORT_5_5_5_1;
        if (n === vu)
            return r.UNSIGNED_INT_5_9_9_9_REV;
        if (n === Au)
            return r.BYTE;
        if (n === gu)
            return r.SHORT;
        if (n === Es)
            return r.UNSIGNED_SHORT;
        if (n === Ya)
            return r.INT;
        if (n === Ai)
            return r.UNSIGNED_INT;
        if (n === dn)
            return r.FLOAT;
        if (n === Fs)
            return r.HALF_FLOAT;
        if (n === xu)
            return r.ALPHA;
        if (n === yu)
            return r.RGB;
        if (n === tn)
            return r.RGBA;
        if (n === Ls)
            return r.DEPTH_COMPONENT;
        if (n === Cs)
            return r.DEPTH_STENCIL;
        if (n === Ka)
            return r.RED;
        if (n === Qa)
            return r.RED_INTEGER;
        if (n === bu)
            return r.RG;
        if (n === Ja)
            return r.RG_INTEGER;
        if (n === $a)
            return r.RGBA_INTEGER;
        if (n === Rr || n === Dr || n === Nr || n === Or)
            if (o === at)
                if (s = e.get("WEBGL_compressed_texture_s3tc_srgb"),
                s !== null) {
                    if (n === Rr)
                        return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    if (n === Dr)
                        return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    if (n === Nr)
                        return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    if (n === Or)
                        return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                } else
                    return null;
            else if (s = e.get("WEBGL_compressed_texture_s3tc"),
            s !== null) {
                if (n === Rr)
                    return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (n === Dr)
                    return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (n === Nr)
                    return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (n === Or)
                    return s.COMPRESSED_RGBA_S3TC_DXT5_EXT
            } else
                return null;
        if (n === na || n === ia || n === sa || n === ra)
            if (s = e.get("WEBGL_compressed_texture_pvrtc"),
            s !== null) {
                if (n === na)
                    return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (n === ia)
                    return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (n === sa)
                    return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (n === ra)
                    return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            } else
                return null;
        if (n === oa || n === aa || n === ca)
            if (s = e.get("WEBGL_compressed_texture_etc"),
            s !== null) {
                if (n === oa || n === aa)
                    return o === at ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
                if (n === ca)
                    return o === at ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : s.COMPRESSED_RGBA8_ETC2_EAC
            } else
                return null;
        if (n === la || n === ua || n === ha || n === da || n === fa || n === pa || n === ma || n === Aa || n === ga || n === va || n === xa || n === ya || n === ba || n === Ma)
            if (s = e.get("WEBGL_compressed_texture_astc"),
            s !== null) {
                if (n === la)
                    return o === at ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (n === ua)
                    return o === at ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (n === ha)
                    return o === at ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (n === da)
                    return o === at ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (n === fa)
                    return o === at ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (n === pa)
                    return o === at ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (n === ma)
                    return o === at ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (n === Aa)
                    return o === at ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (n === ga)
                    return o === at ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (n === va)
                    return o === at ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (n === xa)
                    return o === at ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (n === ya)
                    return o === at ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (n === ba)
                    return o === at ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (n === Ma)
                    return o === at ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : s.COMPRESSED_RGBA_ASTC_12x12_KHR
            } else
                return null;
        if (n === zr || n === wa || n === Sa)
            if (s = e.get("EXT_texture_compression_bptc"),
            s !== null) {
                if (n === zr)
                    return o === at ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                if (n === wa)
                    return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                if (n === Sa)
                    return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
            } else
                return null;
        if (n === Mu || n === Ta || n === Ea || n === Pa)
            if (s = e.get("EXT_texture_compression_rgtc"),
            s !== null) {
                if (n === zr)
                    return s.COMPRESSED_RED_RGTC1_EXT;
                if (n === Ta)
                    return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                if (n === Ea)
                    return s.COMPRESSED_RED_GREEN_RGTC2_EXT;
                if (n === Pa)
                    return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
            } else
                return null;
        return n === Ps ? r.UNSIGNED_INT_24_8 : r[n] !== void 0 ? r[n] : null
    }
    return {
        convert: t
    }
}
const Qv = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`
  , Jv = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class $v {
    constructor() {
        this.texture = null,
        this.mesh = null,
        this.depthNear = 0,
        this.depthFar = 0
    }
    init(e, t, n) {
        if (this.texture === null) {
            const i = new Tt
              , s = e.properties.get(i);
            s.__webglTexture = t.texture,
            (t.depthNear !== n.depthNear || t.depthFar !== n.depthFar) && (this.depthNear = t.depthNear,
            this.depthFar = t.depthFar),
            this.texture = i
        }
    }
    getMesh(e) {
        if (this.texture !== null && this.mesh === null) {
            const t = e.cameras[0].viewport
              , n = new wn({
                vertexShader: Qv,
                fragmentShader: Jv,
                uniforms: {
                    depthColor: {
                        value: this.texture
                    },
                    depthWidth: {
                        value: t.z
                    },
                    depthHeight: {
                        value: t.w
                    }
                }
            });
            this.mesh = new ct(new Xs(20,20),n)
        }
        return this.mesh
    }
    reset() {
        this.texture = null,
        this.mesh = null
    }
    getDepthTexture() {
        return this.texture
    }
}
class e0 extends es {
    constructor(e, t) {
        super();
        const n = this;
        let i = null
          , s = 1
          , o = null
          , a = "local-floor"
          , c = 1
          , l = null
          , u = null
          , h = null
          , d = null
          , f = null
          , m = null;
        const g = new $v
          , A = t.getContextAttributes();
        let p = null
          , S = null;
        const w = []
          , b = []
          , B = new Ae;
        let z = null;
        const I = new Bt;
        I.viewport = new Je;
        const H = new Bt;
        H.viewport = new Je;
        const P = [I, H]
          , T = new lp;
        let _ = null
          , re = null;
        this.cameraAutoUpdate = !0,
        this.enabled = !1,
        this.isPresenting = !1,
        this.getController = function(X) {
            let ne = w[X];
            return ne === void 0 && (ne = new yo,
            w[X] = ne),
            ne.getTargetRaySpace()
        }
        ,
        this.getControllerGrip = function(X) {
            let ne = w[X];
            return ne === void 0 && (ne = new yo,
            w[X] = ne),
            ne.getGripSpace()
        }
        ,
        this.getHand = function(X) {
            let ne = w[X];
            return ne === void 0 && (ne = new yo,
            w[X] = ne),
            ne.getHandSpace()
        }
        ;
        function k(X) {
            const ne = b.indexOf(X.inputSource);
            if (ne === -1)
                return;
            const ae = w[ne];
            ae !== void 0 && (ae.update(X.inputSource, X.frame, l || o),
            ae.dispatchEvent({
                type: X.type,
                data: X.inputSource
            }))
        }
        function U() {
            i.removeEventListener("select", k),
            i.removeEventListener("selectstart", k),
            i.removeEventListener("selectend", k),
            i.removeEventListener("squeeze", k),
            i.removeEventListener("squeezestart", k),
            i.removeEventListener("squeezeend", k),
            i.removeEventListener("end", U),
            i.removeEventListener("inputsourceschange", F);
            for (let X = 0; X < w.length; X++) {
                const ne = b[X];
                ne !== null && (b[X] = null,
                w[X].disconnect(ne))
            }
            _ = null,
            re = null,
            g.reset(),
            e.setRenderTarget(p),
            f = null,
            d = null,
            h = null,
            i = null,
            S = null,
            ue.stop(),
            n.isPresenting = !1,
            e.setPixelRatio(z),
            e.setSize(B.width, B.height, !1),
            n.dispatchEvent({
                type: "sessionend"
            })
        }
        this.setFramebufferScaleFactor = function(X) {
            s = X,
            n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }
        ,
        this.setReferenceSpaceType = function(X) {
            a = X,
            n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }
        ,
        this.getReferenceSpace = function() {
            return l || o
        }
        ,
        this.setReferenceSpace = function(X) {
            l = X
        }
        ,
        this.getBaseLayer = function() {
            return d !== null ? d : f
        }
        ,
        this.getBinding = function() {
            return h
        }
        ,
        this.getFrame = function() {
            return m
        }
        ,
        this.getSession = function() {
            return i
        }
        ,
        this.setSession = async function(X) {
            if (i = X,
            i !== null) {
                if (p = e.getRenderTarget(),
                i.addEventListener("select", k),
                i.addEventListener("selectstart", k),
                i.addEventListener("selectend", k),
                i.addEventListener("squeeze", k),
                i.addEventListener("squeezestart", k),
                i.addEventListener("squeezeend", k),
                i.addEventListener("end", U),
                i.addEventListener("inputsourceschange", F),
                A.xrCompatible !== !0 && await t.makeXRCompatible(),
                z = e.getPixelRatio(),
                e.getSize(B),
                typeof XRWebGLBinding < "u" && "createProjectionLayer"in XRWebGLBinding.prototype) {
                    let ae = null
                      , ce = null
                      , le = null;
                    A.depth && (le = A.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24,
                    ae = A.stencil ? Cs : Ls,
                    ce = A.stencil ? Ps : Ai);
                    const xe = {
                        colorFormat: t.RGBA8,
                        depthFormat: le,
                        scaleFactor: s
                    };
                    h = new XRWebGLBinding(i,t),
                    d = h.createProjectionLayer(xe),
                    i.updateRenderState({
                        layers: [d]
                    }),
                    e.setPixelRatio(1),
                    e.setSize(d.textureWidth, d.textureHeight, !1),
                    S = new gi(d.textureWidth,d.textureHeight,{
                        format: tn,
                        type: Mn,
                        depthTexture: new _u(d.textureWidth,d.textureHeight,ce,void 0,void 0,void 0,void 0,void 0,void 0,ae),
                        stencilBuffer: A.stencil,
                        colorSpace: e.outputColorSpace,
                        samples: A.antialias ? 4 : 0,
                        resolveDepthBuffer: d.ignoreDepthValues === !1,
                        resolveStencilBuffer: d.ignoreDepthValues === !1
                    })
                } else {
                    const ae = {
                        antialias: A.antialias,
                        alpha: !0,
                        depth: A.depth,
                        stencil: A.stencil,
                        framebufferScaleFactor: s
                    };
                    f = new XRWebGLLayer(i,t,ae),
                    i.updateRenderState({
                        baseLayer: f
                    }),
                    e.setPixelRatio(1),
                    e.setSize(f.framebufferWidth, f.framebufferHeight, !1),
                    S = new gi(f.framebufferWidth,f.framebufferHeight,{
                        format: tn,
                        type: Mn,
                        colorSpace: e.outputColorSpace,
                        stencilBuffer: A.stencil,
                        resolveDepthBuffer: f.ignoreDepthValues === !1,
                        resolveStencilBuffer: f.ignoreDepthValues === !1
                    })
                }
                S.isXRRenderTarget = !0,
                this.setFoveation(c),
                l = null,
                o = await i.requestReferenceSpace(a),
                ue.setContext(i),
                ue.start(),
                n.isPresenting = !0,
                n.dispatchEvent({
                    type: "sessionstart"
                })
            }
        }
        ,
        this.getEnvironmentBlendMode = function() {
            if (i !== null)
                return i.environmentBlendMode
        }
        ,
        this.getDepthTexture = function() {
            return g.getDepthTexture()
        }
        ;
        function F(X) {
            for (let ne = 0; ne < X.removed.length; ne++) {
                const ae = X.removed[ne]
                  , ce = b.indexOf(ae);
                ce >= 0 && (b[ce] = null,
                w[ce].disconnect(ae))
            }
            for (let ne = 0; ne < X.added.length; ne++) {
                const ae = X.added[ne];
                let ce = b.indexOf(ae);
                if (ce === -1) {
                    for (let xe = 0; xe < w.length; xe++)
                        if (xe >= b.length) {
                            b.push(ae),
                            ce = xe;
                            break
                        } else if (b[xe] === null) {
                            b[xe] = ae,
                            ce = xe;
                            break
                        }
                    if (ce === -1)
                        break
                }
                const le = w[ce];
                le && le.connect(ae)
            }
        }
        const O = new D
          , y = new D;
        function v(X, ne, ae) {
            O.setFromMatrixPosition(ne.matrixWorld),
            y.setFromMatrixPosition(ae.matrixWorld);
            const ce = O.distanceTo(y)
              , le = ne.projectionMatrix.elements
              , xe = ae.projectionMatrix.elements
              , ye = le[14] / (le[10] - 1)
              , Te = le[14] / (le[10] + 1)
              , G = (le[9] + 1) / le[5]
              , K = (le[9] - 1) / le[5]
              , x = (le[8] - 1) / le[0]
              , V = (xe[8] + 1) / xe[0]
              , W = ye * x
              , oe = ye * V
              , $ = ce / (-x + V)
              , me = $ * -x;
            if (ne.matrixWorld.decompose(X.position, X.quaternion, X.scale),
            X.translateX(me),
            X.translateZ($),
            X.matrixWorld.compose(X.position, X.quaternion, X.scale),
            X.matrixWorldInverse.copy(X.matrixWorld).invert(),
            le[10] === -1)
                X.projectionMatrix.copy(ne.projectionMatrix),
                X.projectionMatrixInverse.copy(ne.projectionMatrixInverse);
            else {
                const he = ye + $
                  , ge = Te + $
                  , De = W - me
                  , N = oe + (ce - me)
                  , M = G * Te / ge * he
                  , q = K * Te / ge * he;
                X.projectionMatrix.makePerspective(De, N, M, q, he, ge),
                X.projectionMatrixInverse.copy(X.projectionMatrix).invert()
            }
        }
        function L(X, ne) {
            ne === null ? X.matrixWorld.copy(X.matrix) : X.matrixWorld.multiplyMatrices(ne.matrixWorld, X.matrix),
            X.matrixWorldInverse.copy(X.matrixWorld).invert()
        }
        this.updateCamera = function(X) {
            if (i === null)
                return;
            let ne = X.near
              , ae = X.far;
            g.texture !== null && (g.depthNear > 0 && (ne = g.depthNear),
            g.depthFar > 0 && (ae = g.depthFar)),
            T.near = H.near = I.near = ne,
            T.far = H.far = I.far = ae,
            (_ !== T.near || re !== T.far) && (i.updateRenderState({
                depthNear: T.near,
                depthFar: T.far
            }),
            _ = T.near,
            re = T.far),
            I.layers.mask = X.layers.mask | 2,
            H.layers.mask = X.layers.mask | 4,
            T.layers.mask = I.layers.mask | H.layers.mask;
            const ce = X.parent
              , le = T.cameras;
            L(T, ce);
            for (let xe = 0; xe < le.length; xe++)
                L(le[xe], ce);
            le.length === 2 ? v(T, I, H) : T.projectionMatrix.copy(I.projectionMatrix),
            R(X, T, ce)
        }
        ;
        function R(X, ne, ae) {
            ae === null ? X.matrix.copy(ne.matrixWorld) : (X.matrix.copy(ae.matrixWorld),
            X.matrix.invert(),
            X.matrix.multiply(ne.matrixWorld)),
            X.matrix.decompose(X.position, X.quaternion, X.scale),
            X.updateMatrixWorld(!0),
            X.projectionMatrix.copy(ne.projectionMatrix),
            X.projectionMatrixInverse.copy(ne.projectionMatrixInverse),
            X.isPerspectiveCamera && (X.fov = Yi * 2 * Math.atan(1 / X.projectionMatrix.elements[5]),
            X.zoom = 1)
        }
        this.getCamera = function() {
            return T
        }
        ,
        this.getFoveation = function() {
            if (!(d === null && f === null))
                return c
        }
        ,
        this.setFoveation = function(X) {
            c = X,
            d !== null && (d.fixedFoveation = X),
            f !== null && f.fixedFoveation !== void 0 && (f.fixedFoveation = X)
        }
        ,
        this.hasDepthSensing = function() {
            return g.texture !== null
        }
        ,
        this.getDepthSensingMesh = function() {
            return g.getMesh(T)
        }
        ;
        let C = null;
        function Y(X, ne) {
            if (u = ne.getViewerPose(l || o),
            m = ne,
            u !== null) {
                const ae = u.views;
                f !== null && (e.setRenderTargetFramebuffer(S, f.framebuffer),
                e.setRenderTarget(S));
                let ce = !1;
                ae.length !== T.cameras.length && (T.cameras.length = 0,
                ce = !0);
                for (let ye = 0; ye < ae.length; ye++) {
                    const Te = ae[ye];
                    let G = null;
                    if (f !== null)
                        G = f.getViewport(Te);
                    else {
                        const x = h.getViewSubImage(d, Te);
                        G = x.viewport,
                        ye === 0 && (e.setRenderTargetTextures(S, x.colorTexture, x.depthStencilTexture),
                        e.setRenderTarget(S))
                    }
                    let K = P[ye];
                    K === void 0 && (K = new Bt,
                    K.layers.enable(ye),
                    K.viewport = new Je,
                    P[ye] = K),
                    K.matrix.fromArray(Te.transform.matrix),
                    K.matrix.decompose(K.position, K.quaternion, K.scale),
                    K.projectionMatrix.fromArray(Te.projectionMatrix),
                    K.projectionMatrixInverse.copy(K.projectionMatrix).invert(),
                    K.viewport.set(G.x, G.y, G.width, G.height),
                    ye === 0 && (T.matrix.copy(K.matrix),
                    T.matrix.decompose(T.position, T.quaternion, T.scale)),
                    ce === !0 && T.cameras.push(K)
                }
                const le = i.enabledFeatures;
                if (le && le.includes("depth-sensing") && i.depthUsage == "gpu-optimized" && h) {
                    const ye = h.getDepthInformation(ae[0]);
                    ye && ye.isValid && ye.texture && g.init(e, ye, i.renderState)
                }
            }
            for (let ae = 0; ae < w.length; ae++) {
                const ce = b[ae]
                  , le = w[ae];
                ce !== null && le !== void 0 && le.update(ce, ne, l || o)
            }
            C && C(X, ne),
            ne.detectedPlanes && n.dispatchEvent({
                type: "planesdetected",
                data: ne
            }),
            m = null
        }
        const ue = new Ju;
        ue.setAnimationLoop(Y),
        this.setAnimationLoop = function(X) {
            C = X
        }
        ,
        this.dispose = function() {}
    }
}
const li = new Ft
  , t0 = new We;
function n0(r, e) {
    function t(A, p) {
        A.matrixAutoUpdate === !0 && A.updateMatrix(),
        p.value.copy(A.matrix)
    }
    function n(A, p) {
        p.color.getRGB(A.fogColor.value, Ru(r)),
        p.isFog ? (A.fogNear.value = p.near,
        A.fogFar.value = p.far) : p.isFogExp2 && (A.fogDensity.value = p.density)
    }
    function i(A, p, S, w, b) {
        p.isMeshBasicMaterial || p.isMeshLambertMaterial ? s(A, p) : p.isMeshToonMaterial ? (s(A, p),
        h(A, p)) : p.isMeshPhongMaterial ? (s(A, p),
        u(A, p)) : p.isMeshStandardMaterial ? (s(A, p),
        d(A, p),
        p.isMeshPhysicalMaterial && f(A, p, b)) : p.isMeshMatcapMaterial ? (s(A, p),
        m(A, p)) : p.isMeshDepthMaterial ? s(A, p) : p.isMeshDistanceMaterial ? (s(A, p),
        g(A, p)) : p.isMeshNormalMaterial ? s(A, p) : p.isLineBasicMaterial ? (o(A, p),
        p.isLineDashedMaterial && a(A, p)) : p.isPointsMaterial ? c(A, p, S, w) : p.isSpriteMaterial ? l(A, p) : p.isShadowMaterial ? (A.color.value.copy(p.color),
        A.opacity.value = p.opacity) : p.isShaderMaterial && (p.uniformsNeedUpdate = !1)
    }
    function s(A, p) {
        A.opacity.value = p.opacity,
        p.color && A.diffuse.value.copy(p.color),
        p.emissive && A.emissive.value.copy(p.emissive).multiplyScalar(p.emissiveIntensity),
        p.map && (A.map.value = p.map,
        t(p.map, A.mapTransform)),
        p.alphaMap && (A.alphaMap.value = p.alphaMap,
        t(p.alphaMap, A.alphaMapTransform)),
        p.bumpMap && (A.bumpMap.value = p.bumpMap,
        t(p.bumpMap, A.bumpMapTransform),
        A.bumpScale.value = p.bumpScale,
        p.side === Vt && (A.bumpScale.value *= -1)),
        p.normalMap && (A.normalMap.value = p.normalMap,
        t(p.normalMap, A.normalMapTransform),
        A.normalScale.value.copy(p.normalScale),
        p.side === Vt && A.normalScale.value.negate()),
        p.displacementMap && (A.displacementMap.value = p.displacementMap,
        t(p.displacementMap, A.displacementMapTransform),
        A.displacementScale.value = p.displacementScale,
        A.displacementBias.value = p.displacementBias),
        p.emissiveMap && (A.emissiveMap.value = p.emissiveMap,
        t(p.emissiveMap, A.emissiveMapTransform)),
        p.specularMap && (A.specularMap.value = p.specularMap,
        t(p.specularMap, A.specularMapTransform)),
        p.alphaTest > 0 && (A.alphaTest.value = p.alphaTest);
        const S = e.get(p)
          , w = S.envMap
          , b = S.envMapRotation;
        w && (A.envMap.value = w,
        li.copy(b),
        li.x *= -1,
        li.y *= -1,
        li.z *= -1,
        w.isCubeTexture && w.isRenderTargetTexture === !1 && (li.y *= -1,
        li.z *= -1),
        A.envMapRotation.value.setFromMatrix4(t0.makeRotationFromEuler(li)),
        A.flipEnvMap.value = w.isCubeTexture && w.isRenderTargetTexture === !1 ? -1 : 1,
        A.reflectivity.value = p.reflectivity,
        A.ior.value = p.ior,
        A.refractionRatio.value = p.refractionRatio),
        p.lightMap && (A.lightMap.value = p.lightMap,
        A.lightMapIntensity.value = p.lightMapIntensity,
        t(p.lightMap, A.lightMapTransform)),
        p.aoMap && (A.aoMap.value = p.aoMap,
        A.aoMapIntensity.value = p.aoMapIntensity,
        t(p.aoMap, A.aoMapTransform))
    }
    function o(A, p) {
        A.diffuse.value.copy(p.color),
        A.opacity.value = p.opacity,
        p.map && (A.map.value = p.map,
        t(p.map, A.mapTransform))
    }
    function a(A, p) {
        A.dashSize.value = p.dashSize,
        A.totalSize.value = p.dashSize + p.gapSize,
        A.scale.value = p.scale
    }
    function c(A, p, S, w) {
        A.diffuse.value.copy(p.color),
        A.opacity.value = p.opacity,
        A.size.value = p.size * S,
        A.scale.value = w * .5,
        p.map && (A.map.value = p.map,
        t(p.map, A.uvTransform)),
        p.alphaMap && (A.alphaMap.value = p.alphaMap,
        t(p.alphaMap, A.alphaMapTransform)),
        p.alphaTest > 0 && (A.alphaTest.value = p.alphaTest)
    }
    function l(A, p) {
        A.diffuse.value.copy(p.color),
        A.opacity.value = p.opacity,
        A.rotation.value = p.rotation,
        p.map && (A.map.value = p.map,
        t(p.map, A.mapTransform)),
        p.alphaMap && (A.alphaMap.value = p.alphaMap,
        t(p.alphaMap, A.alphaMapTransform)),
        p.alphaTest > 0 && (A.alphaTest.value = p.alphaTest)
    }
    function u(A, p) {
        A.specular.value.copy(p.specular),
        A.shininess.value = Math.max(p.shininess, 1e-4)
    }
    function h(A, p) {
        p.gradientMap && (A.gradientMap.value = p.gradientMap)
    }
    function d(A, p) {
        A.metalness.value = p.metalness,
        p.metalnessMap && (A.metalnessMap.value = p.metalnessMap,
        t(p.metalnessMap, A.metalnessMapTransform)),
        A.roughness.value = p.roughness,
        p.roughnessMap && (A.roughnessMap.value = p.roughnessMap,
        t(p.roughnessMap, A.roughnessMapTransform)),
        p.envMap && (A.envMapIntensity.value = p.envMapIntensity)
    }
    function f(A, p, S) {
        A.ior.value = p.ior,
        p.sheen > 0 && (A.sheenColor.value.copy(p.sheenColor).multiplyScalar(p.sheen),
        A.sheenRoughness.value = p.sheenRoughness,
        p.sheenColorMap && (A.sheenColorMap.value = p.sheenColorMap,
        t(p.sheenColorMap, A.sheenColorMapTransform)),
        p.sheenRoughnessMap && (A.sheenRoughnessMap.value = p.sheenRoughnessMap,
        t(p.sheenRoughnessMap, A.sheenRoughnessMapTransform))),
        p.clearcoat > 0 && (A.clearcoat.value = p.clearcoat,
        A.clearcoatRoughness.value = p.clearcoatRoughness,
        p.clearcoatMap && (A.clearcoatMap.value = p.clearcoatMap,
        t(p.clearcoatMap, A.clearcoatMapTransform)),
        p.clearcoatRoughnessMap && (A.clearcoatRoughnessMap.value = p.clearcoatRoughnessMap,
        t(p.clearcoatRoughnessMap, A.clearcoatRoughnessMapTransform)),
        p.clearcoatNormalMap && (A.clearcoatNormalMap.value = p.clearcoatNormalMap,
        t(p.clearcoatNormalMap, A.clearcoatNormalMapTransform),
        A.clearcoatNormalScale.value.copy(p.clearcoatNormalScale),
        p.side === Vt && A.clearcoatNormalScale.value.negate())),
        p.dispersion > 0 && (A.dispersion.value = p.dispersion),
        p.iridescence > 0 && (A.iridescence.value = p.iridescence,
        A.iridescenceIOR.value = p.iridescenceIOR,
        A.iridescenceThicknessMinimum.value = p.iridescenceThicknessRange[0],
        A.iridescenceThicknessMaximum.value = p.iridescenceThicknessRange[1],
        p.iridescenceMap && (A.iridescenceMap.value = p.iridescenceMap,
        t(p.iridescenceMap, A.iridescenceMapTransform)),
        p.iridescenceThicknessMap && (A.iridescenceThicknessMap.value = p.iridescenceThicknessMap,
        t(p.iridescenceThicknessMap, A.iridescenceThicknessMapTransform))),
        p.transmission > 0 && (A.transmission.value = p.transmission,
        A.transmissionSamplerMap.value = S.texture,
        A.transmissionSamplerSize.value.set(S.width, S.height),
        p.transmissionMap && (A.transmissionMap.value = p.transmissionMap,
        t(p.transmissionMap, A.transmissionMapTransform)),
        A.thickness.value = p.thickness,
        p.thicknessMap && (A.thicknessMap.value = p.thicknessMap,
        t(p.thicknessMap, A.thicknessMapTransform)),
        A.attenuationDistance.value = p.attenuationDistance,
        A.attenuationColor.value.copy(p.attenuationColor)),
        p.anisotropy > 0 && (A.anisotropyVector.value.set(p.anisotropy * Math.cos(p.anisotropyRotation), p.anisotropy * Math.sin(p.anisotropyRotation)),
        p.anisotropyMap && (A.anisotropyMap.value = p.anisotropyMap,
        t(p.anisotropyMap, A.anisotropyMapTransform))),
        A.specularIntensity.value = p.specularIntensity,
        A.specularColor.value.copy(p.specularColor),
        p.specularColorMap && (A.specularColorMap.value = p.specularColorMap,
        t(p.specularColorMap, A.specularColorMapTransform)),
        p.specularIntensityMap && (A.specularIntensityMap.value = p.specularIntensityMap,
        t(p.specularIntensityMap, A.specularIntensityMapTransform))
    }
    function m(A, p) {
        p.matcap && (A.matcap.value = p.matcap)
    }
    function g(A, p) {
        const S = e.get(p).light;
        A.referencePosition.value.setFromMatrixPosition(S.matrixWorld),
        A.nearDistance.value = S.shadow.camera.near,
        A.farDistance.value = S.shadow.camera.far
    }
    return {
        refreshFogUniforms: n,
        refreshMaterialUniforms: i
    }
}
function i0(r, e, t, n) {
    let i = {}
      , s = {}
      , o = [];
    const a = r.getParameter(r.MAX_UNIFORM_BUFFER_BINDINGS);
    function c(S, w) {
        const b = w.program;
        n.uniformBlockBinding(S, b)
    }
    function l(S, w) {
        let b = i[S.id];
        b === void 0 && (m(S),
        b = u(S),
        i[S.id] = b,
        S.addEventListener("dispose", A));
        const B = w.program;
        n.updateUBOMapping(S, B);
        const z = e.render.frame;
        s[S.id] !== z && (d(S),
        s[S.id] = z)
    }
    function u(S) {
        const w = h();
        S.__bindingPointIndex = w;
        const b = r.createBuffer()
          , B = S.__size
          , z = S.usage;
        return r.bindBuffer(r.UNIFORM_BUFFER, b),
        r.bufferData(r.UNIFORM_BUFFER, B, z),
        r.bindBuffer(r.UNIFORM_BUFFER, null),
        r.bindBufferBase(r.UNIFORM_BUFFER, w, b),
        b
    }
    function h() {
        for (let S = 0; S < a; S++)
            if (o.indexOf(S) === -1)
                return o.push(S),
                S;
        return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),
        0
    }
    function d(S) {
        const w = i[S.id]
          , b = S.uniforms
          , B = S.__cache;
        r.bindBuffer(r.UNIFORM_BUFFER, w);
        for (let z = 0, I = b.length; z < I; z++) {
            const H = Array.isArray(b[z]) ? b[z] : [b[z]];
            for (let P = 0, T = H.length; P < T; P++) {
                const _ = H[P];
                if (f(_, z, P, B) === !0) {
                    const re = _.__offset
                      , k = Array.isArray(_.value) ? _.value : [_.value];
                    let U = 0;
                    for (let F = 0; F < k.length; F++) {
                        const O = k[F]
                          , y = g(O);
                        typeof O == "number" || typeof O == "boolean" ? (_.__data[0] = O,
                        r.bufferSubData(r.UNIFORM_BUFFER, re + U, _.__data)) : O.isMatrix3 ? (_.__data[0] = O.elements[0],
                        _.__data[1] = O.elements[1],
                        _.__data[2] = O.elements[2],
                        _.__data[3] = 0,
                        _.__data[4] = O.elements[3],
                        _.__data[5] = O.elements[4],
                        _.__data[6] = O.elements[5],
                        _.__data[7] = 0,
                        _.__data[8] = O.elements[6],
                        _.__data[9] = O.elements[7],
                        _.__data[10] = O.elements[8],
                        _.__data[11] = 0) : (O.toArray(_.__data, U),
                        U += y.storage / Float32Array.BYTES_PER_ELEMENT)
                    }
                    r.bufferSubData(r.UNIFORM_BUFFER, re, _.__data)
                }
            }
        }
        r.bindBuffer(r.UNIFORM_BUFFER, null)
    }
    function f(S, w, b, B) {
        const z = S.value
          , I = w + "_" + b;
        if (B[I] === void 0)
            return typeof z == "number" || typeof z == "boolean" ? B[I] = z : B[I] = z.clone(),
            !0;
        {
            const H = B[I];
            if (typeof z == "number" || typeof z == "boolean") {
                if (H !== z)
                    return B[I] = z,
                    !0
            } else if (H.equals(z) === !1)
                return H.copy(z),
                !0
        }
        return !1
    }
    function m(S) {
        const w = S.uniforms;
        let b = 0;
        const B = 16;
        for (let I = 0, H = w.length; I < H; I++) {
            const P = Array.isArray(w[I]) ? w[I] : [w[I]];
            for (let T = 0, _ = P.length; T < _; T++) {
                const re = P[T]
                  , k = Array.isArray(re.value) ? re.value : [re.value];
                for (let U = 0, F = k.length; U < F; U++) {
                    const O = k[U]
                      , y = g(O)
                      , v = b % B
                      , L = v % y.boundary
                      , R = v + L;
                    b += L,
                    R !== 0 && B - R < y.storage && (b += B - R),
                    re.__data = new Float32Array(y.storage / Float32Array.BYTES_PER_ELEMENT),
                    re.__offset = b,
                    b += y.storage
                }
            }
        }
        const z = b % B;
        return z > 0 && (b += B - z),
        S.__size = b,
        S.__cache = {},
        this
    }
    function g(S) {
        const w = {
            boundary: 0,
            storage: 0
        };
        return typeof S == "number" || typeof S == "boolean" ? (w.boundary = 4,
        w.storage = 4) : S.isVector2 ? (w.boundary = 8,
        w.storage = 8) : S.isVector3 || S.isColor ? (w.boundary = 16,
        w.storage = 12) : S.isVector4 ? (w.boundary = 16,
        w.storage = 16) : S.isMatrix3 ? (w.boundary = 48,
        w.storage = 48) : S.isMatrix4 ? (w.boundary = 64,
        w.storage = 64) : S.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", S),
        w
    }
    function A(S) {
        const w = S.target;
        w.removeEventListener("dispose", A);
        const b = o.indexOf(w.__bindingPointIndex);
        o.splice(b, 1),
        r.deleteBuffer(i[w.id]),
        delete i[w.id],
        delete s[w.id]
    }
    function p() {
        for (const S in i)
            r.deleteBuffer(i[S]);
        o = [],
        i = {},
        s = {}
    }
    return {
        bind: c,
        update: l,
        dispose: p
    }
}
class s0 {
    constructor(e={}) {
        const {canvas: t=wd(), context: n=null, depth: i=!0, stencil: s=!1, alpha: o=!1, antialias: a=!1, premultipliedAlpha: c=!0, preserveDrawingBuffer: l=!1, powerPreference: u="default", failIfMajorPerformanceCaveat: h=!1, reverseDepthBuffer: d=!1} = e;
        this.isWebGLRenderer = !0;
        let f;
        if (n !== null) {
            if (typeof WebGLRenderingContext < "u" && n instanceof WebGLRenderingContext)
                throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
            f = n.getContextAttributes().alpha
        } else
            f = o;
        const m = new Uint32Array(4)
          , g = new Int32Array(4);
        let A = null
          , p = null;
        const S = []
          , w = [];
        this.domElement = t,
        this.debug = {
            checkShaderErrors: !0,
            onShaderError: null
        },
        this.autoClear = !0,
        this.autoClearColor = !0,
        this.autoClearDepth = !0,
        this.autoClearStencil = !0,
        this.sortObjects = !0,
        this.clippingPlanes = [],
        this.localClippingEnabled = !1,
        this.toneMapping = ti,
        this.toneMappingExposure = 1,
        this.transmissionResolutionScale = 1;
        const b = this;
        let B = !1;
        this._outputColorSpace = Rt;
        let z = 0
          , I = 0
          , H = null
          , P = -1
          , T = null;
        const _ = new Je
          , re = new Je;
        let k = null;
        const U = new Ge(0);
        let F = 0
          , O = t.width
          , y = t.height
          , v = 1
          , L = null
          , R = null;
        const C = new Je(0,0,O,y)
          , Y = new Je(0,0,O,y);
        let ue = !1;
        const X = new oc;
        let ne = !1
          , ae = !1;
        const ce = new We
          , le = new We
          , xe = new D
          , ye = new Je
          , Te = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0
        };
        let G = !1;
        function K() {
            return H === null ? v : 1
        }
        let x = n;
        function V(E, Z) {
            return t.getContext(E, Z)
        }
        try {
            const E = {
                alpha: !0,
                depth: i,
                stencil: s,
                antialias: a,
                premultipliedAlpha: c,
                preserveDrawingBuffer: l,
                powerPreference: u,
                failIfMajorPerformanceCaveat: h
            };
            if ("setAttribute"in t && t.setAttribute("data-engine", `three.js r${Wa}`),
            t.addEventListener("webglcontextlost", ze, !1),
            t.addEventListener("webglcontextrestored", be, !1),
            t.addEventListener("webglcontextcreationerror", pe, !1),
            x === null) {
                const Z = "webgl2";
                if (x = V(Z, E),
                x === null)
                    throw V(Z) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
            }
        } catch (E) {
            throw console.error("THREE.WebGLRenderer: " + E.message),
            E
        }
        let W, oe, $, me, he, ge, De, N, M, q, J, ee, te, we, de, Ee, Pe, fe, Ne, _e, Ue, Le, ke, j;
        function Ce() {
            W = new pg(x),
            W.init(),
            Le = new Kv(x,W),
            oe = new ag(x,W,e,Le),
            $ = new qv(x,W),
            oe.reverseDepthBuffer && d && $.buffers.depth.setReversed(!0),
            me = new gg(x),
            he = new Iv,
            ge = new Zv(x,W,$,he,oe,Le,me),
            De = new lg(b),
            N = new fg(b),
            M = new wp(x),
            ke = new rg(x,M),
            q = new mg(x,M,me,ke),
            J = new xg(x,q,M,me),
            Ne = new vg(x,oe,ge),
            Ee = new cg(he),
            ee = new zv(b,De,N,W,oe,ke,Ee),
            te = new n0(b,he),
            we = new Bv,
            de = new Vv(W),
            fe = new sg(b,De,N,$,J,f,c),
            Pe = new kv(b,J,oe),
            j = new i0(x,me,oe,$),
            _e = new og(x,W,me),
            Ue = new Ag(x,W,me),
            me.programs = ee.programs,
            b.capabilities = oe,
            b.extensions = W,
            b.properties = he,
            b.renderLists = we,
            b.shadowMap = Pe,
            b.state = $,
            b.info = me
        }
        Ce();
        const ve = new e0(b,x);
        this.xr = ve,
        this.getContext = function() {
            return x
        }
        ,
        this.getContextAttributes = function() {
            return x.getContextAttributes()
        }
        ,
        this.forceContextLoss = function() {
            const E = W.get("WEBGL_lose_context");
            E && E.loseContext()
        }
        ,
        this.forceContextRestore = function() {
            const E = W.get("WEBGL_lose_context");
            E && E.restoreContext()
        }
        ,
        this.getPixelRatio = function() {
            return v
        }
        ,
        this.setPixelRatio = function(E) {
            E !== void 0 && (v = E,
            this.setSize(O, y, !1))
        }
        ,
        this.getSize = function(E) {
            return E.set(O, y)
        }
        ,
        this.setSize = function(E, Z, ie=!0) {
            if (ve.isPresenting) {
                console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                return
            }
            O = E,
            y = Z,
            t.width = Math.floor(E * v),
            t.height = Math.floor(Z * v),
            ie === !0 && (t.style.width = E + "px",
            t.style.height = Z + "px"),
            this.setViewport(0, 0, E, Z)
        }
        ,
        this.getDrawingBufferSize = function(E) {
            return E.set(O * v, y * v).floor()
        }
        ,
        this.setDrawingBufferSize = function(E, Z, ie) {
            O = E,
            y = Z,
            v = ie,
            t.width = Math.floor(E * ie),
            t.height = Math.floor(Z * ie),
            this.setViewport(0, 0, E, Z)
        }
        ,
        this.getCurrentViewport = function(E) {
            return E.copy(_)
        }
        ,
        this.getViewport = function(E) {
            return E.copy(C)
        }
        ,
        this.setViewport = function(E, Z, ie, se) {
            E.isVector4 ? C.set(E.x, E.y, E.z, E.w) : C.set(E, Z, ie, se),
            $.viewport(_.copy(C).multiplyScalar(v).round())
        }
        ,
        this.getScissor = function(E) {
            return E.copy(Y)
        }
        ,
        this.setScissor = function(E, Z, ie, se) {
            E.isVector4 ? Y.set(E.x, E.y, E.z, E.w) : Y.set(E, Z, ie, se),
            $.scissor(re.copy(Y).multiplyScalar(v).round())
        }
        ,
        this.getScissorTest = function() {
            return ue
        }
        ,
        this.setScissorTest = function(E) {
            $.setScissorTest(ue = E)
        }
        ,
        this.setOpaqueSort = function(E) {
            L = E
        }
        ,
        this.setTransparentSort = function(E) {
            R = E
        }
        ,
        this.getClearColor = function(E) {
            return E.copy(fe.getClearColor())
        }
        ,
        this.setClearColor = function() {
            fe.setClearColor(...arguments)
        }
        ,
        this.getClearAlpha = function() {
            return fe.getClearAlpha()
        }
        ,
        this.setClearAlpha = function() {
            fe.setClearAlpha(...arguments)
        }
        ,
        this.clear = function(E=!0, Z=!0, ie=!0) {
            let se = 0;
            if (E) {
                let Q = !1;
                if (H !== null) {
                    const Me = H.texture.format;
                    Q = Me === $a || Me === Ja || Me === Qa
                }
                if (Q) {
                    const Me = H.texture.type
                      , Re = Me === Mn || Me === Ai || Me === Es || Me === Ps || Me === qa || Me === Za
                      , Fe = fe.getClearColor()
                      , Oe = fe.getClearAlpha()
                      , Ve = Fe.r
                      , je = Fe.g
                      , He = Fe.b;
                    Re ? (m[0] = Ve,
                    m[1] = je,
                    m[2] = He,
                    m[3] = Oe,
                    x.clearBufferuiv(x.COLOR, 0, m)) : (g[0] = Ve,
                    g[1] = je,
                    g[2] = He,
                    g[3] = Oe,
                    x.clearBufferiv(x.COLOR, 0, g))
                } else
                    se |= x.COLOR_BUFFER_BIT
            }
            Z && (se |= x.DEPTH_BUFFER_BIT),
            ie && (se |= x.STENCIL_BUFFER_BIT,
            this.state.buffers.stencil.setMask(4294967295)),
            x.clear(se)
        }
        ,
        this.clearColor = function() {
            this.clear(!0, !1, !1)
        }
        ,
        this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }
        ,
        this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }
        ,
        this.dispose = function() {
            t.removeEventListener("webglcontextlost", ze, !1),
            t.removeEventListener("webglcontextrestored", be, !1),
            t.removeEventListener("webglcontextcreationerror", pe, !1),
            fe.dispose(),
            we.dispose(),
            de.dispose(),
            he.dispose(),
            De.dispose(),
            N.dispose(),
            J.dispose(),
            ke.dispose(),
            j.dispose(),
            ee.dispose(),
            ve.dispose(),
            ve.removeEventListener("sessionstart", Ac),
            ve.removeEventListener("sessionend", gc),
            ni.stop()
        }
        ;
        function ze(E) {
            E.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            B = !0
        }
        function be() {
            console.log("THREE.WebGLRenderer: Context Restored."),
            B = !1;
            const E = me.autoReset
              , Z = Pe.enabled
              , ie = Pe.autoUpdate
              , se = Pe.needsUpdate
              , Q = Pe.type;
            Ce(),
            me.autoReset = E,
            Pe.enabled = Z,
            Pe.autoUpdate = ie,
            Pe.needsUpdate = se,
            Pe.type = Q
        }
        function pe(E) {
            console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", E.statusMessage)
        }
        function Be(E) {
            const Z = E.target;
            Z.removeEventListener("dispose", Be),
            Ye(Z)
        }
        function Ye(E) {
            ut(E),
            he.remove(E)
        }
        function ut(E) {
            const Z = he.get(E).programs;
            Z !== void 0 && (Z.forEach(function(ie) {
                ee.releaseProgram(ie)
            }),
            E.isShaderMaterial && ee.releaseShaderCache(E))
        }
        this.renderBufferDirect = function(E, Z, ie, se, Q, Me) {
            Z === null && (Z = Te);
            const Re = Q.isMesh && Q.matrixWorld.determinant() < 0
              , Fe = uh(E, Z, ie, se, Q);
            $.setMaterial(se, Re);
            let Oe = ie.index
              , Ve = 1;
            if (se.wireframe === !0) {
                if (Oe = q.getWireframeAttribute(ie),
                Oe === void 0)
                    return;
                Ve = 2
            }
            const je = ie.drawRange
              , He = ie.attributes.position;
            let $e = je.start * Ve
              , st = (je.start + je.count) * Ve;
            Me !== null && ($e = Math.max($e, Me.start * Ve),
            st = Math.min(st, (Me.start + Me.count) * Ve)),
            Oe !== null ? ($e = Math.max($e, 0),
            st = Math.min(st, Oe.count)) : He != null && ($e = Math.max($e, 0),
            st = Math.min(st, He.count));
            const dt = st - $e;
            if (dt < 0 || dt === 1 / 0)
                return;
            ke.setup(Q, se, Fe, ie, Oe);
            let pt, tt = _e;
            if (Oe !== null && (pt = M.get(Oe),
            tt = Ue,
            tt.setIndex(pt)),
            Q.isMesh)
                se.wireframe === !0 ? ($.setLineWidth(se.wireframeLinewidth * K()),
                tt.setMode(x.LINES)) : tt.setMode(x.TRIANGLES);
            else if (Q.isLine) {
                let Xe = se.linewidth;
                Xe === void 0 && (Xe = 1),
                $.setLineWidth(Xe * K()),
                Q.isLineSegments ? tt.setMode(x.LINES) : Q.isLineLoop ? tt.setMode(x.LINE_LOOP) : tt.setMode(x.LINE_STRIP)
            } else
                Q.isPoints ? tt.setMode(x.POINTS) : Q.isSprite && tt.setMode(x.TRIANGLES);
            if (Q.isBatchedMesh)
                if (Q._multiDrawInstances !== null)
                    _i("THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."),
                    tt.renderMultiDrawInstances(Q._multiDrawStarts, Q._multiDrawCounts, Q._multiDrawCount, Q._multiDrawInstances);
                else if (W.get("WEBGL_multi_draw"))
                    tt.renderMultiDraw(Q._multiDrawStarts, Q._multiDrawCounts, Q._multiDrawCount);
                else {
                    const Xe = Q._multiDrawStarts
                      , Et = Q._multiDrawCounts
                      , nt = Q._multiDrawCount
                      , an = Oe ? M.get(Oe).bytesPerElement : 1
                      , yi = he.get(se).currentProgram.getUniforms();
                    for (let Wt = 0; Wt < nt; Wt++)
                        yi.setValue(x, "_gl_DrawID", Wt),
                        tt.render(Xe[Wt] / an, Et[Wt])
                }
            else if (Q.isInstancedMesh)
                tt.renderInstances($e, dt, Q.count);
            else if (ie.isInstancedBufferGeometry) {
                const Xe = ie._maxInstanceCount !== void 0 ? ie._maxInstanceCount : 1 / 0
                  , Et = Math.min(ie.instanceCount, Xe);
                tt.renderInstances($e, dt, Et)
            } else
                tt.render($e, dt)
        }
        ;
        function it(E, Z, ie) {
            E.transparent === !0 && E.side === $t && E.forceSinglePass === !1 ? (E.side = Vt,
            E.needsUpdate = !0,
            Ws(E, Z, ie),
            E.side = Hn,
            E.needsUpdate = !0,
            Ws(E, Z, ie),
            E.side = $t) : Ws(E, Z, ie)
        }
        this.compile = function(E, Z, ie=null) {
            ie === null && (ie = E),
            p = de.get(ie),
            p.init(Z),
            w.push(p),
            ie.traverseVisible(function(Q) {
                Q.isLight && Q.layers.test(Z.layers) && (p.pushLight(Q),
                Q.castShadow && p.pushShadow(Q))
            }),
            E !== ie && E.traverseVisible(function(Q) {
                Q.isLight && Q.layers.test(Z.layers) && (p.pushLight(Q),
                Q.castShadow && p.pushShadow(Q))
            }),
            p.setupLights();
            const se = new Set;
            return E.traverse(function(Q) {
                if (!(Q.isMesh || Q.isPoints || Q.isLine || Q.isSprite))
                    return;
                const Me = Q.material;
                if (Me)
                    if (Array.isArray(Me))
                        for (let Re = 0; Re < Me.length; Re++) {
                            const Fe = Me[Re];
                            it(Fe, ie, Q),
                            se.add(Fe)
                        }
                    else
                        it(Me, ie, Q),
                        se.add(Me)
            }),
            p = w.pop(),
            se
        }
        ,
        this.compileAsync = function(E, Z, ie=null) {
            const se = this.compile(E, Z, ie);
            return new Promise(Q => {
                function Me() {
                    if (se.forEach(function(Re) {
                        he.get(Re).currentProgram.isReady() && se.delete(Re)
                    }),
                    se.size === 0) {
                        Q(E);
                        return
                    }
                    setTimeout(Me, 10)
                }
                W.get("KHR_parallel_shader_compile") !== null ? Me() : setTimeout(Me, 10)
            }
            )
        }
        ;
        let on = null;
        function Tn(E) {
            on && on(E)
        }
        function Ac() {
            ni.stop()
        }
        function gc() {
            ni.start()
        }
        const ni = new Ju;
        ni.setAnimationLoop(Tn),
        typeof self < "u" && ni.setContext(self),
        this.setAnimationLoop = function(E) {
            on = E,
            ve.setAnimationLoop(E),
            E === null ? ni.stop() : ni.start()
        }
        ,
        ve.addEventListener("sessionstart", Ac),
        ve.addEventListener("sessionend", gc),
        this.render = function(E, Z) {
            if (Z !== void 0 && Z.isCamera !== !0) {
                console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                return
            }
            if (B === !0)
                return;
            if (E.matrixWorldAutoUpdate === !0 && E.updateMatrixWorld(),
            Z.parent === null && Z.matrixWorldAutoUpdate === !0 && Z.updateMatrixWorld(),
            ve.enabled === !0 && ve.isPresenting === !0 && (ve.cameraAutoUpdate === !0 && ve.updateCamera(Z),
            Z = ve.getCamera()),
            E.isScene === !0 && E.onBeforeRender(b, E, Z, H),
            p = de.get(E, w.length),
            p.init(Z),
            w.push(p),
            le.multiplyMatrices(Z.projectionMatrix, Z.matrixWorldInverse),
            X.setFromProjectionMatrix(le),
            ae = this.localClippingEnabled,
            ne = Ee.init(this.clippingPlanes, ae),
            A = we.get(E, S.length),
            A.init(),
            S.push(A),
            ve.enabled === !0 && ve.isPresenting === !0) {
                const Me = b.xr.getDepthSensingMesh();
                Me !== null && Kr(Me, Z, -1 / 0, b.sortObjects)
            }
            Kr(E, Z, 0, b.sortObjects),
            A.finish(),
            b.sortObjects === !0 && A.sort(L, R),
            G = ve.enabled === !1 || ve.isPresenting === !1 || ve.hasDepthSensing() === !1,
            G && fe.addToRenderList(A, E),
            this.info.render.frame++,
            ne === !0 && Ee.beginShadows();
            const ie = p.state.shadowsArray;
            Pe.render(ie, E, Z),
            ne === !0 && Ee.endShadows(),
            this.info.autoReset === !0 && this.info.reset();
            const se = A.opaque
              , Q = A.transmissive;
            if (p.setupLights(),
            Z.isArrayCamera) {
                const Me = Z.cameras;
                if (Q.length > 0)
                    for (let Re = 0, Fe = Me.length; Re < Fe; Re++) {
                        const Oe = Me[Re];
                        xc(se, Q, E, Oe)
                    }
                G && fe.render(E);
                for (let Re = 0, Fe = Me.length; Re < Fe; Re++) {
                    const Oe = Me[Re];
                    vc(A, E, Oe, Oe.viewport)
                }
            } else
                Q.length > 0 && xc(se, Q, E, Z),
                G && fe.render(E),
                vc(A, E, Z);
            H !== null && I === 0 && (ge.updateMultisampleRenderTarget(H),
            ge.updateRenderTargetMipmap(H)),
            E.isScene === !0 && E.onAfterRender(b, E, Z),
            ke.resetDefaultState(),
            P = -1,
            T = null,
            w.pop(),
            w.length > 0 ? (p = w[w.length - 1],
            ne === !0 && Ee.setGlobalState(b.clippingPlanes, p.state.camera)) : p = null,
            S.pop(),
            S.length > 0 ? A = S[S.length - 1] : A = null
        }
        ;
        function Kr(E, Z, ie, se) {
            if (E.visible === !1)
                return;
            if (E.layers.test(Z.layers)) {
                if (E.isGroup)
                    ie = E.renderOrder;
                else if (E.isLOD)
                    E.autoUpdate === !0 && E.update(Z);
                else if (E.isLight)
                    p.pushLight(E),
                    E.castShadow && p.pushShadow(E);
                else if (E.isSprite) {
                    if (!E.frustumCulled || X.intersectsSprite(E)) {
                        se && ye.setFromMatrixPosition(E.matrixWorld).applyMatrix4(le);
                        const Re = J.update(E)
                          , Fe = E.material;
                        Fe.visible && A.push(E, Re, Fe, ie, ye.z, null)
                    }
                } else if ((E.isMesh || E.isLine || E.isPoints) && (!E.frustumCulled || X.intersectsObject(E))) {
                    const Re = J.update(E)
                      , Fe = E.material;
                    if (se && (E.boundingSphere !== void 0 ? (E.boundingSphere === null && E.computeBoundingSphere(),
                    ye.copy(E.boundingSphere.center)) : (Re.boundingSphere === null && Re.computeBoundingSphere(),
                    ye.copy(Re.boundingSphere.center)),
                    ye.applyMatrix4(E.matrixWorld).applyMatrix4(le)),
                    Array.isArray(Fe)) {
                        const Oe = Re.groups;
                        for (let Ve = 0, je = Oe.length; Ve < je; Ve++) {
                            const He = Oe[Ve]
                              , $e = Fe[He.materialIndex];
                            $e && $e.visible && A.push(E, Re, $e, ie, ye.z, He)
                        }
                    } else
                        Fe.visible && A.push(E, Re, Fe, ie, ye.z, null)
                }
            }
            const Me = E.children;
            for (let Re = 0, Fe = Me.length; Re < Fe; Re++)
                Kr(Me[Re], Z, ie, se)
        }
        function vc(E, Z, ie, se) {
            const Q = E.opaque
              , Me = E.transmissive
              , Re = E.transparent;
            p.setupLightsView(ie),
            ne === !0 && Ee.setGlobalState(b.clippingPlanes, ie),
            se && $.viewport(_.copy(se)),
            Q.length > 0 && Vs(Q, Z, ie),
            Me.length > 0 && Vs(Me, Z, ie),
            Re.length > 0 && Vs(Re, Z, ie),
            $.buffers.depth.setTest(!0),
            $.buffers.depth.setMask(!0),
            $.buffers.color.setMask(!0),
            $.setPolygonOffset(!1)
        }
        function xc(E, Z, ie, se) {
            if ((ie.isScene === !0 ? ie.overrideMaterial : null) !== null)
                return;
            p.state.transmissionRenderTarget[se.id] === void 0 && (p.state.transmissionRenderTarget[se.id] = new gi(1,1,{
                generateMipmaps: !0,
                type: W.has("EXT_color_buffer_half_float") || W.has("EXT_color_buffer_float") ? Fs : Mn,
                minFilter: In,
                samples: 4,
                stencilBuffer: s,
                resolveDepthBuffer: !1,
                resolveStencilBuffer: !1,
                colorSpace: et.workingColorSpace
            }));
            const Me = p.state.transmissionRenderTarget[se.id]
              , Re = se.viewport || _;
            Me.setSize(Re.z * b.transmissionResolutionScale, Re.w * b.transmissionResolutionScale);
            const Fe = b.getRenderTarget();
            b.setRenderTarget(Me),
            b.getClearColor(U),
            F = b.getClearAlpha(),
            F < 1 && b.setClearColor(16777215, .5),
            b.clear(),
            G && fe.render(ie);
            const Oe = b.toneMapping;
            b.toneMapping = ti;
            const Ve = se.viewport;
            if (se.viewport !== void 0 && (se.viewport = void 0),
            p.setupLightsView(se),
            ne === !0 && Ee.setGlobalState(b.clippingPlanes, se),
            Vs(E, ie, se),
            ge.updateMultisampleRenderTarget(Me),
            ge.updateRenderTargetMipmap(Me),
            W.has("WEBGL_multisampled_render_to_texture") === !1) {
                let je = !1;
                for (let He = 0, $e = Z.length; He < $e; He++) {
                    const st = Z[He]
                      , dt = st.object
                      , pt = st.geometry
                      , tt = st.material
                      , Xe = st.group;
                    if (tt.side === $t && dt.layers.test(se.layers)) {
                        const Et = tt.side;
                        tt.side = Vt,
                        tt.needsUpdate = !0,
                        yc(dt, ie, se, pt, tt, Xe),
                        tt.side = Et,
                        tt.needsUpdate = !0,
                        je = !0
                    }
                }
                je === !0 && (ge.updateMultisampleRenderTarget(Me),
                ge.updateRenderTargetMipmap(Me))
            }
            b.setRenderTarget(Fe),
            b.setClearColor(U, F),
            Ve !== void 0 && (se.viewport = Ve),
            b.toneMapping = Oe
        }
        function Vs(E, Z, ie) {
            const se = Z.isScene === !0 ? Z.overrideMaterial : null;
            for (let Q = 0, Me = E.length; Q < Me; Q++) {
                const Re = E[Q]
                  , Fe = Re.object
                  , Oe = Re.geometry
                  , Ve = Re.group;
                let je = Re.material;
                je.allowOverride === !0 && se !== null && (je = se),
                Fe.layers.test(ie.layers) && yc(Fe, Z, ie, Oe, je, Ve)
            }
        }
        function yc(E, Z, ie, se, Q, Me) {
            E.onBeforeRender(b, Z, ie, se, Q, Me),
            E.modelViewMatrix.multiplyMatrices(ie.matrixWorldInverse, E.matrixWorld),
            E.normalMatrix.getNormalMatrix(E.modelViewMatrix),
            Q.onBeforeRender(b, Z, ie, se, E, Me),
            Q.transparent === !0 && Q.side === $t && Q.forceSinglePass === !1 ? (Q.side = Vt,
            Q.needsUpdate = !0,
            b.renderBufferDirect(ie, Z, se, Q, E, Me),
            Q.side = Hn,
            Q.needsUpdate = !0,
            b.renderBufferDirect(ie, Z, se, Q, E, Me),
            Q.side = $t) : b.renderBufferDirect(ie, Z, se, Q, E, Me),
            E.onAfterRender(b, Z, ie, se, Q, Me)
        }
        function Ws(E, Z, ie) {
            Z.isScene !== !0 && (Z = Te);
            const se = he.get(E)
              , Q = p.state.lights
              , Me = p.state.shadowsArray
              , Re = Q.state.version
              , Fe = ee.getParameters(E, Q.state, Me, Z, ie)
              , Oe = ee.getProgramCacheKey(Fe);
            let Ve = se.programs;
            se.environment = E.isMeshStandardMaterial ? Z.environment : null,
            se.fog = Z.fog,
            se.envMap = (E.isMeshStandardMaterial ? N : De).get(E.envMap || se.environment),
            se.envMapRotation = se.environment !== null && E.envMap === null ? Z.environmentRotation : E.envMapRotation,
            Ve === void 0 && (E.addEventListener("dispose", Be),
            Ve = new Map,
            se.programs = Ve);
            let je = Ve.get(Oe);
            if (je !== void 0) {
                if (se.currentProgram === je && se.lightsStateVersion === Re)
                    return Mc(E, Fe),
                    je
            } else
                Fe.uniforms = ee.getUniforms(E),
                E.onBeforeCompile(Fe, b),
                je = ee.acquireProgram(Fe, Oe),
                Ve.set(Oe, je),
                se.uniforms = Fe.uniforms;
            const He = se.uniforms;
            return (!E.isShaderMaterial && !E.isRawShaderMaterial || E.clipping === !0) && (He.clippingPlanes = Ee.uniform),
            Mc(E, Fe),
            se.needsLights = dh(E),
            se.lightsStateVersion = Re,
            se.needsLights && (He.ambientLightColor.value = Q.state.ambient,
            He.lightProbe.value = Q.state.probe,
            He.directionalLights.value = Q.state.directional,
            He.directionalLightShadows.value = Q.state.directionalShadow,
            He.spotLights.value = Q.state.spot,
            He.spotLightShadows.value = Q.state.spotShadow,
            He.rectAreaLights.value = Q.state.rectArea,
            He.ltc_1.value = Q.state.rectAreaLTC1,
            He.ltc_2.value = Q.state.rectAreaLTC2,
            He.pointLights.value = Q.state.point,
            He.pointLightShadows.value = Q.state.pointShadow,
            He.hemisphereLights.value = Q.state.hemi,
            He.directionalShadowMap.value = Q.state.directionalShadowMap,
            He.directionalShadowMatrix.value = Q.state.directionalShadowMatrix,
            He.spotShadowMap.value = Q.state.spotShadowMap,
            He.spotLightMatrix.value = Q.state.spotLightMatrix,
            He.spotLightMap.value = Q.state.spotLightMap,
            He.pointShadowMap.value = Q.state.pointShadowMap,
            He.pointShadowMatrix.value = Q.state.pointShadowMatrix),
            se.currentProgram = je,
            se.uniformsList = null,
            je
        }
        function bc(E) {
            if (E.uniformsList === null) {
                const Z = E.currentProgram.getUniforms();
                E.uniformsList = Ir.seqWithValue(Z.seq, E.uniforms)
            }
            return E.uniformsList
        }
        function Mc(E, Z) {
            const ie = he.get(E);
            ie.outputColorSpace = Z.outputColorSpace,
            ie.batching = Z.batching,
            ie.batchingColor = Z.batchingColor,
            ie.instancing = Z.instancing,
            ie.instancingColor = Z.instancingColor,
            ie.instancingMorph = Z.instancingMorph,
            ie.skinning = Z.skinning,
            ie.morphTargets = Z.morphTargets,
            ie.morphNormals = Z.morphNormals,
            ie.morphColors = Z.morphColors,
            ie.morphTargetsCount = Z.morphTargetsCount,
            ie.numClippingPlanes = Z.numClippingPlanes,
            ie.numIntersection = Z.numClipIntersection,
            ie.vertexAlphas = Z.vertexAlphas,
            ie.vertexTangents = Z.vertexTangents,
            ie.toneMapping = Z.toneMapping
        }
        function uh(E, Z, ie, se, Q) {
            Z.isScene !== !0 && (Z = Te),
            ge.resetTextureUnits();
            const Me = Z.fog
              , Re = se.isMeshStandardMaterial ? Z.environment : null
              , Fe = H === null ? b.outputColorSpace : H.isXRRenderTarget === !0 ? H.texture.colorSpace : Ht
              , Oe = (se.isMeshStandardMaterial ? N : De).get(se.envMap || Re)
              , Ve = se.vertexColors === !0 && !!ie.attributes.color && ie.attributes.color.itemSize === 4
              , je = !!ie.attributes.tangent && (!!se.normalMap || se.anisotropy > 0)
              , He = !!ie.morphAttributes.position
              , $e = !!ie.morphAttributes.normal
              , st = !!ie.morphAttributes.color;
            let dt = ti;
            se.toneMapped && (H === null || H.isXRRenderTarget === !0) && (dt = b.toneMapping);
            const pt = ie.morphAttributes.position || ie.morphAttributes.normal || ie.morphAttributes.color
              , tt = pt !== void 0 ? pt.length : 0
              , Xe = he.get(se)
              , Et = p.state.lights;
            if (ne === !0 && (ae === !0 || E !== T)) {
                const zt = E === T && se.id === P;
                Ee.setState(se, E, zt)
            }
            let nt = !1;
            se.version === Xe.__version ? (Xe.needsLights && Xe.lightsStateVersion !== Et.state.version || Xe.outputColorSpace !== Fe || Q.isBatchedMesh && Xe.batching === !1 || !Q.isBatchedMesh && Xe.batching === !0 || Q.isBatchedMesh && Xe.batchingColor === !0 && Q.colorTexture === null || Q.isBatchedMesh && Xe.batchingColor === !1 && Q.colorTexture !== null || Q.isInstancedMesh && Xe.instancing === !1 || !Q.isInstancedMesh && Xe.instancing === !0 || Q.isSkinnedMesh && Xe.skinning === !1 || !Q.isSkinnedMesh && Xe.skinning === !0 || Q.isInstancedMesh && Xe.instancingColor === !0 && Q.instanceColor === null || Q.isInstancedMesh && Xe.instancingColor === !1 && Q.instanceColor !== null || Q.isInstancedMesh && Xe.instancingMorph === !0 && Q.morphTexture === null || Q.isInstancedMesh && Xe.instancingMorph === !1 && Q.morphTexture !== null || Xe.envMap !== Oe || se.fog === !0 && Xe.fog !== Me || Xe.numClippingPlanes !== void 0 && (Xe.numClippingPlanes !== Ee.numPlanes || Xe.numIntersection !== Ee.numIntersection) || Xe.vertexAlphas !== Ve || Xe.vertexTangents !== je || Xe.morphTargets !== He || Xe.morphNormals !== $e || Xe.morphColors !== st || Xe.toneMapping !== dt || Xe.morphTargetsCount !== tt) && (nt = !0) : (nt = !0,
            Xe.__version = se.version);
            let an = Xe.currentProgram;
            nt === !0 && (an = Ws(se, Z, Q));
            let yi = !1
              , Wt = !1
              , ss = !1;
            const ht = an.getUniforms()
              , qt = Xe.uniforms;
            if ($.useProgram(an.program) && (yi = !0,
            Wt = !0,
            ss = !0),
            se.id !== P && (P = se.id,
            Wt = !0),
            yi || T !== E) {
                $.buffers.depth.getReversed() ? (ce.copy(E.projectionMatrix),
                Td(ce),
                Ed(ce),
                ht.setValue(x, "projectionMatrix", ce)) : ht.setValue(x, "projectionMatrix", E.projectionMatrix),
                ht.setValue(x, "viewMatrix", E.matrixWorldInverse);
                const Xt = ht.map.cameraPosition;
                Xt !== void 0 && Xt.setValue(x, xe.setFromMatrixPosition(E.matrixWorld)),
                oe.logarithmicDepthBuffer && ht.setValue(x, "logDepthBufFC", 2 / (Math.log(E.far + 1) / Math.LN2)),
                (se.isMeshPhongMaterial || se.isMeshToonMaterial || se.isMeshLambertMaterial || se.isMeshBasicMaterial || se.isMeshStandardMaterial || se.isShaderMaterial) && ht.setValue(x, "isOrthographic", E.isOrthographicCamera === !0),
                T !== E && (T = E,
                Wt = !0,
                ss = !0)
            }
            if (Q.isSkinnedMesh) {
                ht.setOptional(x, Q, "bindMatrix"),
                ht.setOptional(x, Q, "bindMatrixInverse");
                const zt = Q.skeleton;
                zt && (zt.boneTexture === null && zt.computeBoneTexture(),
                ht.setValue(x, "boneTexture", zt.boneTexture, ge))
            }
            Q.isBatchedMesh && (ht.setOptional(x, Q, "batchingTexture"),
            ht.setValue(x, "batchingTexture", Q._matricesTexture, ge),
            ht.setOptional(x, Q, "batchingIdTexture"),
            ht.setValue(x, "batchingIdTexture", Q._indirectTexture, ge),
            ht.setOptional(x, Q, "batchingColorTexture"),
            Q._colorsTexture !== null && ht.setValue(x, "batchingColorTexture", Q._colorsTexture, ge));
            const Zt = ie.morphAttributes;
            if ((Zt.position !== void 0 || Zt.normal !== void 0 || Zt.color !== void 0) && Ne.update(Q, ie, an),
            (Wt || Xe.receiveShadow !== Q.receiveShadow) && (Xe.receiveShadow = Q.receiveShadow,
            ht.setValue(x, "receiveShadow", Q.receiveShadow)),
            se.isMeshGouraudMaterial && se.envMap !== null && (qt.envMap.value = Oe,
            qt.flipEnvMap.value = Oe.isCubeTexture && Oe.isRenderTargetTexture === !1 ? -1 : 1),
            se.isMeshStandardMaterial && se.envMap === null && Z.environment !== null && (qt.envMapIntensity.value = Z.environmentIntensity),
            Wt && (ht.setValue(x, "toneMappingExposure", b.toneMappingExposure),
            Xe.needsLights && hh(qt, ss),
            Me && se.fog === !0 && te.refreshFogUniforms(qt, Me),
            te.refreshMaterialUniforms(qt, se, v, y, p.state.transmissionRenderTarget[E.id]),
            Ir.upload(x, bc(Xe), qt, ge)),
            se.isShaderMaterial && se.uniformsNeedUpdate === !0 && (Ir.upload(x, bc(Xe), qt, ge),
            se.uniformsNeedUpdate = !1),
            se.isSpriteMaterial && ht.setValue(x, "center", Q.center),
            ht.setValue(x, "modelViewMatrix", Q.modelViewMatrix),
            ht.setValue(x, "normalMatrix", Q.normalMatrix),
            ht.setValue(x, "modelMatrix", Q.matrixWorld),
            se.isShaderMaterial || se.isRawShaderMaterial) {
                const zt = se.uniformsGroups;
                for (let Xt = 0, Qr = zt.length; Xt < Qr; Xt++) {
                    const ii = zt[Xt];
                    j.update(ii, an),
                    j.bind(ii, an)
                }
            }
            return an
        }
        function hh(E, Z) {
            E.ambientLightColor.needsUpdate = Z,
            E.lightProbe.needsUpdate = Z,
            E.directionalLights.needsUpdate = Z,
            E.directionalLightShadows.needsUpdate = Z,
            E.pointLights.needsUpdate = Z,
            E.pointLightShadows.needsUpdate = Z,
            E.spotLights.needsUpdate = Z,
            E.spotLightShadows.needsUpdate = Z,
            E.rectAreaLights.needsUpdate = Z,
            E.hemisphereLights.needsUpdate = Z
        }
        function dh(E) {
            return E.isMeshLambertMaterial || E.isMeshToonMaterial || E.isMeshPhongMaterial || E.isMeshStandardMaterial || E.isShadowMaterial || E.isShaderMaterial && E.lights === !0
        }
        this.getActiveCubeFace = function() {
            return z
        }
        ,
        this.getActiveMipmapLevel = function() {
            return I
        }
        ,
        this.getRenderTarget = function() {
            return H
        }
        ,
        this.setRenderTargetTextures = function(E, Z, ie) {
            const se = he.get(E);
            se.__autoAllocateDepthBuffer = E.resolveDepthBuffer === !1,
            se.__autoAllocateDepthBuffer === !1 && (se.__useRenderToTexture = !1),
            he.get(E.texture).__webglTexture = Z,
            he.get(E.depthTexture).__webglTexture = se.__autoAllocateDepthBuffer ? void 0 : ie,
            se.__hasExternalTextures = !0
        }
        ,
        this.setRenderTargetFramebuffer = function(E, Z) {
            const ie = he.get(E);
            ie.__webglFramebuffer = Z,
            ie.__useDefaultFramebuffer = Z === void 0
        }
        ;
        const fh = x.createFramebuffer();
        this.setRenderTarget = function(E, Z=0, ie=0) {
            H = E,
            z = Z,
            I = ie;
            let se = !0
              , Q = null
              , Me = !1
              , Re = !1;
            if (E) {
                const Oe = he.get(E);
                if (Oe.__useDefaultFramebuffer !== void 0)
                    $.bindFramebuffer(x.FRAMEBUFFER, null),
                    se = !1;
                else if (Oe.__webglFramebuffer === void 0)
                    ge.setupRenderTarget(E);
                else if (Oe.__hasExternalTextures)
                    ge.rebindTextures(E, he.get(E.texture).__webglTexture, he.get(E.depthTexture).__webglTexture);
                else if (E.depthBuffer) {
                    const He = E.depthTexture;
                    if (Oe.__boundDepthTexture !== He) {
                        if (He !== null && he.has(He) && (E.width !== He.image.width || E.height !== He.image.height))
                            throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
                        ge.setupDepthRenderbuffer(E)
                    }
                }
                const Ve = E.texture;
                (Ve.isData3DTexture || Ve.isDataArrayTexture || Ve.isCompressedArrayTexture) && (Re = !0);
                const je = he.get(E).__webglFramebuffer;
                E.isWebGLCubeRenderTarget ? (Array.isArray(je[Z]) ? Q = je[Z][ie] : Q = je[Z],
                Me = !0) : E.samples > 0 && ge.useMultisampledRTT(E) === !1 ? Q = he.get(E).__webglMultisampledFramebuffer : Array.isArray(je) ? Q = je[ie] : Q = je,
                _.copy(E.viewport),
                re.copy(E.scissor),
                k = E.scissorTest
            } else
                _.copy(C).multiplyScalar(v).floor(),
                re.copy(Y).multiplyScalar(v).floor(),
                k = ue;
            if (ie !== 0 && (Q = fh),
            $.bindFramebuffer(x.FRAMEBUFFER, Q) && se && $.drawBuffers(E, Q),
            $.viewport(_),
            $.scissor(re),
            $.setScissorTest(k),
            Me) {
                const Oe = he.get(E.texture);
                x.framebufferTexture2D(x.FRAMEBUFFER, x.COLOR_ATTACHMENT0, x.TEXTURE_CUBE_MAP_POSITIVE_X + Z, Oe.__webglTexture, ie)
            } else if (Re) {
                const Oe = he.get(E.texture)
                  , Ve = Z;
                x.framebufferTextureLayer(x.FRAMEBUFFER, x.COLOR_ATTACHMENT0, Oe.__webglTexture, ie, Ve)
            } else if (E !== null && ie !== 0) {
                const Oe = he.get(E.texture);
                x.framebufferTexture2D(x.FRAMEBUFFER, x.COLOR_ATTACHMENT0, x.TEXTURE_2D, Oe.__webglTexture, ie)
            }
            P = -1
        }
        ,
        this.readRenderTargetPixels = function(E, Z, ie, se, Q, Me, Re, Fe=0) {
            if (!(E && E.isWebGLRenderTarget)) {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                return
            }
            let Oe = he.get(E).__webglFramebuffer;
            if (E.isWebGLCubeRenderTarget && Re !== void 0 && (Oe = Oe[Re]),
            Oe) {
                $.bindFramebuffer(x.FRAMEBUFFER, Oe);
                try {
                    const Ve = E.textures[Fe]
                      , je = Ve.format
                      , He = Ve.type;
                    if (!oe.textureFormatReadable(je)) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        return
                    }
                    if (!oe.textureTypeReadable(He)) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        return
                    }
                    Z >= 0 && Z <= E.width - se && ie >= 0 && ie <= E.height - Q && (E.textures.length > 1 && x.readBuffer(x.COLOR_ATTACHMENT0 + Fe),
                    x.readPixels(Z, ie, se, Q, Le.convert(je), Le.convert(He), Me))
                } finally {
                    const Ve = H !== null ? he.get(H).__webglFramebuffer : null;
                    $.bindFramebuffer(x.FRAMEBUFFER, Ve)
                }
            }
        }
        ,
        this.readRenderTargetPixelsAsync = async function(E, Z, ie, se, Q, Me, Re, Fe=0) {
            if (!(E && E.isWebGLRenderTarget))
                throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            let Oe = he.get(E).__webglFramebuffer;
            if (E.isWebGLCubeRenderTarget && Re !== void 0 && (Oe = Oe[Re]),
            Oe)
                if (Z >= 0 && Z <= E.width - se && ie >= 0 && ie <= E.height - Q) {
                    $.bindFramebuffer(x.FRAMEBUFFER, Oe);
                    const Ve = E.textures[Fe]
                      , je = Ve.format
                      , He = Ve.type;
                    if (!oe.textureFormatReadable(je))
                        throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
                    if (!oe.textureTypeReadable(He))
                        throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
                    const $e = x.createBuffer();
                    x.bindBuffer(x.PIXEL_PACK_BUFFER, $e),
                    x.bufferData(x.PIXEL_PACK_BUFFER, Me.byteLength, x.STREAM_READ),
                    E.textures.length > 1 && x.readBuffer(x.COLOR_ATTACHMENT0 + Fe),
                    x.readPixels(Z, ie, se, Q, Le.convert(je), Le.convert(He), 0);
                    const st = H !== null ? he.get(H).__webglFramebuffer : null;
                    $.bindFramebuffer(x.FRAMEBUFFER, st);
                    const dt = x.fenceSync(x.SYNC_GPU_COMMANDS_COMPLETE, 0);
                    return x.flush(),
                    await Sd(x, dt, 4),
                    x.bindBuffer(x.PIXEL_PACK_BUFFER, $e),
                    x.getBufferSubData(x.PIXEL_PACK_BUFFER, 0, Me),
                    x.deleteBuffer($e),
                    x.deleteSync(dt),
                    Me
                } else
                    throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")
        }
        ,
        this.copyFramebufferToTexture = function(E, Z=null, ie=0) {
            const se = Math.pow(2, -ie)
              , Q = Math.floor(E.image.width * se)
              , Me = Math.floor(E.image.height * se)
              , Re = Z !== null ? Z.x : 0
              , Fe = Z !== null ? Z.y : 0;
            ge.setTexture2D(E, 0),
            x.copyTexSubImage2D(x.TEXTURE_2D, ie, 0, 0, Re, Fe, Q, Me),
            $.unbindTexture()
        }
        ;
        const ph = x.createFramebuffer()
          , mh = x.createFramebuffer();
        this.copyTextureToTexture = function(E, Z, ie=null, se=null, Q=0, Me=null) {
            Me === null && (Q !== 0 ? (_i("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."),
            Me = Q,
            Q = 0) : Me = 0);
            let Re, Fe, Oe, Ve, je, He, $e, st, dt;
            const pt = E.isCompressedTexture ? E.mipmaps[Me] : E.image;
            if (ie !== null)
                Re = ie.max.x - ie.min.x,
                Fe = ie.max.y - ie.min.y,
                Oe = ie.isBox3 ? ie.max.z - ie.min.z : 1,
                Ve = ie.min.x,
                je = ie.min.y,
                He = ie.isBox3 ? ie.min.z : 0;
            else {
                const Zt = Math.pow(2, -Q);
                Re = Math.floor(pt.width * Zt),
                Fe = Math.floor(pt.height * Zt),
                E.isDataArrayTexture ? Oe = pt.depth : E.isData3DTexture ? Oe = Math.floor(pt.depth * Zt) : Oe = 1,
                Ve = 0,
                je = 0,
                He = 0
            }
            se !== null ? ($e = se.x,
            st = se.y,
            dt = se.z) : ($e = 0,
            st = 0,
            dt = 0);
            const tt = Le.convert(Z.format)
              , Xe = Le.convert(Z.type);
            let Et;
            Z.isData3DTexture ? (ge.setTexture3D(Z, 0),
            Et = x.TEXTURE_3D) : Z.isDataArrayTexture || Z.isCompressedArrayTexture ? (ge.setTexture2DArray(Z, 0),
            Et = x.TEXTURE_2D_ARRAY) : (ge.setTexture2D(Z, 0),
            Et = x.TEXTURE_2D),
            x.pixelStorei(x.UNPACK_FLIP_Y_WEBGL, Z.flipY),
            x.pixelStorei(x.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Z.premultiplyAlpha),
            x.pixelStorei(x.UNPACK_ALIGNMENT, Z.unpackAlignment);
            const nt = x.getParameter(x.UNPACK_ROW_LENGTH)
              , an = x.getParameter(x.UNPACK_IMAGE_HEIGHT)
              , yi = x.getParameter(x.UNPACK_SKIP_PIXELS)
              , Wt = x.getParameter(x.UNPACK_SKIP_ROWS)
              , ss = x.getParameter(x.UNPACK_SKIP_IMAGES);
            x.pixelStorei(x.UNPACK_ROW_LENGTH, pt.width),
            x.pixelStorei(x.UNPACK_IMAGE_HEIGHT, pt.height),
            x.pixelStorei(x.UNPACK_SKIP_PIXELS, Ve),
            x.pixelStorei(x.UNPACK_SKIP_ROWS, je),
            x.pixelStorei(x.UNPACK_SKIP_IMAGES, He);
            const ht = E.isDataArrayTexture || E.isData3DTexture
              , qt = Z.isDataArrayTexture || Z.isData3DTexture;
            if (E.isDepthTexture) {
                const Zt = he.get(E)
                  , zt = he.get(Z)
                  , Xt = he.get(Zt.__renderTarget)
                  , Qr = he.get(zt.__renderTarget);
                $.bindFramebuffer(x.READ_FRAMEBUFFER, Xt.__webglFramebuffer),
                $.bindFramebuffer(x.DRAW_FRAMEBUFFER, Qr.__webglFramebuffer);
                for (let ii = 0; ii < Oe; ii++)
                    ht && (x.framebufferTextureLayer(x.READ_FRAMEBUFFER, x.COLOR_ATTACHMENT0, he.get(E).__webglTexture, Q, He + ii),
                    x.framebufferTextureLayer(x.DRAW_FRAMEBUFFER, x.COLOR_ATTACHMENT0, he.get(Z).__webglTexture, Me, dt + ii)),
                    x.blitFramebuffer(Ve, je, Re, Fe, $e, st, Re, Fe, x.DEPTH_BUFFER_BIT, x.NEAREST);
                $.bindFramebuffer(x.READ_FRAMEBUFFER, null),
                $.bindFramebuffer(x.DRAW_FRAMEBUFFER, null)
            } else if (Q !== 0 || E.isRenderTargetTexture || he.has(E)) {
                const Zt = he.get(E)
                  , zt = he.get(Z);
                $.bindFramebuffer(x.READ_FRAMEBUFFER, ph),
                $.bindFramebuffer(x.DRAW_FRAMEBUFFER, mh);
                for (let Xt = 0; Xt < Oe; Xt++)
                    ht ? x.framebufferTextureLayer(x.READ_FRAMEBUFFER, x.COLOR_ATTACHMENT0, Zt.__webglTexture, Q, He + Xt) : x.framebufferTexture2D(x.READ_FRAMEBUFFER, x.COLOR_ATTACHMENT0, x.TEXTURE_2D, Zt.__webglTexture, Q),
                    qt ? x.framebufferTextureLayer(x.DRAW_FRAMEBUFFER, x.COLOR_ATTACHMENT0, zt.__webglTexture, Me, dt + Xt) : x.framebufferTexture2D(x.DRAW_FRAMEBUFFER, x.COLOR_ATTACHMENT0, x.TEXTURE_2D, zt.__webglTexture, Me),
                    Q !== 0 ? x.blitFramebuffer(Ve, je, Re, Fe, $e, st, Re, Fe, x.COLOR_BUFFER_BIT, x.NEAREST) : qt ? x.copyTexSubImage3D(Et, Me, $e, st, dt + Xt, Ve, je, Re, Fe) : x.copyTexSubImage2D(Et, Me, $e, st, Ve, je, Re, Fe);
                $.bindFramebuffer(x.READ_FRAMEBUFFER, null),
                $.bindFramebuffer(x.DRAW_FRAMEBUFFER, null)
            } else
                qt ? E.isDataTexture || E.isData3DTexture ? x.texSubImage3D(Et, Me, $e, st, dt, Re, Fe, Oe, tt, Xe, pt.data) : Z.isCompressedArrayTexture ? x.compressedTexSubImage3D(Et, Me, $e, st, dt, Re, Fe, Oe, tt, pt.data) : x.texSubImage3D(Et, Me, $e, st, dt, Re, Fe, Oe, tt, Xe, pt) : E.isDataTexture ? x.texSubImage2D(x.TEXTURE_2D, Me, $e, st, Re, Fe, tt, Xe, pt.data) : E.isCompressedTexture ? x.compressedTexSubImage2D(x.TEXTURE_2D, Me, $e, st, pt.width, pt.height, tt, pt.data) : x.texSubImage2D(x.TEXTURE_2D, Me, $e, st, Re, Fe, tt, Xe, pt);
            x.pixelStorei(x.UNPACK_ROW_LENGTH, nt),
            x.pixelStorei(x.UNPACK_IMAGE_HEIGHT, an),
            x.pixelStorei(x.UNPACK_SKIP_PIXELS, yi),
            x.pixelStorei(x.UNPACK_SKIP_ROWS, Wt),
            x.pixelStorei(x.UNPACK_SKIP_IMAGES, ss),
            Me === 0 && Z.generateMipmaps && x.generateMipmap(Et),
            $.unbindTexture()
        }
        ,
        this.copyTextureToTexture3D = function(E, Z, ie=null, se=null, Q=0) {
            return _i('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'),
            this.copyTextureToTexture(E, Z, ie, se, Q)
        }
        ,
        this.initRenderTarget = function(E) {
            he.get(E).__webglFramebuffer === void 0 && ge.setupRenderTarget(E)
        }
        ,
        this.initTexture = function(E) {
            E.isCubeTexture ? ge.setTextureCube(E, 0) : E.isData3DTexture ? ge.setTexture3D(E, 0) : E.isDataArrayTexture || E.isCompressedArrayTexture ? ge.setTexture2DArray(E, 0) : ge.setTexture2D(E, 0),
            $.unbindTexture()
        }
        ,
        this.resetState = function() {
            z = 0,
            I = 0,
            H = null,
            $.reset(),
            ke.reset()
        }
        ,
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    get coordinateSystem() {
        return Un
    }
    get outputColorSpace() {
        return this._outputColorSpace
    }
    set outputColorSpace(e) {
        this._outputColorSpace = e;
        const t = this.getContext();
        t.drawingBufferColorSpace = et._getDrawingBufferColorSpace(e),
        t.unpackColorSpace = et._getUnpackColorSpace()
    }
}
class fs {
    static createStandardMaterial(e, t, n, i, s) {
        return new Ki({
            color: e,
            emissive: t,
            emissiveIntensity: n,
            transparent: i,
            opacity: s
        })
    }
    static transitionMaterial(e, t, n=100) {
        const i = Array.isArray(e.material) ? e.material[0] : e.material
          , s = e.clone();
        s.material = i.clone(),
        s.material.transparent = !0,
        s.material.opacity = i.opacity,
        e.parent && e.parent.add(s);
        const o = t.clone();
        o.transparent = !0,
        o.opacity = 0,
        e.material = o;
        const a = performance.now();
        function c() {
            const l = performance.now() - a
              , u = Math.min(l / n, 1);
            s.material.opacity = i.opacity * (1 - u),
            e.material.opacity = u,
            u < 1 ? requestAnimationFrame(c) : (e.parent && e.parent.remove(s),
            e.material.opacity = t.opacity)
        }
        c()
    }
}
class r0 extends lt {
    constructor(e=document.createElement("div")) {
        super(),
        this.isCSS2DObject = !0,
        this.element = e,
        this.element.style.position = "absolute",
        this.element.style.userSelect = "none",
        this.element.setAttribute("draggable", !1),
        this.center = new Ae(.5,.5),
        this.addEventListener("removed", function() {
            this.traverse(function(t) {
                t.element instanceof t.element.ownerDocument.defaultView.Element && t.element.parentNode !== null && t.element.remove()
            })
        })
    }
    copy(e, t) {
        return super.copy(e, t),
        this.element = e.element.cloneNode(!0),
        this.center = e.center,
        this
    }
}
new D;
new We;
new We;
new D;
new D;
const Ql = new xt
  , Tr = new D;
class ih extends ap {
    constructor() {
        super(),
        this.isLineSegmentsGeometry = !0,
        this.type = "LineSegmentsGeometry";
        const e = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0]
          , t = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2]
          , n = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
        this.setIndex(n),
        this.setAttribute("position", new yt(e,3)),
        this.setAttribute("uv", new yt(t,2))
    }
    applyMatrix4(e) {
        const t = this.attributes.instanceStart
          , n = this.attributes.instanceEnd;
        return t !== void 0 && (t.applyMatrix4(e),
        n.applyMatrix4(e),
        t.needsUpdate = !0),
        this.boundingBox !== null && this.computeBoundingBox(),
        this.boundingSphere !== null && this.computeBoundingSphere(),
        this
    }
    setPositions(e) {
        let t;
        e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
        const n = new Ba(t,6,1);
        return this.setAttribute("instanceStart", new Bn(n,3,0)),
        this.setAttribute("instanceEnd", new Bn(n,3,3)),
        this.instanceCount = this.attributes.instanceStart.count,
        this.computeBoundingBox(),
        this.computeBoundingSphere(),
        this
    }
    setColors(e) {
        let t;
        e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
        const n = new Ba(t,6,1);
        return this.setAttribute("instanceColorStart", new Bn(n,3,0)),
        this.setAttribute("instanceColorEnd", new Bn(n,3,3)),
        this
    }
    fromWireframeGeometry(e) {
        return this.setPositions(e.attributes.position.array),
        this
    }
    fromEdgesGeometry(e) {
        return this.setPositions(e.attributes.position.array),
        this
    }
    fromMesh(e) {
        return this.fromWireframeGeometry(new _f(e.geometry)),
        this
    }
    fromLineSegments(e) {
        const t = e.geometry;
        return this.setPositions(t.attributes.position.array),
        this
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new xt);
        const e = this.attributes.instanceStart
          , t = this.attributes.instanceEnd;
        e !== void 0 && t !== void 0 && (this.boundingBox.setFromBufferAttribute(e),
        Ql.setFromBufferAttribute(t),
        this.boundingBox.union(Ql))
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new rn),
        this.boundingBox === null && this.computeBoundingBox();
        const e = this.attributes.instanceStart
          , t = this.attributes.instanceEnd;
        if (e !== void 0 && t !== void 0) {
            const n = this.boundingSphere.center;
            this.boundingBox.getCenter(n);
            let i = 0;
            for (let s = 0, o = e.count; s < o; s++)
                Tr.fromBufferAttribute(e, s),
                i = Math.max(i, n.distanceToSquared(Tr)),
                Tr.fromBufferAttribute(t, s),
                i = Math.max(i, n.distanceToSquared(Tr));
            this.boundingSphere.radius = Math.sqrt(i),
            isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this)
        }
    }
    toJSON() {}
}
Se.line = {
    worldUnits: {
        value: 1
    },
    linewidth: {
        value: 1
    },
    resolution: {
        value: new Ae(1,1)
    },
    dashOffset: {
        value: 0
    },
    dashScale: {
        value: 1
    },
    dashSize: {
        value: 1
    },
    gapSize: {
        value: 1
    }
};
Gt.line = {
    uniforms: sc.merge([Se.common, Se.fog, Se.line]),
    vertexShader: `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );
				vec3 worldUp = normalize( cross( worldDir, tmpFwd ) );
				vec3 worldFwd = cross( worldDir, worldUp );
				worldPos = position.y < 0.5 ? start: end;

				// height offset
				float hw = linewidth * 0.5;
				worldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// cap extension
					worldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;

					// add width to the box
					worldPos.xyz += worldFwd * hw;

					// endcaps
					if ( position.y > 1.0 || position.y < 0.0 ) {

						worldPos.xyz -= worldFwd * 2.0 * hw;

					}

				#endif

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`,
    fragmentShader: `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			float alpha = opacity;
			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
};
class Us extends wn {
    constructor(e) {
        super({
            type: "LineMaterial",
            uniforms: sc.clone(Gt.line.uniforms),
            vertexShader: Gt.line.vertexShader,
            fragmentShader: Gt.line.fragmentShader,
            clipping: !0
        }),
        this.isLineMaterial = !0,
        this.setValues(e)
    }
    get color() {
        return this.uniforms.diffuse.value
    }
    set color(e) {
        this.uniforms.diffuse.value = e
    }
    get worldUnits() {
        return "WORLD_UNITS"in this.defines
    }
    set worldUnits(e) {
        e === !0 ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS
    }
    get linewidth() {
        return this.uniforms.linewidth.value
    }
    set linewidth(e) {
        this.uniforms.linewidth && (this.uniforms.linewidth.value = e)
    }
    get dashed() {
        return "USE_DASH"in this.defines
    }
    set dashed(e) {
        e === !0 !== this.dashed && (this.needsUpdate = !0),
        e === !0 ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH
    }
    get dashScale() {
        return this.uniforms.dashScale.value
    }
    set dashScale(e) {
        this.uniforms.dashScale.value = e
    }
    get dashSize() {
        return this.uniforms.dashSize.value
    }
    set dashSize(e) {
        this.uniforms.dashSize.value = e
    }
    get dashOffset() {
        return this.uniforms.dashOffset.value
    }
    set dashOffset(e) {
        this.uniforms.dashOffset.value = e
    }
    get gapSize() {
        return this.uniforms.gapSize.value
    }
    set gapSize(e) {
        this.uniforms.gapSize.value = e
    }
    get opacity() {
        return this.uniforms.opacity.value
    }
    set opacity(e) {
        this.uniforms && (this.uniforms.opacity.value = e)
    }
    get resolution() {
        return this.uniforms.resolution.value
    }
    set resolution(e) {
        this.uniforms.resolution.value.copy(e)
    }
    get alphaToCoverage() {
        return "USE_ALPHA_TO_COVERAGE"in this.defines
    }
    set alphaToCoverage(e) {
        this.defines && (e === !0 !== this.alphaToCoverage && (this.needsUpdate = !0),
        e === !0 ? this.defines.USE_ALPHA_TO_COVERAGE = "" : delete this.defines.USE_ALPHA_TO_COVERAGE)
    }
}
const Fo = new Je
  , Jl = new D
  , $l = new D
  , Pt = new Je
  , Lt = new Je
  , An = new Je
  , _o = new D
  , Ho = new We
  , Ct = new xp
  , eu = new D
  , Er = new xt
  , Pr = new rn
  , gn = new Je;
let yn, mi;
function tu(r, e, t) {
    return gn.set(0, 0, -e, 1).applyMatrix4(r.projectionMatrix),
    gn.multiplyScalar(1 / gn.w),
    gn.x = mi / t.width,
    gn.y = mi / t.height,
    gn.applyMatrix4(r.projectionMatrixInverse),
    gn.multiplyScalar(1 / gn.w),
    Math.abs(Math.max(gn.x, gn.y))
}
function o0(r, e) {
    const t = r.matrixWorld
      , n = r.geometry
      , i = n.attributes.instanceStart
      , s = n.attributes.instanceEnd
      , o = Math.min(n.instanceCount, i.count);
    for (let a = 0, c = o; a < c; a++) {
        Ct.start.fromBufferAttribute(i, a),
        Ct.end.fromBufferAttribute(s, a),
        Ct.applyMatrix4(t);
        const l = new D
          , u = new D;
        yn.distanceSqToSegment(Ct.start, Ct.end, u, l),
        u.distanceTo(l) < mi * .5 && e.push({
            point: u,
            pointOnLine: l,
            distance: yn.origin.distanceTo(u),
            object: r,
            face: null,
            faceIndex: a,
            uv: null,
            uv1: null
        })
    }
}
function a0(r, e, t) {
    const n = e.projectionMatrix
      , s = r.material.resolution
      , o = r.matrixWorld
      , a = r.geometry
      , c = a.attributes.instanceStart
      , l = a.attributes.instanceEnd
      , u = Math.min(a.instanceCount, c.count)
      , h = -e.near;
    yn.at(1, An),
    An.w = 1,
    An.applyMatrix4(e.matrixWorldInverse),
    An.applyMatrix4(n),
    An.multiplyScalar(1 / An.w),
    An.x *= s.x / 2,
    An.y *= s.y / 2,
    An.z = 0,
    _o.copy(An),
    Ho.multiplyMatrices(e.matrixWorldInverse, o);
    for (let d = 0, f = u; d < f; d++) {
        if (Pt.fromBufferAttribute(c, d),
        Lt.fromBufferAttribute(l, d),
        Pt.w = 1,
        Lt.w = 1,
        Pt.applyMatrix4(Ho),
        Lt.applyMatrix4(Ho),
        Pt.z > h && Lt.z > h)
            continue;
        if (Pt.z > h) {
            const w = Pt.z - Lt.z
              , b = (Pt.z - h) / w;
            Pt.lerp(Lt, b)
        } else if (Lt.z > h) {
            const w = Lt.z - Pt.z
              , b = (Lt.z - h) / w;
            Lt.lerp(Pt, b)
        }
        Pt.applyMatrix4(n),
        Lt.applyMatrix4(n),
        Pt.multiplyScalar(1 / Pt.w),
        Lt.multiplyScalar(1 / Lt.w),
        Pt.x *= s.x / 2,
        Pt.y *= s.y / 2,
        Lt.x *= s.x / 2,
        Lt.y *= s.y / 2,
        Ct.start.copy(Pt),
        Ct.start.z = 0,
        Ct.end.copy(Lt),
        Ct.end.z = 0;
        const g = Ct.closestPointToPointParameter(_o, !0);
        Ct.at(g, eu);
        const A = Dt.lerp(Pt.z, Lt.z, g)
          , p = A >= -1 && A <= 1
          , S = _o.distanceTo(eu) < mi * .5;
        if (p && S) {
            Ct.start.fromBufferAttribute(c, d),
            Ct.end.fromBufferAttribute(l, d),
            Ct.start.applyMatrix4(o),
            Ct.end.applyMatrix4(o);
            const w = new D
              , b = new D;
            yn.distanceSqToSegment(Ct.start, Ct.end, b, w),
            t.push({
                point: b,
                pointOnLine: w,
                distance: yn.origin.distanceTo(b),
                object: r,
                face: null,
                faceIndex: d,
                uv: null,
                uv1: null
            })
        }
    }
}
class c0 extends ct {
    constructor(e=new ih, t=new Us({
        color: Math.random() * 16777215
    })) {
        super(e, t),
        this.isLineSegments2 = !0,
        this.type = "LineSegments2"
    }
    computeLineDistances() {
        const e = this.geometry
          , t = e.attributes.instanceStart
          , n = e.attributes.instanceEnd
          , i = new Float32Array(2 * t.count);
        for (let o = 0, a = 0, c = t.count; o < c; o++,
        a += 2)
            Jl.fromBufferAttribute(t, o),
            $l.fromBufferAttribute(n, o),
            i[a] = a === 0 ? 0 : i[a - 1],
            i[a + 1] = i[a] + Jl.distanceTo($l);
        const s = new Ba(i,2,1);
        return e.setAttribute("instanceDistanceStart", new Bn(s,1,0)),
        e.setAttribute("instanceDistanceEnd", new Bn(s,1,1)),
        this
    }
    raycast(e, t) {
        const n = this.material.worldUnits
          , i = e.camera;
        i === null && !n && console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');
        const s = e.params.Line2 !== void 0 && e.params.Line2.threshold || 0;
        yn = e.ray;
        const o = this.matrixWorld
          , a = this.geometry
          , c = this.material;
        mi = c.linewidth + s,
        a.boundingSphere === null && a.computeBoundingSphere(),
        Pr.copy(a.boundingSphere).applyMatrix4(o);
        let l;
        if (n)
            l = mi * .5;
        else {
            const h = Math.max(i.near, Pr.distanceToPoint(yn.origin));
            l = tu(i, h, c.resolution)
        }
        if (Pr.radius += l,
        yn.intersectsSphere(Pr) === !1)
            return;
        a.boundingBox === null && a.computeBoundingBox(),
        Er.copy(a.boundingBox).applyMatrix4(o);
        let u;
        if (n)
            u = mi * .5;
        else {
            const h = Math.max(i.near, Er.distanceToPoint(yn.origin));
            u = tu(i, h, c.resolution)
        }
        Er.expandByScalar(u),
        yn.intersectsBox(Er) !== !1 && (n ? o0(this, t) : a0(this, i, t))
    }
    onBeforeRender(e) {
        const t = this.material.uniforms;
        t && t.resolution && (e.getViewport(Fo),
        this.material.uniforms.resolution.value.set(Fo.z, Fo.w))
    }
}
class qn extends ih {
    constructor() {
        super(),
        this.isLineGeometry = !0,
        this.type = "LineGeometry"
    }
    setPositions(e) {
        const t = e.length - 3
          , n = new Float32Array(2 * t);
        for (let i = 0; i < t; i += 3)
            n[2 * i] = e[i],
            n[2 * i + 1] = e[i + 1],
            n[2 * i + 2] = e[i + 2],
            n[2 * i + 3] = e[i + 3],
            n[2 * i + 4] = e[i + 4],
            n[2 * i + 5] = e[i + 5];
        return super.setPositions(n),
        this
    }
    setColors(e) {
        const t = e.length - 3
          , n = new Float32Array(2 * t);
        for (let i = 0; i < t; i += 3)
            n[2 * i] = e[i],
            n[2 * i + 1] = e[i + 1],
            n[2 * i + 2] = e[i + 2],
            n[2 * i + 3] = e[i + 3],
            n[2 * i + 4] = e[i + 4],
            n[2 * i + 5] = e[i + 5];
        return super.setColors(n),
        this
    }
    setFromPoints(e) {
        const t = e.length - 1
          , n = new Float32Array(6 * t);
        for (let i = 0; i < t; i++)
            n[6 * i] = e[i].x,
            n[6 * i + 1] = e[i].y,
            n[6 * i + 2] = e[i].z || 0,
            n[6 * i + 3] = e[i + 1].x,
            n[6 * i + 4] = e[i + 1].y,
            n[6 * i + 5] = e[i + 1].z || 0;
        return super.setPositions(n),
        this
    }
    fromLine(e) {
        const t = e.geometry;
        return this.setPositions(t.attributes.position.array),
        this
    }
}
class di extends c0 {
    constructor(e=new qn, t=new Us({
        color: Math.random() * 16777215
    })) {
        super(e, t),
        this.isLine2 = !0,
        this.type = "Line2"
    }
}
class ps extends lc {
    constructor(e, t={}) {
        const n = t.font;
        if (n === void 0)
            super();
        else {
            const i = n.generateShapes(e, t.size);
            t.depth === void 0 && (t.depth = 50),
            t.bevelThickness === void 0 && (t.bevelThickness = 10),
            t.bevelSize === void 0 && (t.bevelSize = 8),
            t.bevelEnabled === void 0 && (t.bevelEnabled = !1),
            super(i, t)
        }
        this.type = "TextGeometry"
    }
}
function l0(r, e=!1) {
    const t = r[0].index !== null
      , n = new Set(Object.keys(r[0].attributes))
      , i = new Set(Object.keys(r[0].morphAttributes))
      , s = {}
      , o = {}
      , a = r[0].morphTargetsRelative
      , c = new At;
    let l = 0;
    for (let u = 0; u < r.length; ++u) {
        const h = r[u];
        let d = 0;
        if (t !== (h.index !== null))
            return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + u + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),
            null;
        for (const f in h.attributes) {
            if (!n.has(f))
                return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + u + '. All geometries must have compatible attributes; make sure "' + f + '" attribute exists among all geometries, or in none of them.'),
                null;
            s[f] === void 0 && (s[f] = []),
            s[f].push(h.attributes[f]),
            d++
        }
        if (d !== n.size)
            return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + u + ". Make sure all geometries have the same number of attributes."),
            null;
        if (a !== h.morphTargetsRelative)
            return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + u + ". .morphTargetsRelative must be consistent throughout all geometries."),
            null;
        for (const f in h.morphAttributes) {
            if (!i.has(f))
                return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + u + ".  .morphAttributes must be consistent throughout all geometries."),
                null;
            o[f] === void 0 && (o[f] = []),
            o[f].push(h.morphAttributes[f])
        }
        if (e) {
            let f;
            if (t)
                f = h.index.count;
            else if (h.attributes.position !== void 0)
                f = h.attributes.position.count;
            else
                return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + u + ". The geometry must have either an index or a position attribute"),
                null;
            c.addGroup(l, f, u),
            l += f
        }
    }
    if (t) {
        let u = 0;
        const h = [];
        for (let d = 0; d < r.length; ++d) {
            const f = r[d].index;
            for (let m = 0; m < f.count; ++m)
                h.push(f.getX(m) + u);
            u += r[d].attributes.position.count
        }
        c.setIndex(h)
    }
    for (const u in s) {
        const h = nu(s[u]);
        if (!h)
            return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + u + " attribute."),
            null;
        c.setAttribute(u, h)
    }
    for (const u in o) {
        const h = o[u][0].length;
        if (h === 0)
            break;
        c.morphAttributes = c.morphAttributes || {},
        c.morphAttributes[u] = [];
        for (let d = 0; d < h; ++d) {
            const f = [];
            for (let g = 0; g < o[u].length; ++g)
                f.push(o[u][g][d]);
            const m = nu(f);
            if (!m)
                return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + u + " morphAttribute."),
                null;
            c.morphAttributes[u].push(m)
        }
    }
    return c
}
function nu(r) {
    let e, t, n, i = -1, s = 0;
    for (let l = 0; l < r.length; ++l) {
        const u = r[l];
        if (e === void 0 && (e = u.array.constructor),
        e !== u.array.constructor)
            return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),
            null;
        if (t === void 0 && (t = u.itemSize),
        t !== u.itemSize)
            return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),
            null;
        if (n === void 0 && (n = u.normalized),
        n !== u.normalized)
            return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),
            null;
        if (i === -1 && (i = u.gpuType),
        i !== u.gpuType)
            return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."),
            null;
        s += u.count * t
    }
    const o = new e(s)
      , a = new vt(o,t,n);
    let c = 0;
    for (let l = 0; l < r.length; ++l) {
        const u = r[l];
        if (u.isInterleavedBufferAttribute) {
            const h = c / t;
            for (let d = 0, f = u.count; d < f; d++)
                for (let m = 0; m < t; m++) {
                    const g = u.getComponent(d, m);
                    a.setComponent(d + h, m, g)
                }
        } else
            o.set(u.array, c);
        c += u.count * t
    }
    return i !== void 0 && (a.gpuType = i),
    a
}
function iu(r, e) {
    if (e === Kh)
        return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),
        r;
    if (e === La || e === wu) {
        let t = r.getIndex();
        if (t === null) {
            const o = []
              , a = r.getAttribute("position");
            if (a !== void 0) {
                for (let c = 0; c < a.count; c++)
                    o.push(c);
                r.setIndex(o),
                t = r.getIndex()
            } else
                return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),
                r
        }
        const n = t.count - 2
          , i = [];
        if (e === La)
            for (let o = 1; o <= n; o++)
                i.push(t.getX(0)),
                i.push(t.getX(o)),
                i.push(t.getX(o + 1));
        else
            for (let o = 0; o < n; o++)
                o % 2 === 0 ? (i.push(t.getX(o)),
                i.push(t.getX(o + 1)),
                i.push(t.getX(o + 2))) : (i.push(t.getX(o + 2)),
                i.push(t.getX(o + 1)),
                i.push(t.getX(o)));
        i.length / 3 !== n && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
        const s = r.clone();
        return s.setIndex(i),
        s.clearGroups(),
        s
    } else
        return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e),
        r
}
const Ie = {
    isProcessing: !1,
    IsDebugMode: !1,
    Fonts: null,
    ProjectData: null,
    Map: null,
    StopRenderLoop: !1,
    spacerApp: null
}
  , u0 = Math.PI / 180;
function h0(r) {
    return r * u0
}
class d0 {
    constructor(e, t) {
        mt(this, "BAR_LENGTH", 1);
        mt(this, "BAR_THICKNESS", 1);
        mt(this, "DIM_LINE_OFFSET", .5);
        mt(this, "DASH_SIZE", .1);
        mt(this, "DASH_GAP", .2);
        mt(this, "LABEL_3D_MARGIN", .2);
        mt(this, "DIM_HEIGHT", .2);
        mt(this, "MIN_DIM", 1);
        mt(this, "DIM_SUFFIX", "m");
        mt(this, "PLOT_INFO_GAP", .3);
        mt(this, "DashedLineMaterial", null);
        mt(this, "BarLineMaterial", null);
        mt(this, "SimpleLineMaterial", null);
        mt(this, "StandardMaterial", null);
        mt(this, "scene", null);
        mt(this, "Dimensions", []);
        mt(this, "animationDuration", .5);
        mt(this, "Camera", null);
        mt(this, "PLOT_NUM_SIZE_FACTOR", .6);
        mt(this, "FadedPlane", null);
        this.Camera = t,
        this.SimpleLineMaterial = new Us({
            color: "white",
            linewidth: 1,
            depthWrite: !1,
            depthTest: !1,
            transparent: !0
        }),
        this.BarLineMaterial = new Us({
            color: "white",
            linewidth: this.BAR_THICKNESS,
            vertexColors: !0,
            depthWrite: !1,
            depthTest: !1,
            transparent: !0
        }),
        this.StandardMaterial = new Ki({
            color: "black",
            transparent: !0,
            opacity: .8,
            depthWrite: !1,
            depthTest: !1,
            transparent: !0
        }),
        this.scene = e
    }
    RemoveDisplayedDim() {
        for (let e = 0; e < this.Dimensions.length; e++)
            try {
                this.scene.remove(this.Dimensions[e])
            } catch {}
    }
    Remove() {
        for (let e = 0; e < this.Dimensions.length; e++)
            try {
                this.scene.remove(this.Dimensions[e])
            } catch {}
        this.FadedPlane && (this.Camera.remove(this.FadedPlane),
        this.FadedPlane = null)
    }
    getAreaUnitString(e) {
        const t = {
            m2: "m",
            cm2: "cm",
            mm2: "mm",
            km2: "km",
            ft2: "ft",
            in2: "in",
            yd2: "yd",
            acre: "acres",
            hectare: "hectares"
        };
        return e.toLowerCase()in t ? t[e] : ""
    }
    alignObjectToVector(e, t) {
        const n = new D(0,0,1);
        n.applyQuaternion(e.quaternion).normalize();
        const i = new sn().setFromUnitVectors(n, t);
        e.quaternion.premultiply(i),
        e.updateMatrixWorld(!0)
    }
    alignObjectUpToVector(e, t) {
        const n = new D().copy(e.up.multiplyScalar(-1));
        e.updateMatrixWorld(!0),
        n.applyQuaternion(e.quaternion).normalize();
        const i = new sn().setFromUnitVectors(n, t);
        e.quaternion.premultiply(i),
        e.updateMatrixWorld(!0)
    }
    Add3DDimensionLabel(e, t, n, i, s) {
        const o = i[1].clone().sub(i[0]).normalize()
          , a = new D(n.attributes.normal.array[0],n.attributes.normal.array[1],n.attributes.normal.array[2])
          , c = a.clone().cross(o)
          , l = new ps(`${e}`,{
            font: Ie.Fonts,
            size: s * .15,
            depth: 0
        });
        l.computeBoundingBox(),
        l.translate(-(l.boundingBox.max.x - l.boundingBox.min.x) / 2, -(l.boundingBox.max.y - l.boundingBox.min.y) / 2, -(l.boundingBox.max.z - l.boundingBox.min.z) / 2);
        const u = new gl({
            color: "#ffffff",
            emissive: "white",
            emissiveIntensity: 1,
            depthWrite: !1,
            depthTest: !1,
            transparent: !0
        })
          , h = new ct(l,u);
        return h.position.x = t.x,
        h.position.y = t.y + this.DIM_HEIGHT,
        h.position.z = t.z,
        h.renderOrder = 999,
        this.alignObjectToVector(h, a),
        this.alignObjectUpToVector(h, c),
        this.scene.add(h),
        this.Dimensions.push(h),
        l
    }
    AddDimensionLabel(e, t, n) {
        const i = document.createElement("div")
          , s = document.createElement("div");
        i.appendChild(s),
        i.className = "dimension-label",
        s.textContent = e.toString() + "m";
        const o = new r0(i);
        o.position.set(t.x, t.y, t.z),
        s.style.transform = `rotate(${n}deg)`,
        this.scene.add(o),
        this.Dimensions.push(o)
    }
    GetLargestEdgePoints(e) {
        const n = new Na(e).attributes.position;
        let i = [new D, new D]
          , s = 0;
        for (let o = 0; o < n.count - 1; o += 2) {
            const a = new D(n.getX(o),n.getY(o),n.getZ(o))
              , c = new D(n.getX(o + 1),n.getY(o + 1),n.getZ(o + 1))
              , l = a.distanceTo(c);
            l > s && (i = [a, c],
            s = l)
        }
        return i
    }
    GetEdgePoints(e, t=1) {
        const i = new Na(e).attributes.position
          , s = [];
        for (let o = 0; o < i.count - 1; o += 2) {
            const a = new D(i.getX(o),i.getY(o),i.getZ(o))
              , c = new D(i.getX(o + 1),i.getY(o + 1),i.getZ(o + 1));
            a.distanceTo(c) >= t && s.push([a, c])
        }
        return s
    }
    createEdgeFadeGradientPlane(e, t=.4, n=.5, i=.5) {
        (t >= n || t < 0 || n > .5) && console.warn("Invalid fade distances. `fadeStartDistance` must be < `fadeEndDistance`, both must be between 0.0 and 0.5. Defaulting fade distances to 0.4 and 0.5."),
        (i < 0 || i > 1) && (console.warn("Invalid `maxAlpha`. Must be between 0.0 and 1.0. Defaulting to 0.5."),
        i = .5);
        const s = new wn({
            uniforms: {
                u_fadeStartDistance: {
                    value: t
                },
                u_fadeEndDistance: {
                    value: n
                },
                u_maxAlpha: {
                    value: i
                }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float u_fadeStartDistance;
                uniform float u_fadeEndDistance;
                uniform float u_maxAlpha; // New uniform
                varying vec2 vUv;

                void main() {
                    vec2 distanceFromCenter = abs(vUv - 0.5); // Ranges from 0.0 (center) to 0.5 (edges)

                    // Calculate base alpha for X and Y independently (0.0 to 1.0 range)
                    float alphaX = 1.0 - smoothstep(u_fadeStartDistance, u_fadeEndDistance, distanceFromCenter.x);
                    float alphaY = 1.0 - smoothstep(u_fadeStartDistance, u_fadeEndDistance, distanceFromCenter.y);

                    // Take the minimum to ensure the rectangular shape, giving a final alpha in [0.0, 1.0]
                    float baseAlpha = min(alphaX, alphaY);

                    // Scale the base alpha to the desired maximum alpha
                    float finalAlpha = baseAlpha * u_maxAlpha;

                    // Ensure finalAlpha is clamped (though already handled by smoothstep and multiplication)
                    finalAlpha = clamp(finalAlpha, 0.0, u_maxAlpha);
                    // Set the color to black and apply the calculated alpha
                    gl_FragColor = vec4(0.0, 0.0, 0.0, finalAlpha);
                }
            `,
            transparent: !0,
            side: $t,
            depthWrite: !1
        });
        return new ct(e,s)
    }
    applyPlanarUVs(e, t="xz", n={
        u: 1,
        v: 1
    }) {
        const i = e.getAttribute("position");
        if (!i) {
            console.error("Geometry must have a position attribute to apply planar UVs.");
            return
        }
        let s = e.getAttribute("uv");
        s || (s = new vt(new Float32Array(i.count * 2),2),
        e.setAttribute("uv", s)),
        e.computeBoundingBox();
        const o = e.boundingBox
          , a = o.min
          , c = o.max;
        let l, u, h, d, f, m;
        switch (t.toLowerCase()) {
        case "xy":
            l = a.x,
            u = c.x,
            h = a.y,
            d = c.y,
            f = p => i.getX(p),
            m = p => i.getY(p);
            break;
        case "xz":
            l = a.x,
            u = c.x,
            h = a.z,
            d = c.z,
            f = p => i.getX(p),
            m = p => i.getZ(p);
            break;
        case "yz":
            l = a.y,
            u = c.y,
            h = a.z,
            d = c.z,
            f = p => i.getY(p),
            m = p => i.getZ(p);
            break;
        default:
            console.warn("Invalid projectionAxis. Using XZ by default."),
            l = a.x,
            u = c.x,
            h = a.z,
            d = c.z,
            f = p => i.getX(p),
            m = p => i.getZ(p);
            break
        }
        const g = u - l
          , A = d - h;
        for (let p = 0; p < i.count; p++) {
            let S = f(p)
              , w = m(p)
              , b = g === 0 ? 0 : (S - l) / g
              , B = A === 0 ? 0 : (w - h) / A;
            b *= n.u,
            B *= n.v,
            s.setXY(p, b, B)
        }
        s.needsUpdate = !0,
        console.log(`Planar UVs applied (${t} projection) to geometry.`)
    }
    convertFromMeters(e, t) {
        if (typeof e != "number" || isNaN(e))
            throw new Error("Value must be a valid number");
        const n = {
            m: 1,
            cm: 100,
            mm: 1e3,
            km: .001,
            in: 39.37007874,
            ft: 3.280839895,
            yd: 1.0936132983,
            mile: .0006213711922,
            "ft-in": 3.280839895
        }
          , i = t.toLowerCase();
        if (!n[i])
            throw new Error(`Unsupported unit: ${t}`);
        const s = e * n[i];
        if (i === "ft-in") {
            let o = Math.floor(s)
              , a = (s - o) * 12;
            return a > 11 && (o += 1,
            a = 0),
            a < 1 && (a = 0),
            `${this.formatIndianNumber(o)}'${a == 0 ? "" : ` ${Math.round(a)}"`}`
        } else
            return `${this.formatIndianNumber(s.toFixed(2))} ${t}`
    }
    async SetUp3DDimensions(e, t, n, i, s, o, a, c, l, u, h) {
        const d = this.GetEdgePoints(e, a * .5);
        for (let f = 0; f < d.length; f++) {
            const m = d[f]
              , g = m[0].distanceTo(m[1])
              , A = m[1].clone().sub(m[0]).normalize()
              , p = new D(-A.z,0,A.x).setLength(a * .15);
            let S = [];
            S.push(m[0].clone().add(p)),
            S.push(m[1].clone().add(p));
            const w = S[0].clone().add(S[1]).multiplyScalar(.5)
              , b = this.convertFromMeters(g, c)
              , B = await this.Add3DDimensionLabel(b, w, e, m, a);
            B.computeBoundingBox();
            const z = B.boundingBox
              , I = z.max.x - z.min.x
              , H = (g - I) / 2 - a * .1;
            let P = [];
            P.push(m[0].clone().add(p)),
            P.push(A.clone().multiplyScalar(H).add(m[0].clone().add(p)));
            let T = [];
            T.push(m[1].clone().add(p)),
            T.push(A.clone().multiplyScalar(-H).add(m[1].clone().add(p)));
            const _ = new vl({
                color: "white",
                linewidth: 1,
                scale: 1,
                dashSize: a * .1,
                gapSize: a * .1,
                depthWrite: !1,
                depthTest: !1,
                transparent: !0
            })
              , re = new At().setFromPoints(P)
              , k = new Xi(re,_);
            k.computeLineDistances();
            const U = new At().setFromPoints(T)
              , F = new Xi(U,_);
            F.computeLineDistances();
            const O = S[0].clone().add(p.clone())
              , y = S[0].clone()
              , v = S[0].clone().add(p.clone().multiplyScalar(-1))
              , L = S[1].clone().add(p.clone())
              , R = S[1].clone()
              , C = S[1].clone().add(p.clone().multiplyScalar(-1))
              , Y = new qn().setFromPoints([O, y, v])
              , ue = new qn().setFromPoints([L, R, C])
              , X = m[0].clone()
              , ne = m[0].clone().add(new D(0,this.DIM_HEIGHT,0))
              , ae = new qn().setFromPoints([X, ne])
              , ce = new di(ae,this.SimpleLineMaterial)
              , le = m[1].clone()
              , xe = m[1].clone().add(new D(0,this.DIM_HEIGHT,0))
              , ye = new qn().setFromPoints([le, xe])
              , Te = new di(ye,this.SimpleLineMaterial);
            Y.setColors([1, 1, 1, 1, 1, 1, 1, 1, 1]),
            ue.setColors([1, 1, 1, 1, 1, 1, 1, 1, 1]);
            const G = new di(Y,this.BarLineMaterial)
              , K = new di(ue,this.BarLineMaterial);
            G.position.y += this.DIM_HEIGHT,
            K.position.y += this.DIM_HEIGHT,
            k.position.y += this.DIM_HEIGHT,
            F.position.y += this.DIM_HEIGHT,
            G.renderOrder = 999,
            K.renderOrder = 999,
            k.renderOrder = 999,
            F.renderOrder = 999,
            ce.renderOrder = 999,
            Te.renderOrder = 999,
            this.scene.add(G),
            this.scene.add(K),
            this.scene.add(k),
            this.scene.add(F),
            this.scene.add(ce),
            this.scene.add(Te),
            this.Dimensions.push(G),
            this.Dimensions.push(K),
            this.Dimensions.push(k),
            this.Dimensions.push(F),
            this.Dimensions.push(ce),
            this.Dimensions.push(Te)
        }
        this.AddFadedPlane(e),
        await this.AddPlotArea(t, n, i, s, o, a, l, u, h),
        this.FadedPlane || this.attachMeshToCamera()
    }
    AddFadedPlane(e) {
        const t = e.clone();
        t.computeBoundingBox();
        const n = new D;
        t.boundingBox.getCenter(n),
        t.translate(-n.x, -n.y, -n.z);
        const i = new ct(t,new Ki({
            color: "#339dff",
            transparent: !0,
            opacity: 1
        }));
        return i.position.x = n.x,
        i.position.y = n.y + this.DIM_HEIGHT,
        i.position.z = n.z,
        i.renderOrder = 998,
        i.scale.set(0, 0, 0),
        this.scene.add(i),
        this.Dimensions.push(i),
        this.popInMesh(i),
        i
    }
    mergeMeshes(e) {
        const t = e.map(s => {
            const o = s.geometry.clone();
            return o.applyMatrix4(s.matrixWorld),
            o
        }
        )
          , n = l0(t, !0);
        n.computeBoundingBox();
        const i = new D;
        return n.boundingBox.getCenter(i),
        n.translate(-i.x, -i.y, -i.z),
        new ct(n,e[0].material)
    }
    popInMesh(e, t=1, n=.5) {
        const i = performance.now();
        e.scale.set(0, 0, 0);
        function s(a) {
            const c = (a - i) / 1e3
              , l = Math.min(c / n, 1)
              , u = o(l) * t;
            e.scale.set(u, u, u),
            l < 1 ? requestAnimationFrame(s) : Ie.isProcessing = !1
        }
        requestAnimationFrame(s);
        function o(a) {
            return Math.max(0, 1 + 2.70158 * Math.pow(a - 1, 3) + 1.70158 * Math.pow(a - 1, 2))
        }
    }
    formatIndianNumber(e) {
        if (e == null)
            return "";
        const t = Number(e);
        if (isNaN(t))
            throw new Error("Value must be a valid number");
        const [n,i] = t.toString().split(".")
          , s = n.slice(-3)
          , o = n.slice(0, -3)
          , a = o ? o.replace(/\B(?=(\d{2})+(?!\d))/g, ",") + "," + s : s;
        return i ? `${a}.${i}` : a
    }
    async AddPlotArea(e, t, n, i, s, o, a, c, l) {
        const u = o * this.PLOT_NUM_SIZE_FACTOR
          , h = o * this.PLOT_NUM_SIZE_FACTOR * .2666
          , d = o * this.PLOT_NUM_SIZE_FACTOR * .4
          , f = o * this.PLOT_NUM_SIZE_FACTOR * .3
          , m = []
          , g = i
          , A = new D(0,1,0)
          , p = new gl({
            color: "white",
            emissive: "white",
            emissiveIntensity: 10,
            depthWrite: !1,
            depthTest: !1,
            transparent: !0
        })
          , S = new ps(e,{
            font: Ie.Fonts,
            size: u,
            depth: 0
        });
        S.computeBoundingBox(),
        S.translate(-(S.boundingBox.max.x - S.boundingBox.min.x) / 2, -(S.boundingBox.max.y - S.boundingBox.min.y) / 2, -(S.boundingBox.max.z - S.boundingBox.min.z) / 2);
        const w = new ct(S,p);
        w.position.x = g.x,
        w.position.y = g.y + this.DIM_HEIGHT + .01,
        w.position.z = g.z,
        w.renderOrder = 999;
        const b = new D(0,0,1).clone().multiplyScalar(u * -1.15);
        w.position.add(b),
        this.alignObjectToVector(w, A),
        m.push(w);
        const B = this.getAreaUnitString(a)
          , z = this.getAreaUnitString(c)
          , I = this.formatIndianNumber(t.toFixed(2))
          , H = new ps(`${I} ${B}`,{
            font: Ie.Fonts,
            size: d,
            depth: 0
        });
        H.computeBoundingBox(),
        H.translate(-(H.boundingBox.max.x - H.boundingBox.min.x) / 2, -(H.boundingBox.max.y - H.boundingBox.min.y) / 2, -(H.boundingBox.max.z - H.boundingBox.min.z) / 2);
        const P = new ct(H,p);
        P.position.x = g.x,
        P.position.y = g.y + this.DIM_HEIGHT + .01,
        P.position.z = g.z,
        P.renderOrder = 999;
        const T = new D(0,0,1).multiplyScalar(u * .53666);
        P.position.add(T),
        this.alignObjectToVector(P, A),
        m.push(P);
        let _;
        if (c) {
            const U = this.formatIndianNumber(n.toFixed(2))
              , F = new ps(`${U} ${z}`,{
                font: Ie.Fonts,
                size: h,
                depth: 0
            });
            F.computeBoundingBox(),
            F.translate(-(F.boundingBox.max.x - F.boundingBox.min.x) / 2, -(F.boundingBox.max.y - F.boundingBox.min.y) / 2, -(F.boundingBox.max.z - F.boundingBox.min.z) / 2),
            _ = new ct(F,p),
            _.position.x = g.x,
            _.position.y = g.y + this.DIM_HEIGHT + .01,
            _.position.z = g.z,
            _.renderOrder = 999,
            this.alignObjectToVector(_, A),
            m.push(_)
        }
        let re;
        if (l) {
            const U = new ps(l,{
                font: Ie.Fonts,
                size: f,
                depth: 0
            });
            U.computeBoundingBox(),
            U.translate(-(U.boundingBox.max.x - U.boundingBox.min.x) / 2, -(U.boundingBox.max.y - U.boundingBox.min.y) / 2, -(U.boundingBox.max.z - U.boundingBox.min.z) / 2),
            re = new ct(U,p),
            re.position.x = g.x,
            re.position.y = g.y + this.DIM_HEIGHT + .01,
            re.position.z = g.z,
            re.renderOrder = 999;
            const F = new D(0,0,1).multiplyScalar(u * 1.53666);
            re.position.add(F),
            this.alignObjectToVector(re, A),
            m.push(re)
        }
        const k = this.mergeMeshes(m);
        k.scale.set(0, 0, 0),
        k.position.x = g.x,
        k.position.y = k.position.y + this.DIM_HEIGHT + .01,
        k.position.z = g.z,
        s && (k.rotation.y = h0(s)),
        k.renderOrder = 999,
        this.scene.add(k),
        this.Dimensions.push(k),
        this.popInMesh(k)
    }
    createQuadMeshFromPoints(e, t) {
        if (e.length !== 4)
            return console.error("Please provide exactly 4 points to create a quad mesh."),
            null;
        const n = new At
          , i = new Float32Array([e[0].x, e[0].y, e[0].z, e[1].x, e[1].y, e[1].z, e[2].x, e[2].y, e[2].z, e[3].x, e[3].y, e[3].z]);
        n.setAttribute("position", new vt(i,3));
        const s = new Uint32Array([0, 1, 2, 0, 2, 3]);
        n.setIndex(new vt(s,1));
        const o = new Float32Array([0, 1, 0, 0, 1, 0, 1, 1]);
        n.setAttribute("uv", new vt(o,2)),
        n.computeVertexNormals();
        const a = new ct(n,t);
        return this.scene.add(a),
        this.Dimensions.push(a),
        a
    }
    scaleMeshFromCenter(e, t, n, i) {
        const s = new xt().setFromObject(e)
          , o = new D;
        s.getCenter(o);
        const a = new D;
        e.getWorldPosition(a),
        e.position.sub(o).add(a),
        e.scale.set(t, n, i);
        const c = new xt().setFromObject(e)
          , l = new D;
        c.getCenter(l);
        const u = new D().subVectors(o, l);
        e.position.add(u)
    }
    SetUpDimensions(e) {
        const t = this.GetEdgePoints(e);
        for (let n = 0; n < t.length; n++) {
            const i = t[n]
              , s = i[0].distanceTo(i[1])
              , o = i[1].clone().sub(i[0]).normalize()
              , a = new D(-o.z,0,o.x).setLength(this.DIM_LINE_OFFSET);
            let c = [];
            c.push(i[0].clone().add(a)),
            c.push(i[1].clone().add(a));
            let l = Dt.radToDeg(Math.atan2(-a.z, a.x)) - 90;
            const u = c[0].clone().add(c[1]).multiplyScalar(.5);
            this.AddDimensionLabel(s.toFixed(2), u, -l);
            const h = new vl({
                color: "white",
                linewidth: 1,
                scale: 1,
                dashSize: this.DASH_SIZE,
                gapSize: this.DASH_GAP,
                depthWrite: !1,
                depthTest: !1,
                transparent: !0
            })
              , d = new At().setFromPoints(c)
              , f = new Xi(d,h);
            f.computeLineDistances();
            const m = c[0].clone().add(a.clone().normalize().multiplyScalar(this.BAR_LENGTH / 2))
              , g = c[0].clone()
              , A = c[0].clone().add(a.clone().normalize().multiplyScalar(-this.BAR_LENGTH / 2))
              , p = c[1].clone().add(a.clone().normalize().multiplyScalar(this.BAR_LENGTH / 2))
              , S = c[1].clone()
              , w = c[1].clone().add(a.clone().normalize().multiplyScalar(-this.BAR_LENGTH / 2))
              , b = new qn().setFromPoints([m, g, A])
              , B = new qn().setFromPoints([p, S, w]);
            b.setColors([0, 0, 0, 1, 1, 1, 0, 0, 0]),
            B.setColors([0, 0, 0, 1, 1, 1, 0, 0, 0]);
            const z = new di(b,this.BarLineMaterial)
              , I = new di(B,this.BarLineMaterial);
            this.scene.add(z),
            this.scene.add(I),
            this.scene.add(f),
            this.Dimensions.push(z),
            this.Dimensions.push(I),
            this.Dimensions.push(f)
        }
    }
    attachMeshToCamera() {
        const e = 2 * Math.tan(Dt.degToRad(this.Camera.fov / 2)) * Math.abs(-2)
          , t = e * this.Camera.aspect
          , n = new Xs(t,e)
          , i = new Qn({
            color: 0,
            side: $t,
            transparent: !0,
            opacity: .5,
            depthTest: !1,
            depthWrite: !1
        });
        this.FadedPlane = new ct(n,i),
        this.FadedPlane.position.set(0, 0, -2),
        this.FadedPlane.renderOrder = 4,
        this.Camera.add(this.FadedPlane),
        this.Dimensions.push(this.FadedPlane)
    }
}
const St = {
    plot_text: new pn({
        color: "#303030",
        roughness: 1,
        thickness: 1,
        emissiveIntensity: 200,
        opacity: 0,
        transparent: !0
    })
}
  , zn = class zn {
    constructor() {
        this.plotMeshes = [],
        this.numericPlots = new Map,
        this.nonNumericPlots = new Map,
        this.activePlotData = null,
        this.activePlotMesh = null,
        this.plotsData = [],
        this.showStatus = !1,
        this.statusVisible = !1,
        this.avgPlotSize = 0,
        this.avgFontSize = 1,
        this.statusMaterials = {},
        this.plotSelectionMaterial = fs.createStandardMaterial("#339dff", "#339dff", .9, !0, .9)
    }
    StorePlotsData(e) {
        e.forEach(t => {
            const n = this.strictParseInt(t.name)
              , i = {
                annotationVisible: !1,
                name: t.name,
                sqMeter: parseFloat(t.sqMeter.toString()),
                sqYard: parseFloat(t.sqYard.toString()),
                statusId: t.statusId,
                pos: t.pos,
                rotation: t.rotation,
                scale: t.scale,
                label: t.label ? t.label : ""
            };
            n ? this.numericPlots[t.name.toLowerCase()] = i : this.nonNumericPlots[t.name.toLowerCase()] = i,
            this.plotsData.push(i)
        }
        )
    }
    strictParseInt(e) {
        return /^-?\d+$/.test(e.trim()) ? parseInt(e, 10) : null
    }
    convertFromSquareMeters(e, t) {
        if (typeof e != "number" || isNaN(e))
            throw new Error("Value must be a valid number");
        const n = {
            m2: 1,
            cm2: 1e4,
            mm2: 1e6,
            km2: 1e-6,
            ft2: 10.7639,
            in2: 1550.0031,
            yd2: 1.19599,
            acre: 247105e-9,
            hectare: 1e-4
        }
          , i = t.toLowerCase();
        if (!n[i])
            throw new Error(`Unsupported unit: ${t}`);
        return e * n[i]
    }
    StorePlotMeshData(e) {
        const t = new xt().setFromObject(e)
          , n = new D;
        t.getSize(n);
        const i = (n.x + n.y + n.z) / 3;
        zn.totalSize += i,
        zn.meshCount++;
        const s = this.getPlotCenter(e);
        e.name in this.numericPlots && this.numericPlots[e.name.toLowerCase()].pos === null ? this.numericPlots[e.name.toLowerCase()].pos = s : e.name.toLowerCase()in this.nonNumericPlots && this.nonNumericPlots[e.name.toLowerCase()].pos === null && (this.nonNumericPlots[e.name.toLowerCase()].pos = s)
    }
    selectPlot(e, t, n, i, s, o) {
        var c, l, u, h, d, f, m, g;
        this.activePlotData && o.add(this.activePlotData.textMesh);
        const a = this.GetPlotData(e);
        if (this.dimension.RemoveDisplayedDim(),
        a) {
            this.activePlotData && this.activePlotData !== a && (this.activePlotData.annotationVisible = !1,
            this.showStatus ? this.updateToPlotStatusMaterial(this.activePlotData, n, i) : this.activePlotMesh && (this.activePlotMesh.material = this.initialPlotMaterial)),
            a && (a.annotationVisible = !0);
            const A = this.plotMeshes.find(H => H.name.toLowerCase() === e.toLowerCase());
            if (!A) {
                this.activePlotData = null;
                const H = document.getElementById("searchTray");
                return H && H.classList.add("error"),
                null
            }
            this.activePlotMesh = A,
            this.activePlotData = a,
            this.activePlotData.pos,
            this.activePlotData.rotation && this.activePlotData.rotation;
            let p = this.avgFontSize;
            this.activePlotData.scale && (p = this.avgFontSize * this.activePlotData.scale.x);
            const S = this.activePlotData.label;
            let w = this.activePlotData.sqYard
              , b = this.activePlotData.sqMeter
              , B = "m"
              , z = "yd2"
              , I = "m2";
            return (c = Ie.ProjectData) != null && c.primaryAreaUnits && (w = this.convertFromSquareMeters(this.activePlotData.sqMeter, (l = Ie.ProjectData) == null ? void 0 : l.primaryAreaUnits),
            z = (u = Ie.ProjectData) == null ? void 0 : u.primaryAreaUnits),
            (h = Ie.ProjectData) != null && h.lengthUnits && (B = (d = Ie.ProjectData) == null ? void 0 : d.lengthUnits),
            "secondaryAreaUnits"in Ie.ProjectData && (b = (f = Ie.ProjectData) != null && f.secondaryAreaUnits ? this.convertFromSquareMeters(this.activePlotData.sqMeter, (m = Ie.ProjectData) == null ? void 0 : m.secondaryAreaUnits) : 0,
            I = ((g = Ie.ProjectData) == null ? void 0 : g.secondaryAreaUnits) ?? ""),
            this.dimension.SetUp3DDimensions(this.activePlotMesh.geometry, this.activePlotData.name, w, b, this.activePlotData.pos, this.activePlotData.rotation, p, B, z, I, S),
            this.activePlotData && o.remove(this.activePlotData.textMesh),
            a
        }
        return null
    }
    getPlotByName(e) {
        return this.numericPlots.get(e) || this.nonNumericPlots.get(e) || null
    }
    updatePlotStatus(e, t) {
        const n = this.numericPlots.get(e);
        n && (n.annotationVisible = t)
    }
    updateToPlotStatusMaterial(e, t, n) {
        var s;
        if (!n)
            return;
        let i = this.plotMeshes.find(o => o.name.toString().toLowerCase() === e.name.toString().toLowerCase());
        if (!e.annotationVisible)
            if (e.annotationVisible)
                fs.transitionMaterial(i, this.initialPlotMaterial);
            else {
                let o;
                e.statusId != null && t[e.statusId] != null ? o = t[e.statusId].color : o = (s = Ie.spacerApp) == null ? void 0 : s.defaultStatus.color,
                this.statusMaterials.hasOwnProperty(o) || (this.statusMaterials[o] = fs.createStandardMaterial(o, o, 1, !0, .7));
                const a = this.statusMaterials[o];
                fs.transitionMaterial(i, a)
            }
    }
    async DrawPlotNumbers(e) {
        return new Promise( (t, n) => {
            this.plotMeshes.forEach(s => {
                this.StorePlotMeshData(s)
            }
            ),
            this.avgPlotSize = zn.meshCount > 0 ? zn.totalSize / zn.meshCount : 1;
            const i = this.avgPlotSize * .25;
            this.plotMeshes.forEach(s => {
                const o = new xt().setFromObject(s)
                  , a = new D;
                o.getSize(a);
                const c = a.x
                  , l = a.z
                  , u = Math.sqrt(c * c + l * l)
                  , h = this.GetPlotData(s.name)
                  , d = h ? h.pos : null;
                let f = i;
                i < u * .6 || (f = u * .6),
                this.avgFontSize = f,
                h && d && this.addText(s.name, d, h.rotation, this.avgFontSize, e, h.scale)
            }
            ),
            t()
        }
        )
    }
    GetPlotData(e) {
        return e.toLowerCase()in this.numericPlots ? this.numericPlots[e.toLowerCase()] : e.toLowerCase()in this.nonNumericPlots ? this.nonNumericPlots[e.toLowerCase()] : null
    }
    getPlotMesh(e) {
        return e && this.plotMeshes.find(n => {
            var i;
            return ((i = n.name) == null ? void 0 : i.toLowerCase()) === e.toLowerCase()
        }
        ) || null
    }
    getPlotCenter(e, t=1) {
        if (!e || typeof e.updateWorldMatrix != "function")
            return new D(0,0,0);
        const n = e.geometry;
        n.computeBoundingBox();
        const i = n.boundingBox
          , s = new D;
        return i == null || i.getCenter(s),
        s
    }
    animateOpacity(e, t=1) {
        const n = performance.now()
          , i = t * 1e3;
        function s(o) {
            const a = o - n
              , c = Math.min(a / i, 1);
            e.opacity = c,
            c < 1 ? requestAnimationFrame(s) : e.opacity = 1
        }
        requestAnimationFrame(s)
    }
    addText(e, t, n, i, s, o) {
        var f, m;
        const a = (f = Ie.Fonts) == null ? void 0 : f.generateShapes(`${e}`, i)
          , c = new uc(a);
        if (c.computeBoundingBox(),
        c.boundingBox) {
            const g = c.boundingBox.getCenter(new D).negate();
            c.translate(g.x, g.y, g.z + .1)
        }
        const l = St.plot_text
          , u = new ct(c,l);
        u.rotation.x = Dt.degToRad(-90),
        n && (u.rotation.z = Dt.degToRad(n)),
        s.add(u);
        let h = this.avgFontSize;
        o && (u.scale.set(o.x, o.z, 1),
        h = this.avgFontSize * o.x);
        const d = h * ((m = Ie.ProjectData) == null ? void 0 : m.plotNumberTextHeight);
        u.position.set(t.x, d, t.z),
        e.toLowerCase()in this.numericPlots && (this.numericPlots[e.toLowerCase()].textMesh = u),
        e.toLowerCase()in this.nonNumericPlots && (this.nonNumericPlots[e.toLowerCase()].textMesh = u),
        this.animateOpacity(l, 2)
    }
    toggleStatusView(e, t, n) {
        var u, h;
        const i = e.target;
        i.disabled = !0;
        const o = this.plotsData.sort( (d, f) => this.comparePlotNames(d, f))
          , a = 1e3
          , c = o.length > 0 ? a / o.length : a
          , l = e.target;
        if (l && l.checked) {
            this.showStatus = !0,
            o.forEach( (m, g) => {
                let A;
                if (m.name.toLowerCase()in this.nonNumericPlots ? A = this.nonNumericPlots[m.name.toLowerCase()] : m.name.toLowerCase()in this.numericPlots && (A = this.numericPlots[m.name.toLowerCase()]),
                !A) {
                    console.warn("No plot found for name:", m.name);
                    return
                }
                setTimeout( () => {
                    this.updateToPlotStatusMaterial(m, t, n)
                }
                , g * c)
            }
            );
            const d = document.getElementById("indicators");
            let f = "";
            Object.keys(t).forEach(m => {
                const g = `<div class="indicatorItem">
                                    <div class="indicatorCircle" style="background-color:${t[m].color}"></div>
                                    <div class="indicatorText">${t[m].name}</div>
                                </div>`;
                f += g
            }
            ),
            d && (f += `<div class="indicatorItem">
                                    <div class="indicatorCircle" style="background-color:${(u = Ie.spacerApp) == null ? void 0 : u.defaultStatus.color}"></div>
                                    <div class="indicatorText">${(h = Ie.spacerApp) == null ? void 0 : h.defaultStatus.name}</div>
                                </div>`,
            d.innerHTML = f,
            d.classList.add("active"))
        } else {
            this.showStatus = !1,
            o.slice().reverse().forEach( (f, m) => {
                let g;
                if (f.name.toLowerCase()in this.nonNumericPlots ? g = this.nonNumericPlots[f.name.toLowerCase()] : f.name.toLowerCase()in this.numericPlots && (g = this.numericPlots[f.name.toLowerCase()]),
                g && !g.annotationVisible) {
                    const A = this.plotMeshes.find(p => f.name === p.name);
                    A && setTimeout( () => {
                        n && fs.transitionMaterial(A, this.initialPlotMaterial)
                    }
                    , m * c)
                }
            }
            );
            const d = document.getElementById("indicators");
            d && d.classList.remove("active")
        }
        setTimeout( () => {
            i.disabled = !1
        }
        , a + 200)
    }
    extractNumericParts(e) {
        return e.split(/[^0-9]+/).filter(t => t).map(Number)
    }
    comparePlotNames(e, t) {
        const n = this.extractNumericParts(e.name)
          , i = this.extractNumericParts(t.name)
          , s = Math.max(n.length, i.length);
        for (let o = 0; o < s; o++) {
            const a = n[o] ?? 0
              , c = i[o] ?? 0;
            if (a !== c)
                return a - c
        }
        return 0
    }
    initializeDimension(e, t) {
        this.dimension = new d0(e,t)
    }
}
;
zn.totalSize = 0,
zn.meshCount = 0;
let Ha = zn;
class Xo extends xi {
    constructor(e) {
        super(e),
        this.dracoLoader = null,
        this.ktx2Loader = null,
        this.meshoptDecoder = null,
        this.pluginCallbacks = [],
        this.register(function(t) {
            return new g0(t)
        }),
        this.register(function(t) {
            return new v0(t)
        }),
        this.register(function(t) {
            return new P0(t)
        }),
        this.register(function(t) {
            return new L0(t)
        }),
        this.register(function(t) {
            return new C0(t)
        }),
        this.register(function(t) {
            return new y0(t)
        }),
        this.register(function(t) {
            return new b0(t)
        }),
        this.register(function(t) {
            return new M0(t)
        }),
        this.register(function(t) {
            return new w0(t)
        }),
        this.register(function(t) {
            return new A0(t)
        }),
        this.register(function(t) {
            return new S0(t)
        }),
        this.register(function(t) {
            return new x0(t)
        }),
        this.register(function(t) {
            return new E0(t)
        }),
        this.register(function(t) {
            return new T0(t)
        }),
        this.register(function(t) {
            return new p0(t)
        }),
        this.register(function(t) {
            return new R0(t)
        }),
        this.register(function(t) {
            return new D0(t)
        })
    }
    load(e, t, n, i) {
        const s = this;
        let o;
        if (this.resourcePath !== "")
            o = this.resourcePath;
        else if (this.path !== "") {
            const l = Ts.extractUrlBase(e);
            o = Ts.resolveURL(l, this.path)
        } else
            o = Ts.extractUrlBase(e);
        this.manager.itemStart(e);
        const a = function(l) {
            i ? i(l) : console.error(l),
            s.manager.itemError(e),
            s.manager.itemEnd(e)
        }
          , c = new hc(this.manager);
        c.setPath(this.path),
        c.setResponseType("arraybuffer"),
        c.setRequestHeader(this.requestHeader),
        c.setWithCredentials(this.withCredentials),
        c.load(e, function(l) {
            try {
                s.parse(l, o, function(u) {
                    t(u),
                    s.manager.itemEnd(e)
                }, a)
            } catch (u) {
                a(u)
            }
        }, n, a)
    }
    setDRACOLoader(e) {
        return this.dracoLoader = e,
        this
    }
    setKTX2Loader(e) {
        return this.ktx2Loader = e,
        this
    }
    setMeshoptDecoder(e) {
        return this.meshoptDecoder = e,
        this
    }
    register(e) {
        return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e),
        this
    }
    unregister(e) {
        return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
        this
    }
    parse(e, t, n, i) {
        let s;
        const o = {}
          , a = {}
          , c = new TextDecoder;
        if (typeof e == "string")
            s = JSON.parse(e);
        else if (e instanceof ArrayBuffer)
            if (c.decode(new Uint8Array(e,0,4)) === sh) {
                try {
                    o[Qe.KHR_BINARY_GLTF] = new N0(e)
                } catch (h) {
                    i && i(h);
                    return
                }
                s = JSON.parse(o[Qe.KHR_BINARY_GLTF].content)
            } else
                s = JSON.parse(c.decode(e));
        else
            s = e;
        if (s.asset === void 0 || s.asset.version[0] < 2) {
            i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
            return
        }
        const l = new j0(s,{
            path: t || this.resourcePath || "",
            crossOrigin: this.crossOrigin,
            requestHeader: this.requestHeader,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder
        });
        l.fileLoader.setRequestHeader(this.requestHeader);
        for (let u = 0; u < this.pluginCallbacks.length; u++) {
            const h = this.pluginCallbacks[u](l);
            h.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),
            a[h.name] = h,
            o[h.name] = !0
        }
        if (s.extensionsUsed)
            for (let u = 0; u < s.extensionsUsed.length; ++u) {
                const h = s.extensionsUsed[u]
                  , d = s.extensionsRequired || [];
                switch (h) {
                case Qe.KHR_MATERIALS_UNLIT:
                    o[h] = new m0;
                    break;
                case Qe.KHR_DRACO_MESH_COMPRESSION:
                    o[h] = new O0(s,this.dracoLoader);
                    break;
                case Qe.KHR_TEXTURE_TRANSFORM:
                    o[h] = new z0;
                    break;
                case Qe.KHR_MESH_QUANTIZATION:
                    o[h] = new I0;
                    break;
                default:
                    d.indexOf(h) >= 0 && a[h] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + h + '".')
                }
            }
        l.setExtensions(o),
        l.setPlugins(a),
        l.parse(n, i)
    }
    parseAsync(e, t) {
        const n = this;
        return new Promise(function(i, s) {
            n.parse(e, t, i, s)
        }
        )
    }
}
function f0() {
    let r = {};
    return {
        get: function(e) {
            return r[e]
        },
        add: function(e, t) {
            r[e] = t
        },
        remove: function(e) {
            delete r[e]
        },
        removeAll: function() {
            r = {}
        }
    }
}
const Qe = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
    KHR_MATERIALS_IOR: "KHR_materials_ior",
    KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
    KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
    KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
    KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_MATERIALS_VOLUME: "KHR_materials_volume",
    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
    EXT_MATERIALS_BUMP: "EXT_materials_bump",
    EXT_TEXTURE_WEBP: "EXT_texture_webp",
    EXT_TEXTURE_AVIF: "EXT_texture_avif",
    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
    EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class p0 {
    constructor(e) {
        this.parser = e,
        this.name = Qe.KHR_LIGHTS_PUNCTUAL,
        this.cache = {
            refs: {},
            uses: {}
        }
    }
    _markDefs() {
        const e = this.parser
          , t = this.parser.json.nodes || [];
        for (let n = 0, i = t.length; n < i; n++) {
            const s = t[n];
            s.extensions && s.extensions[this.name] && s.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, s.extensions[this.name].light)
        }
    }
    _loadLight(e) {
        const t = this.parser
          , n = "light:" + e;
        let i = t.cache.get(n);
        if (i)
            return i;
        const s = t.json
          , c = ((s.extensions && s.extensions[this.name] || {}).lights || [])[e];
        let l;
        const u = new Ge(16777215);
        c.color !== void 0 && u.setRGB(c.color[0], c.color[1], c.color[2], Ht);
        const h = c.range !== void 0 ? c.range : 0;
        switch (c.type) {
        case "directional":
            l = new Qu(u),
            l.target.position.set(0, 0, -1),
            l.add(l.target);
            break;
        case "point":
            l = new rp(u),
            l.distance = h;
            break;
        case "spot":
            l = new ip(u),
            l.distance = h,
            c.spot = c.spot || {},
            c.spot.innerConeAngle = c.spot.innerConeAngle !== void 0 ? c.spot.innerConeAngle : 0,
            c.spot.outerConeAngle = c.spot.outerConeAngle !== void 0 ? c.spot.outerConeAngle : Math.PI / 4,
            l.angle = c.spot.outerConeAngle,
            l.penumbra = 1 - c.spot.innerConeAngle / c.spot.outerConeAngle,
            l.target.position.set(0, 0, -1),
            l.add(l.target);
            break;
        default:
            throw new Error("THREE.GLTFLoader: Unexpected light type: " + c.type)
        }
        return l.position.set(0, 0, 0),
        On(l, c),
        c.intensity !== void 0 && (l.intensity = c.intensity),
        l.name = t.createUniqueName(c.name || "light_" + e),
        i = Promise.resolve(l),
        t.cache.add(n, i),
        i
    }
    getDependency(e, t) {
        if (e === "light")
            return this._loadLight(t)
    }
    createNodeAttachment(e) {
        const t = this
          , n = this.parser
          , s = n.json.nodes[e]
          , a = (s.extensions && s.extensions[this.name] || {}).light;
        return a === void 0 ? null : this._loadLight(a).then(function(c) {
            return n._getNodeRef(t.cache, a, c)
        })
    }
}
class m0 {
    constructor() {
        this.name = Qe.KHR_MATERIALS_UNLIT
    }
    getMaterialType() {
        return Qn
    }
    extendParams(e, t, n) {
        const i = [];
        e.color = new Ge(1,1,1),
        e.opacity = 1;
        const s = t.pbrMetallicRoughness;
        if (s) {
            if (Array.isArray(s.baseColorFactor)) {
                const o = s.baseColorFactor;
                e.color.setRGB(o[0], o[1], o[2], Ht),
                e.opacity = o[3]
            }
            s.baseColorTexture !== void 0 && i.push(n.assignTexture(e, "map", s.baseColorTexture, Rt))
        }
        return Promise.all(i)
    }
}
class A0 {
    constructor(e) {
        this.parser = e,
        this.name = Qe.KHR_MATERIALS_EMISSIVE_STRENGTH
    }
    extendMaterialParams(e, t) {
        const i = this.parser.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = i.extensions[this.name].emissiveStrength;
        return s !== void 0 && (t.emissiveIntensity = s),
        Promise.resolve()
    }
}
class g0 {
    constructor(e) {
        this.parser = e,
        this.name = Qe.KHR_MATERIALS_CLEARCOAT
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : pn
    }
    extendMaterialParams(e, t) {
        const n = this.parser
          , i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = []
          , o = i.extensions[this.name];
        if (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor),
        o.clearcoatTexture !== void 0 && s.push(n.assignTexture(t, "clearcoatMap", o.clearcoatTexture)),
        o.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = o.clearcoatRoughnessFactor),
        o.clearcoatRoughnessTexture !== void 0 && s.push(n.assignTexture(t, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)),
        o.clearcoatNormalTexture !== void 0 && (s.push(n.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)),
        o.clearcoatNormalTexture.scale !== void 0)) {
            const a = o.clearcoatNormalTexture.scale;
            t.clearcoatNormalScale = new Ae(a,a)
        }
        return Promise.all(s)
    }
}
class v0 {
    constructor(e) {
        this.parser = e,
        this.name = Qe.KHR_MATERIALS_DISPERSION
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : pn
    }
    extendMaterialParams(e, t) {
        const i = this.parser.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = i.extensions[this.name];
        return t.dispersion = s.dispersion !== void 0 ? s.dispersion : 0,
        Promise.resolve()
    }
}
class x0 {
    constructor(e) {
        this.parser = e,
        this.name = Qe.KHR_MATERIALS_IRIDESCENCE
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : pn
    }
    extendMaterialParams(e, t) {
        const n = this.parser
          , i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = []
          , o = i.extensions[this.name];
        return o.iridescenceFactor !== void 0 && (t.iridescence = o.iridescenceFactor),
        o.iridescenceTexture !== void 0 && s.push(n.assignTexture(t, "iridescenceMap", o.iridescenceTexture)),
        o.iridescenceIor !== void 0 && (t.iridescenceIOR = o.iridescenceIor),
        t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]),
        o.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum),
        o.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum),
        o.iridescenceThicknessTexture !== void 0 && s.push(n.assignTexture(t, "iridescenceThicknessMap", o.iridescenceThicknessTexture)),
        Promise.all(s)
    }
}
class y0 {
    constructor(e) {
        this.parser = e,
        this.name = Qe.KHR_MATERIALS_SHEEN
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : pn
    }
    extendMaterialParams(e, t) {
        const n = this.parser
          , i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = [];
        t.sheenColor = new Ge(0,0,0),
        t.sheenRoughness = 0,
        t.sheen = 1;
        const o = i.extensions[this.name];
        if (o.sheenColorFactor !== void 0) {
            const a = o.sheenColorFactor;
            t.sheenColor.setRGB(a[0], a[1], a[2], Ht)
        }
        return o.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = o.sheenRoughnessFactor),
        o.sheenColorTexture !== void 0 && s.push(n.assignTexture(t, "sheenColorMap", o.sheenColorTexture, Rt)),
        o.sheenRoughnessTexture !== void 0 && s.push(n.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)),
        Promise.all(s)
    }
}
class b0 {
    constructor(e) {
        this.parser = e,
        this.name = Qe.KHR_MATERIALS_TRANSMISSION
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : pn
    }
    extendMaterialParams(e, t) {
        const n = this.parser
          , i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = []
          , o = i.extensions[this.name];
        return o.transmissionFactor !== void 0 && (t.transmission = o.transmissionFactor),
        o.transmissionTexture !== void 0 && s.push(n.assignTexture(t, "transmissionMap", o.transmissionTexture)),
        Promise.all(s)
    }
}
class M0 {
    constructor(e) {
        this.parser = e,
        this.name = Qe.KHR_MATERIALS_VOLUME
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : pn
    }
    extendMaterialParams(e, t) {
        const n = this.parser
          , i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = []
          , o = i.extensions[this.name];
        t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0,
        o.thicknessTexture !== void 0 && s.push(n.assignTexture(t, "thicknessMap", o.thicknessTexture)),
        t.attenuationDistance = o.attenuationDistance || 1 / 0;
        const a = o.attenuationColor || [1, 1, 1];
        return t.attenuationColor = new Ge().setRGB(a[0], a[1], a[2], Ht),
        Promise.all(s)
    }
}
class w0 {
    constructor(e) {
        this.parser = e,
        this.name = Qe.KHR_MATERIALS_IOR
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : pn
    }
    extendMaterialParams(e, t) {
        const i = this.parser.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = i.extensions[this.name];
        return t.ior = s.ior !== void 0 ? s.ior : 1.5,
        Promise.resolve()
    }
}
class S0 {
    constructor(e) {
        this.parser = e,
        this.name = Qe.KHR_MATERIALS_SPECULAR
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : pn
    }
    extendMaterialParams(e, t) {
        const n = this.parser
          , i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = []
          , o = i.extensions[this.name];
        t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1,
        o.specularTexture !== void 0 && s.push(n.assignTexture(t, "specularIntensityMap", o.specularTexture));
        const a = o.specularColorFactor || [1, 1, 1];
        return t.specularColor = new Ge().setRGB(a[0], a[1], a[2], Ht),
        o.specularColorTexture !== void 0 && s.push(n.assignTexture(t, "specularColorMap", o.specularColorTexture, Rt)),
        Promise.all(s)
    }
}
class T0 {
    constructor(e) {
        this.parser = e,
        this.name = Qe.EXT_MATERIALS_BUMP
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : pn
    }
    extendMaterialParams(e, t) {
        const n = this.parser
          , i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = []
          , o = i.extensions[this.name];
        return t.bumpScale = o.bumpFactor !== void 0 ? o.bumpFactor : 1,
        o.bumpTexture !== void 0 && s.push(n.assignTexture(t, "bumpMap", o.bumpTexture)),
        Promise.all(s)
    }
}
class E0 {
    constructor(e) {
        this.parser = e,
        this.name = Qe.KHR_MATERIALS_ANISOTROPY
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : pn
    }
    extendMaterialParams(e, t) {
        const n = this.parser
          , i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = []
          , o = i.extensions[this.name];
        return o.anisotropyStrength !== void 0 && (t.anisotropy = o.anisotropyStrength),
        o.anisotropyRotation !== void 0 && (t.anisotropyRotation = o.anisotropyRotation),
        o.anisotropyTexture !== void 0 && s.push(n.assignTexture(t, "anisotropyMap", o.anisotropyTexture)),
        Promise.all(s)
    }
}
class P0 {
    constructor(e) {
        this.parser = e,
        this.name = Qe.KHR_TEXTURE_BASISU
    }
    loadTexture(e) {
        const t = this.parser
          , n = t.json
          , i = n.textures[e];
        if (!i.extensions || !i.extensions[this.name])
            return null;
        const s = i.extensions[this.name]
          , o = t.options.ktx2Loader;
        if (!o) {
            if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
                throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
            return null
        }
        return t.loadTextureImage(e, s.source, o)
    }
}
class L0 {
    constructor(e) {
        this.parser = e,
        this.name = Qe.EXT_TEXTURE_WEBP
    }
    loadTexture(e) {
        const t = this.name
          , n = this.parser
          , i = n.json
          , s = i.textures[e];
        if (!s.extensions || !s.extensions[t])
            return null;
        const o = s.extensions[t]
          , a = i.images[o.source];
        let c = n.textureLoader;
        if (a.uri) {
            const l = n.options.manager.getHandler(a.uri);
            l !== null && (c = l)
        }
        return n.loadTextureImage(e, o.source, c)
    }
}
class C0 {
    constructor(e) {
        this.parser = e,
        this.name = Qe.EXT_TEXTURE_AVIF
    }
    loadTexture(e) {
        const t = this.name
          , n = this.parser
          , i = n.json
          , s = i.textures[e];
        if (!s.extensions || !s.extensions[t])
            return null;
        const o = s.extensions[t]
          , a = i.images[o.source];
        let c = n.textureLoader;
        if (a.uri) {
            const l = n.options.manager.getHandler(a.uri);
            l !== null && (c = l)
        }
        return n.loadTextureImage(e, o.source, c)
    }
}
class R0 {
    constructor(e) {
        this.name = Qe.EXT_MESHOPT_COMPRESSION,
        this.parser = e
    }
    loadBufferView(e) {
        const t = this.parser.json
          , n = t.bufferViews[e];
        if (n.extensions && n.extensions[this.name]) {
            const i = n.extensions[this.name]
              , s = this.parser.getDependency("buffer", i.buffer)
              , o = this.parser.options.meshoptDecoder;
            if (!o || !o.supported) {
                if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
                    throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                return null
            }
            return s.then(function(a) {
                const c = i.byteOffset || 0
                  , l = i.byteLength || 0
                  , u = i.count
                  , h = i.byteStride
                  , d = new Uint8Array(a,c,l);
                return o.decodeGltfBufferAsync ? o.decodeGltfBufferAsync(u, h, d, i.mode, i.filter).then(function(f) {
                    return f.buffer
                }) : o.ready.then(function() {
                    const f = new ArrayBuffer(u * h);
                    return o.decodeGltfBuffer(new Uint8Array(f), u, h, d, i.mode, i.filter),
                    f
                })
            })
        } else
            return null
    }
}
class D0 {
    constructor(e) {
        this.name = Qe.EXT_MESH_GPU_INSTANCING,
        this.parser = e
    }
    createNodeMesh(e) {
        const t = this.parser.json
          , n = t.nodes[e];
        if (!n.extensions || !n.extensions[this.name] || n.mesh === void 0)
            return null;
        const i = t.meshes[n.mesh];
        for (const l of i.primitives)
            if (l.mode !== Jt.TRIANGLES && l.mode !== Jt.TRIANGLE_STRIP && l.mode !== Jt.TRIANGLE_FAN && l.mode !== void 0)
                return null;
        const o = n.extensions[this.name].attributes
          , a = []
          , c = {};
        for (const l in o)
            a.push(this.parser.getDependency("accessor", o[l]).then(u => (c[l] = u,
            c[l])));
        return a.length < 1 ? null : (a.push(this.parser.createNodeMesh(e)),
        Promise.all(a).then(l => {
            const u = l.pop()
              , h = u.isGroup ? u.children : [u]
              , d = l[0].count
              , f = [];
            for (const m of h) {
                const g = new We
                  , A = new D
                  , p = new sn
                  , S = new D(1,1,1)
                  , w = new Uu(m.geometry,m.material,d);
                for (let b = 0; b < d; b++)
                    c.TRANSLATION && A.fromBufferAttribute(c.TRANSLATION, b),
                    c.ROTATION && p.fromBufferAttribute(c.ROTATION, b),
                    c.SCALE && S.fromBufferAttribute(c.SCALE, b),
                    w.setMatrixAt(b, g.compose(A, p, S));
                for (const b in c)
                    if (b === "_COLOR_0") {
                        const B = c[b];
                        w.instanceColor = new Ra(B.array,B.itemSize,B.normalized)
                    } else
                        b !== "TRANSLATION" && b !== "ROTATION" && b !== "SCALE" && m.geometry.setAttribute(b, c[b]);
                lt.prototype.copy.call(w, m),
                this.parser.assignFinalMaterial(w),
                f.push(w)
            }
            return u.isGroup ? (u.clear(),
            u.add(...f),
            u) : f[0]
        }
        ))
    }
}
const sh = "glTF"
  , ms = 12
  , su = {
    JSON: 1313821514,
    BIN: 5130562
};
class N0 {
    constructor(e) {
        this.name = Qe.KHR_BINARY_GLTF,
        this.content = null,
        this.body = null;
        const t = new DataView(e,0,ms)
          , n = new TextDecoder;
        if (this.header = {
            magic: n.decode(new Uint8Array(e.slice(0, 4))),
            version: t.getUint32(4, !0),
            length: t.getUint32(8, !0)
        },
        this.header.magic !== sh)
            throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
        if (this.header.version < 2)
            throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
        const i = this.header.length - ms
          , s = new DataView(e,ms);
        let o = 0;
        for (; o < i; ) {
            const a = s.getUint32(o, !0);
            o += 4;
            const c = s.getUint32(o, !0);
            if (o += 4,
            c === su.JSON) {
                const l = new Uint8Array(e,ms + o,a);
                this.content = n.decode(l)
            } else if (c === su.BIN) {
                const l = ms + o;
                this.body = e.slice(l, l + a)
            }
            o += a
        }
        if (this.content === null)
            throw new Error("THREE.GLTFLoader: JSON content not found.")
    }
}
class O0 {
    constructor(e, t) {
        if (!t)
            throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
        this.name = Qe.KHR_DRACO_MESH_COMPRESSION,
        this.json = e,
        this.dracoLoader = t,
        this.dracoLoader.preload()
    }
    decodePrimitive(e, t) {
        const n = this.json
          , i = this.dracoLoader
          , s = e.extensions[this.name].bufferView
          , o = e.extensions[this.name].attributes
          , a = {}
          , c = {}
          , l = {};
        for (const u in o) {
            const h = Xa[u] || u.toLowerCase();
            a[h] = o[u]
        }
        for (const u in e.attributes) {
            const h = Xa[u] || u.toLowerCase();
            if (o[u] !== void 0) {
                const d = n.accessors[e.attributes[u]]
                  , f = Gi[d.componentType];
                l[h] = f.name,
                c[h] = d.normalized === !0
            }
        }
        return t.getDependency("bufferView", s).then(function(u) {
            return new Promise(function(h, d) {
                i.decodeDracoFile(u, function(f) {
                    for (const m in f.attributes) {
                        const g = f.attributes[m]
                          , A = c[m];
                        A !== void 0 && (g.normalized = A)
                    }
                    h(f)
                }, a, l, Ht, d)
            }
            )
        })
    }
}
class z0 {
    constructor() {
        this.name = Qe.KHR_TEXTURE_TRANSFORM
    }
    extendTexture(e, t) {
        return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(),
        t.texCoord !== void 0 && (e.channel = t.texCoord),
        t.offset !== void 0 && e.offset.fromArray(t.offset),
        t.rotation !== void 0 && (e.rotation = t.rotation),
        t.scale !== void 0 && e.repeat.fromArray(t.scale),
        e.needsUpdate = !0),
        e
    }
}
class I0 {
    constructor() {
        this.name = Qe.KHR_MESH_QUANTIZATION
    }
}
class rh extends Gs {
    constructor(e, t, n, i) {
        super(e, t, n, i)
    }
    copySampleValue_(e) {
        const t = this.resultBuffer
          , n = this.sampleValues
          , i = this.valueSize
          , s = e * i * 3 + i;
        for (let o = 0; o !== i; o++)
            t[o] = n[s + o];
        return t
    }
    interpolate_(e, t, n, i) {
        const s = this.resultBuffer
          , o = this.sampleValues
          , a = this.valueSize
          , c = a * 2
          , l = a * 3
          , u = i - t
          , h = (n - t) / u
          , d = h * h
          , f = d * h
          , m = e * l
          , g = m - l
          , A = -2 * f + 3 * d
          , p = f - d
          , S = 1 - A
          , w = p - d + h;
        for (let b = 0; b !== a; b++) {
            const B = o[g + b + a]
              , z = o[g + b + c] * u
              , I = o[m + b + a]
              , H = o[m + b] * u;
            s[b] = S * B + w * z + A * I + p * H
        }
        return s
    }
}
const U0 = new sn;
class B0 extends rh {
    interpolate_(e, t, n, i) {
        const s = super.interpolate_(e, t, n, i);
        return U0.fromArray(s).normalize().toArray(s),
        s
    }
}
const Jt = {
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6
}
  , Gi = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
}
  , ru = {
    9728: _t,
    9729: Yt,
    9984: mu,
    9985: Cr,
    9986: As,
    9987: In
}
  , ou = {
    33071: Kn,
    33648: Fr,
    10497: ki
}
  , Go = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
}
  , Xa = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv1",
    TEXCOORD_2: "uv2",
    TEXCOORD_3: "uv3",
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex"
}
  , Yn = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences"
}
  , F0 = {
    CUBICSPLINE: void 0,
    LINEAR: Ds,
    STEP: Rs
}
  , Vo = {
    OPAQUE: "OPAQUE",
    MASK: "MASK",
    BLEND: "BLEND"
};
function _0(r) {
    return r.DefaultMaterial === void 0 && (r.DefaultMaterial = new Ki({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: Hn
    })),
    r.DefaultMaterial
}
function ui(r, e, t) {
    for (const n in t.extensions)
        r[n] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {},
        e.userData.gltfExtensions[n] = t.extensions[n])
}
function On(r, e) {
    e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(r.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras))
}
function H0(r, e, t) {
    let n = !1
      , i = !1
      , s = !1;
    for (let l = 0, u = e.length; l < u; l++) {
        const h = e[l];
        if (h.POSITION !== void 0 && (n = !0),
        h.NORMAL !== void 0 && (i = !0),
        h.COLOR_0 !== void 0 && (s = !0),
        n && i && s)
            break
    }
    if (!n && !i && !s)
        return Promise.resolve(r);
    const o = []
      , a = []
      , c = [];
    for (let l = 0, u = e.length; l < u; l++) {
        const h = e[l];
        if (n) {
            const d = h.POSITION !== void 0 ? t.getDependency("accessor", h.POSITION) : r.attributes.position;
            o.push(d)
        }
        if (i) {
            const d = h.NORMAL !== void 0 ? t.getDependency("accessor", h.NORMAL) : r.attributes.normal;
            a.push(d)
        }
        if (s) {
            const d = h.COLOR_0 !== void 0 ? t.getDependency("accessor", h.COLOR_0) : r.attributes.color;
            c.push(d)
        }
    }
    return Promise.all([Promise.all(o), Promise.all(a), Promise.all(c)]).then(function(l) {
        const u = l[0]
          , h = l[1]
          , d = l[2];
        return n && (r.morphAttributes.position = u),
        i && (r.morphAttributes.normal = h),
        s && (r.morphAttributes.color = d),
        r.morphTargetsRelative = !0,
        r
    })
}
function X0(r, e) {
    if (r.updateMorphTargets(),
    e.weights !== void 0)
        for (let t = 0, n = e.weights.length; t < n; t++)
            r.morphTargetInfluences[t] = e.weights[t];
    if (e.extras && Array.isArray(e.extras.targetNames)) {
        const t = e.extras.targetNames;
        if (r.morphTargetInfluences.length === t.length) {
            r.morphTargetDictionary = {};
            for (let n = 0, i = t.length; n < i; n++)
                r.morphTargetDictionary[t[n]] = n
        } else
            console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
    }
}
function G0(r) {
    let e;
    const t = r.extensions && r.extensions[Qe.KHR_DRACO_MESH_COMPRESSION];
    if (t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + Wo(t.attributes) : e = r.indices + ":" + Wo(r.attributes) + ":" + r.mode,
    r.targets !== void 0)
        for (let n = 0, i = r.targets.length; n < i; n++)
            e += ":" + Wo(r.targets[n]);
    return e
}
function Wo(r) {
    let e = "";
    const t = Object.keys(r).sort();
    for (let n = 0, i = t.length; n < i; n++)
        e += t[n] + ":" + r[t[n]] + ";";
    return e
}
function Ga(r) {
    switch (r) {
    case Int8Array:
        return 1 / 127;
    case Uint8Array:
        return 1 / 255;
    case Int16Array:
        return 1 / 32767;
    case Uint16Array:
        return 1 / 65535;
    default:
        throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
    }
}
function V0(r) {
    return r.search(/\.jpe?g($|\?)/i) > 0 || r.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : r.search(/\.webp($|\?)/i) > 0 || r.search(/^data\:image\/webp/) === 0 ? "image/webp" : r.search(/\.ktx2($|\?)/i) > 0 || r.search(/^data\:image\/ktx2/) === 0 ? "image/ktx2" : "image/png"
}
const W0 = new We;
class j0 {
    constructor(e={}, t={}) {
        this.json = e,
        this.extensions = {},
        this.plugins = {},
        this.options = t,
        this.cache = new f0,
        this.associations = new Map,
        this.primitiveCache = {},
        this.nodeCache = {},
        this.meshCache = {
            refs: {},
            uses: {}
        },
        this.cameraCache = {
            refs: {},
            uses: {}
        },
        this.lightCache = {
            refs: {},
            uses: {}
        },
        this.sourceCache = {},
        this.textureCache = {},
        this.nodeNamesUsed = {};
        let n = !1
          , i = -1
          , s = !1
          , o = -1;
        if (typeof navigator < "u") {
            const a = navigator.userAgent;
            n = /^((?!chrome|android).)*safari/i.test(a) === !0;
            const c = a.match(/Version\/(\d+)/);
            i = n && c ? parseInt(c[1], 10) : -1,
            s = a.indexOf("Firefox") > -1,
            o = s ? a.match(/Firefox\/([0-9]+)\./)[1] : -1
        }
        typeof createImageBitmap > "u" || n && i < 17 || s && o < 98 ? this.textureLoader = new ep(this.options.manager) : this.textureLoader = new cp(this.options.manager),
        this.textureLoader.setCrossOrigin(this.options.crossOrigin),
        this.textureLoader.setRequestHeader(this.options.requestHeader),
        this.fileLoader = new hc(this.options.manager),
        this.fileLoader.setResponseType("arraybuffer"),
        this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0)
    }
    setExtensions(e) {
        this.extensions = e
    }
    setPlugins(e) {
        this.plugins = e
    }
    parse(e, t) {
        const n = this
          , i = this.json
          , s = this.extensions;
        this.cache.removeAll(),
        this.nodeCache = {},
        this._invokeAll(function(o) {
            return o._markDefs && o._markDefs()
        }),
        Promise.all(this._invokeAll(function(o) {
            return o.beforeRoot && o.beforeRoot()
        })).then(function() {
            return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
        }).then(function(o) {
            const a = {
                scene: o[0][i.scene || 0],
                scenes: o[0],
                animations: o[1],
                cameras: o[2],
                asset: i.asset,
                parser: n,
                userData: {}
            };
            return ui(s, a, i),
            On(a, i),
            Promise.all(n._invokeAll(function(c) {
                return c.afterRoot && c.afterRoot(a)
            })).then(function() {
                for (const c of a.scenes)
                    c.updateMatrixWorld();
                e(a)
            })
        }).catch(t)
    }
    _markDefs() {
        const e = this.json.nodes || []
          , t = this.json.skins || []
          , n = this.json.meshes || [];
        for (let i = 0, s = t.length; i < s; i++) {
            const o = t[i].joints;
            for (let a = 0, c = o.length; a < c; a++)
                e[o[a]].isBone = !0
        }
        for (let i = 0, s = e.length; i < s; i++) {
            const o = e[i];
            o.mesh !== void 0 && (this._addNodeRef(this.meshCache, o.mesh),
            o.skin !== void 0 && (n[o.mesh].isSkinnedMesh = !0)),
            o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera)
        }
    }
    _addNodeRef(e, t) {
        t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0),
        e.refs[t]++)
    }
    _getNodeRef(e, t, n) {
        if (e.refs[t] <= 1)
            return n;
        const i = n.clone()
          , s = (o, a) => {
            const c = this.associations.get(o);
            c != null && this.associations.set(a, c);
            for (const [l,u] of o.children.entries())
                s(u, a.children[l])
        }
        ;
        return s(n, i),
        i.name += "_instance_" + e.uses[t]++,
        i
    }
    _invokeOne(e) {
        const t = Object.values(this.plugins);
        t.push(this);
        for (let n = 0; n < t.length; n++) {
            const i = e(t[n]);
            if (i)
                return i
        }
        return null
    }
    _invokeAll(e) {
        const t = Object.values(this.plugins);
        t.unshift(this);
        const n = [];
        for (let i = 0; i < t.length; i++) {
            const s = e(t[i]);
            s && n.push(s)
        }
        return n
    }
    getDependency(e, t) {
        const n = e + ":" + t;
        let i = this.cache.get(n);
        if (!i) {
            switch (e) {
            case "scene":
                i = this.loadScene(t);
                break;
            case "node":
                i = this._invokeOne(function(s) {
                    return s.loadNode && s.loadNode(t)
                });
                break;
            case "mesh":
                i = this._invokeOne(function(s) {
                    return s.loadMesh && s.loadMesh(t)
                });
                break;
            case "accessor":
                i = this.loadAccessor(t);
                break;
            case "bufferView":
                i = this._invokeOne(function(s) {
                    return s.loadBufferView && s.loadBufferView(t)
                });
                break;
            case "buffer":
                i = this.loadBuffer(t);
                break;
            case "material":
                i = this._invokeOne(function(s) {
                    return s.loadMaterial && s.loadMaterial(t)
                });
                break;
            case "texture":
                i = this._invokeOne(function(s) {
                    return s.loadTexture && s.loadTexture(t)
                });
                break;
            case "skin":
                i = this.loadSkin(t);
                break;
            case "animation":
                i = this._invokeOne(function(s) {
                    return s.loadAnimation && s.loadAnimation(t)
                });
                break;
            case "camera":
                i = this.loadCamera(t);
                break;
            default:
                if (i = this._invokeOne(function(s) {
                    return s != this && s.getDependency && s.getDependency(e, t)
                }),
                !i)
                    throw new Error("Unknown type: " + e);
                break
            }
            this.cache.add(n, i)
        }
        return i
    }
    getDependencies(e) {
        let t = this.cache.get(e);
        if (!t) {
            const n = this
              , i = this.json[e + (e === "mesh" ? "es" : "s")] || [];
            t = Promise.all(i.map(function(s, o) {
                return n.getDependency(e, o)
            })),
            this.cache.add(e, t)
        }
        return t
    }
    loadBuffer(e) {
        const t = this.json.buffers[e]
          , n = this.fileLoader;
        if (t.type && t.type !== "arraybuffer")
            throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
        if (t.uri === void 0 && e === 0)
            return Promise.resolve(this.extensions[Qe.KHR_BINARY_GLTF].body);
        const i = this.options;
        return new Promise(function(s, o) {
            n.load(Ts.resolveURL(t.uri, i.path), s, void 0, function() {
                o(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
            })
        }
        )
    }
    loadBufferView(e) {
        const t = this.json.bufferViews[e];
        return this.getDependency("buffer", t.buffer).then(function(n) {
            const i = t.byteLength || 0
              , s = t.byteOffset || 0;
            return n.slice(s, s + i)
        })
    }
    loadAccessor(e) {
        const t = this
          , n = this.json
          , i = this.json.accessors[e];
        if (i.bufferView === void 0 && i.sparse === void 0) {
            const o = Go[i.type]
              , a = Gi[i.componentType]
              , c = i.normalized === !0
              , l = new a(i.count * o);
            return Promise.resolve(new vt(l,o,c))
        }
        const s = [];
        return i.bufferView !== void 0 ? s.push(this.getDependency("bufferView", i.bufferView)) : s.push(null),
        i.sparse !== void 0 && (s.push(this.getDependency("bufferView", i.sparse.indices.bufferView)),
        s.push(this.getDependency("bufferView", i.sparse.values.bufferView))),
        Promise.all(s).then(function(o) {
            const a = o[0]
              , c = Go[i.type]
              , l = Gi[i.componentType]
              , u = l.BYTES_PER_ELEMENT
              , h = u * c
              , d = i.byteOffset || 0
              , f = i.bufferView !== void 0 ? n.bufferViews[i.bufferView].byteStride : void 0
              , m = i.normalized === !0;
            let g, A;
            if (f && f !== h) {
                const p = Math.floor(d / f)
                  , S = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + p + ":" + i.count;
                let w = t.cache.get(S);
                w || (g = new l(a,p * f,i.count * f / u),
                w = new Ou(g,f / u),
                t.cache.add(S, w)),
                A = new Bn(w,c,d % f / u,m)
            } else
                a === null ? g = new l(i.count * c) : g = new l(a,d,i.count * c),
                A = new vt(g,c,m);
            if (i.sparse !== void 0) {
                const p = Go.SCALAR
                  , S = Gi[i.sparse.indices.componentType]
                  , w = i.sparse.indices.byteOffset || 0
                  , b = i.sparse.values.byteOffset || 0
                  , B = new S(o[1],w,i.sparse.count * p)
                  , z = new l(o[2],b,i.sparse.count * c);
                a !== null && (A = new vt(A.array.slice(),A.itemSize,A.normalized)),
                A.normalized = !1;
                for (let I = 0, H = B.length; I < H; I++) {
                    const P = B[I];
                    if (A.setX(P, z[I * c]),
                    c >= 2 && A.setY(P, z[I * c + 1]),
                    c >= 3 && A.setZ(P, z[I * c + 2]),
                    c >= 4 && A.setW(P, z[I * c + 3]),
                    c >= 5)
                        throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                }
                A.normalized = m
            }
            return A
        })
    }
    loadTexture(e) {
        const t = this.json
          , n = this.options
          , s = t.textures[e].source
          , o = t.images[s];
        let a = this.textureLoader;
        if (o.uri) {
            const c = n.manager.getHandler(o.uri);
            c !== null && (a = c)
        }
        return this.loadTextureImage(e, s, a)
    }
    loadTextureImage(e, t, n) {
        const i = this
          , s = this.json
          , o = s.textures[e]
          , a = s.images[t]
          , c = (a.uri || a.bufferView) + ":" + o.sampler;
        if (this.textureCache[c])
            return this.textureCache[c];
        const l = this.loadImageSource(t, n).then(function(u) {
            u.flipY = !1,
            u.name = o.name || a.name || "",
            u.name === "" && typeof a.uri == "string" && a.uri.startsWith("data:image/") === !1 && (u.name = a.uri);
            const d = (s.samplers || {})[o.sampler] || {};
            return u.magFilter = ru[d.magFilter] || Yt,
            u.minFilter = ru[d.minFilter] || In,
            u.wrapS = ou[d.wrapS] || ki,
            u.wrapT = ou[d.wrapT] || ki,
            u.generateMipmaps = !u.isCompressedTexture && u.minFilter !== _t && u.minFilter !== Yt,
            i.associations.set(u, {
                textures: e
            }),
            u
        }).catch(function() {
            return null
        });
        return this.textureCache[c] = l,
        l
    }
    loadImageSource(e, t) {
        const n = this
          , i = this.json
          , s = this.options;
        if (this.sourceCache[e] !== void 0)
            return this.sourceCache[e].then(h => h.clone());
        const o = i.images[e]
          , a = self.URL || self.webkitURL;
        let c = o.uri || ""
          , l = !1;
        if (o.bufferView !== void 0)
            c = n.getDependency("bufferView", o.bufferView).then(function(h) {
                l = !0;
                const d = new Blob([h],{
                    type: o.mimeType
                });
                return c = a.createObjectURL(d),
                c
            });
        else if (o.uri === void 0)
            throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
        const u = Promise.resolve(c).then(function(h) {
            return new Promise(function(d, f) {
                let m = d;
                t.isImageBitmapLoader === !0 && (m = function(g) {
                    const A = new Tt(g);
                    A.needsUpdate = !0,
                    d(A)
                }
                ),
                t.load(Ts.resolveURL(h, s.path), m, void 0, f)
            }
            )
        }).then(function(h) {
            return l === !0 && a.revokeObjectURL(c),
            On(h, o),
            h.userData.mimeType = o.mimeType || V0(o.uri),
            h
        }).catch(function(h) {
            throw console.error("THREE.GLTFLoader: Couldn't load texture", c),
            h
        });
        return this.sourceCache[e] = u,
        u
    }
    assignTexture(e, t, n, i) {
        const s = this;
        return this.getDependency("texture", n.index).then(function(o) {
            if (!o)
                return null;
            if (n.texCoord !== void 0 && n.texCoord > 0 && (o = o.clone(),
            o.channel = n.texCoord),
            s.extensions[Qe.KHR_TEXTURE_TRANSFORM]) {
                const a = n.extensions !== void 0 ? n.extensions[Qe.KHR_TEXTURE_TRANSFORM] : void 0;
                if (a) {
                    const c = s.associations.get(o);
                    o = s.extensions[Qe.KHR_TEXTURE_TRANSFORM].extendTexture(o, a),
                    s.associations.set(o, c)
                }
            }
            return i !== void 0 && (o.colorSpace = i),
            e[t] = o,
            o
        })
    }
    assignFinalMaterial(e) {
        const t = e.geometry;
        let n = e.material;
        const i = t.attributes.tangent === void 0
          , s = t.attributes.color !== void 0
          , o = t.attributes.normal === void 0;
        if (e.isPoints) {
            const a = "PointsMaterial:" + n.uuid;
            let c = this.cache.get(a);
            c || (c = new Fu,
            fn.prototype.copy.call(c, n),
            c.color.copy(n.color),
            c.map = n.map,
            c.sizeAttenuation = !1,
            this.cache.add(a, c)),
            n = c
        } else if (e.isLine) {
            const a = "LineBasicMaterial:" + n.uuid;
            let c = this.cache.get(a);
            c || (c = new jr,
            fn.prototype.copy.call(c, n),
            c.color.copy(n.color),
            c.map = n.map,
            this.cache.add(a, c)),
            n = c
        }
        if (i || s || o) {
            let a = "ClonedMaterial:" + n.uuid + ":";
            i && (a += "derivative-tangents:"),
            s && (a += "vertex-colors:"),
            o && (a += "flat-shading:");
            let c = this.cache.get(a);
            c || (c = n.clone(),
            s && (c.vertexColors = !0),
            o && (c.flatShading = !0),
            i && (c.normalScale && (c.normalScale.y *= -1),
            c.clearcoatNormalScale && (c.clearcoatNormalScale.y *= -1)),
            this.cache.add(a, c),
            this.associations.set(c, this.associations.get(n))),
            n = c
        }
        e.material = n
    }
    getMaterialType() {
        return Ki
    }
    loadMaterial(e) {
        const t = this
          , n = this.json
          , i = this.extensions
          , s = n.materials[e];
        let o;
        const a = {}
          , c = s.extensions || {}
          , l = [];
        if (c[Qe.KHR_MATERIALS_UNLIT]) {
            const h = i[Qe.KHR_MATERIALS_UNLIT];
            o = h.getMaterialType(),
            l.push(h.extendParams(a, s, t))
        } else {
            const h = s.pbrMetallicRoughness || {};
            if (a.color = new Ge(1,1,1),
            a.opacity = 1,
            Array.isArray(h.baseColorFactor)) {
                const d = h.baseColorFactor;
                a.color.setRGB(d[0], d[1], d[2], Ht),
                a.opacity = d[3]
            }
            h.baseColorTexture !== void 0 && l.push(t.assignTexture(a, "map", h.baseColorTexture, Rt)),
            a.metalness = h.metallicFactor !== void 0 ? h.metallicFactor : 1,
            a.roughness = h.roughnessFactor !== void 0 ? h.roughnessFactor : 1,
            h.metallicRoughnessTexture !== void 0 && (l.push(t.assignTexture(a, "metalnessMap", h.metallicRoughnessTexture)),
            l.push(t.assignTexture(a, "roughnessMap", h.metallicRoughnessTexture))),
            o = this._invokeOne(function(d) {
                return d.getMaterialType && d.getMaterialType(e)
            }),
            l.push(Promise.all(this._invokeAll(function(d) {
                return d.extendMaterialParams && d.extendMaterialParams(e, a)
            })))
        }
        s.doubleSided === !0 && (a.side = $t);
        const u = s.alphaMode || Vo.OPAQUE;
        if (u === Vo.BLEND ? (a.transparent = !0,
        a.depthWrite = !1) : (a.transparent = !1,
        u === Vo.MASK && (a.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : .5)),
        s.normalTexture !== void 0 && o !== Qn && (l.push(t.assignTexture(a, "normalMap", s.normalTexture)),
        a.normalScale = new Ae(1,1),
        s.normalTexture.scale !== void 0)) {
            const h = s.normalTexture.scale;
            a.normalScale.set(h, h)
        }
        if (s.occlusionTexture !== void 0 && o !== Qn && (l.push(t.assignTexture(a, "aoMap", s.occlusionTexture)),
        s.occlusionTexture.strength !== void 0 && (a.aoMapIntensity = s.occlusionTexture.strength)),
        s.emissiveFactor !== void 0 && o !== Qn) {
            const h = s.emissiveFactor;
            a.emissive = new Ge().setRGB(h[0], h[1], h[2], Ht)
        }
        return s.emissiveTexture !== void 0 && o !== Qn && l.push(t.assignTexture(a, "emissiveMap", s.emissiveTexture, Rt)),
        Promise.all(l).then(function() {
            const h = new o(a);
            return s.name && (h.name = s.name),
            On(h, s),
            t.associations.set(h, {
                materials: e
            }),
            s.extensions && ui(i, h, s),
            h
        })
    }
    createUniqueName(e) {
        const t = ot.sanitizeNodeName(e || "");
        return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0,
        t)
    }
    loadGeometries(e) {
        const t = this
          , n = this.extensions
          , i = this.primitiveCache;
        function s(a) {
            return n[Qe.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a, t).then(function(c) {
                return au(c, a, t)
            })
        }
        const o = [];
        for (let a = 0, c = e.length; a < c; a++) {
            const l = e[a]
              , u = G0(l)
              , h = i[u];
            if (h)
                o.push(h.promise);
            else {
                let d;
                l.extensions && l.extensions[Qe.KHR_DRACO_MESH_COMPRESSION] ? d = s(l) : d = au(new At, l, t),
                i[u] = {
                    primitive: l,
                    promise: d
                },
                o.push(d)
            }
        }
        return Promise.all(o)
    }
    loadMesh(e) {
        const t = this
          , n = this.json
          , i = this.extensions
          , s = n.meshes[e]
          , o = s.primitives
          , a = [];
        for (let c = 0, l = o.length; c < l; c++) {
            const u = o[c].material === void 0 ? _0(this.cache) : this.getDependency("material", o[c].material);
            a.push(u)
        }
        return a.push(t.loadGeometries(o)),
        Promise.all(a).then(function(c) {
            const l = c.slice(0, c.length - 1)
              , u = c[c.length - 1]
              , h = [];
            for (let f = 0, m = u.length; f < m; f++) {
                const g = u[f]
                  , A = o[f];
                let p;
                const S = l[f];
                if (A.mode === Jt.TRIANGLES || A.mode === Jt.TRIANGLE_STRIP || A.mode === Jt.TRIANGLE_FAN || A.mode === void 0)
                    p = s.isSkinnedMesh === !0 ? new Qd(g,S) : new ct(g,S),
                    p.isSkinnedMesh === !0 && p.normalizeSkinWeights(),
                    A.mode === Jt.TRIANGLE_STRIP ? p.geometry = iu(p.geometry, wu) : A.mode === Jt.TRIANGLE_FAN && (p.geometry = iu(p.geometry, La));
                else if (A.mode === Jt.LINES)
                    p = new Bu(g,S);
                else if (A.mode === Jt.LINE_STRIP)
                    p = new Xi(g,S);
                else if (A.mode === Jt.LINE_LOOP)
                    p = new nf(g,S);
                else if (A.mode === Jt.POINTS)
                    p = new sf(g,S);
                else
                    throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + A.mode);
                Object.keys(p.geometry.morphAttributes).length > 0 && X0(p, s),
                p.name = t.createUniqueName(s.name || "mesh_" + e),
                On(p, s),
                A.extensions && ui(i, p, A),
                t.assignFinalMaterial(p),
                h.push(p)
            }
            for (let f = 0, m = h.length; f < m; f++)
                t.associations.set(h[f], {
                    meshes: e,
                    primitives: f
                });
            if (h.length === 1)
                return s.extensions && ui(i, h[0], s),
                h[0];
            const d = new Jn;
            s.extensions && ui(i, d, s),
            t.associations.set(d, {
                meshes: e
            });
            for (let f = 0, m = h.length; f < m; f++)
                d.add(h[f]);
            return d
        })
    }
    loadCamera(e) {
        let t;
        const n = this.json.cameras[e]
          , i = n[n.type];
        if (!i) {
            console.warn("THREE.GLTFLoader: Missing camera parameters.");
            return
        }
        return n.type === "perspective" ? t = new Bt(Dt.radToDeg(i.yfov),i.aspectRatio || 1,i.znear || 1,i.zfar || 2e6) : n.type === "orthographic" && (t = new Yr(-i.xmag,i.xmag,i.ymag,-i.ymag,i.znear,i.zfar)),
        n.name && (t.name = this.createUniqueName(n.name)),
        On(t, n),
        Promise.resolve(t)
    }
    loadSkin(e) {
        const t = this.json.skins[e]
          , n = [];
        for (let i = 0, s = t.joints.length; i < s; i++)
            n.push(this._loadNodeShallow(t.joints[i]));
        return t.inverseBindMatrices !== void 0 ? n.push(this.getDependency("accessor", t.inverseBindMatrices)) : n.push(null),
        Promise.all(n).then(function(i) {
            const s = i.pop()
              , o = i
              , a = []
              , c = [];
            for (let l = 0, u = o.length; l < u; l++) {
                const h = o[l];
                if (h) {
                    a.push(h);
                    const d = new We;
                    s !== null && d.fromArray(s.array, l * 16),
                    c.push(d)
                } else
                    console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[l])
            }
            return new rc(a,c)
        })
    }
    loadAnimation(e) {
        const t = this.json
          , n = this
          , i = t.animations[e]
          , s = i.name ? i.name : "animation_" + e
          , o = []
          , a = []
          , c = []
          , l = []
          , u = [];
        for (let h = 0, d = i.channels.length; h < d; h++) {
            const f = i.channels[h]
              , m = i.samplers[f.sampler]
              , g = f.target
              , A = g.node
              , p = i.parameters !== void 0 ? i.parameters[m.input] : m.input
              , S = i.parameters !== void 0 ? i.parameters[m.output] : m.output;
            g.node !== void 0 && (o.push(this.getDependency("node", A)),
            a.push(this.getDependency("accessor", p)),
            c.push(this.getDependency("accessor", S)),
            l.push(m),
            u.push(g))
        }
        return Promise.all([Promise.all(o), Promise.all(a), Promise.all(c), Promise.all(l), Promise.all(u)]).then(function(h) {
            const d = h[0]
              , f = h[1]
              , m = h[2]
              , g = h[3]
              , A = h[4]
              , p = [];
            for (let S = 0, w = d.length; S < w; S++) {
                const b = d[S]
                  , B = f[S]
                  , z = m[S]
                  , I = g[S]
                  , H = A[S];
                if (b === void 0)
                    continue;
                b.updateMatrix && b.updateMatrix();
                const P = n._createAnimationTracks(b, B, z, I, H);
                if (P)
                    for (let T = 0; T < P.length; T++)
                        p.push(P[T])
            }
            return new qf(s,void 0,p)
        })
    }
    createNodeMesh(e) {
        const t = this.json
          , n = this
          , i = t.nodes[e];
        return i.mesh === void 0 ? null : n.getDependency("mesh", i.mesh).then(function(s) {
            const o = n._getNodeRef(n.meshCache, i.mesh, s);
            return i.weights !== void 0 && o.traverse(function(a) {
                if (a.isMesh)
                    for (let c = 0, l = i.weights.length; c < l; c++)
                        a.morphTargetInfluences[c] = i.weights[c]
            }),
            o
        })
    }
    loadNode(e) {
        const t = this.json
          , n = this
          , i = t.nodes[e]
          , s = n._loadNodeShallow(e)
          , o = []
          , a = i.children || [];
        for (let l = 0, u = a.length; l < u; l++)
            o.push(n.getDependency("node", a[l]));
        const c = i.skin === void 0 ? Promise.resolve(null) : n.getDependency("skin", i.skin);
        return Promise.all([s, Promise.all(o), c]).then(function(l) {
            const u = l[0]
              , h = l[1]
              , d = l[2];
            d !== null && u.traverse(function(f) {
                f.isSkinnedMesh && f.bind(d, W0)
            });
            for (let f = 0, m = h.length; f < m; f++)
                u.add(h[f]);
            return u
        })
    }
    _loadNodeShallow(e) {
        const t = this.json
          , n = this.extensions
          , i = this;
        if (this.nodeCache[e] !== void 0)
            return this.nodeCache[e];
        const s = t.nodes[e]
          , o = s.name ? i.createUniqueName(s.name) : ""
          , a = []
          , c = i._invokeOne(function(l) {
            return l.createNodeMesh && l.createNodeMesh(e)
        });
        return c && a.push(c),
        s.camera !== void 0 && a.push(i.getDependency("camera", s.camera).then(function(l) {
            return i._getNodeRef(i.cameraCache, s.camera, l)
        })),
        i._invokeAll(function(l) {
            return l.createNodeAttachment && l.createNodeAttachment(e)
        }).forEach(function(l) {
            a.push(l)
        }),
        this.nodeCache[e] = Promise.all(a).then(function(l) {
            let u;
            if (s.isBone === !0 ? u = new zu : l.length > 1 ? u = new Jn : l.length === 1 ? u = l[0] : u = new lt,
            u !== l[0])
                for (let h = 0, d = l.length; h < d; h++)
                    u.add(l[h]);
            if (s.name && (u.userData.name = s.name,
            u.name = o),
            On(u, s),
            s.extensions && ui(n, u, s),
            s.matrix !== void 0) {
                const h = new We;
                h.fromArray(s.matrix),
                u.applyMatrix4(h)
            } else
                s.translation !== void 0 && u.position.fromArray(s.translation),
                s.rotation !== void 0 && u.quaternion.fromArray(s.rotation),
                s.scale !== void 0 && u.scale.fromArray(s.scale);
            if (!i.associations.has(u))
                i.associations.set(u, {});
            else if (s.mesh !== void 0 && i.meshCache.refs[s.mesh] > 1) {
                const h = i.associations.get(u);
                i.associations.set(u, {
                    ...h
                })
            }
            return i.associations.get(u).nodes = e,
            u
        }),
        this.nodeCache[e]
    }
    loadScene(e) {
        const t = this.extensions
          , n = this.json.scenes[e]
          , i = this
          , s = new Jn;
        n.name && (s.name = i.createUniqueName(n.name)),
        On(s, n),
        n.extensions && ui(t, s, n);
        const o = n.nodes || []
          , a = [];
        for (let c = 0, l = o.length; c < l; c++)
            a.push(i.getDependency("node", o[c]));
        return Promise.all(a).then(function(c) {
            for (let u = 0, h = c.length; u < h; u++)
                s.add(c[u]);
            const l = u => {
                const h = new Map;
                for (const [d,f] of i.associations)
                    (d instanceof fn || d instanceof Tt) && h.set(d, f);
                return u.traverse(d => {
                    const f = i.associations.get(d);
                    f != null && h.set(d, f)
                }
                ),
                h
            }
            ;
            return i.associations = l(s),
            s
        })
    }
    _createAnimationTracks(e, t, n, i, s) {
        const o = []
          , a = e.name ? e.name : e.uuid
          , c = [];
        Yn[s.path] === Yn.weights ? e.traverse(function(d) {
            d.morphTargetInfluences && c.push(d.name ? d.name : d.uuid)
        }) : c.push(a);
        let l;
        switch (Yn[s.path]) {
        case Yn.weights:
            l = Qi;
            break;
        case Yn.rotation:
            l = Ji;
            break;
        case Yn.translation:
        case Yn.scale:
            l = $i;
            break;
        default:
            switch (n.itemSize) {
            case 1:
                l = Qi;
                break;
            case 2:
            case 3:
            default:
                l = $i;
                break
            }
            break
        }
        const u = i.interpolation !== void 0 ? F0[i.interpolation] : Ds
          , h = this._getArrayFromAccessor(n);
        for (let d = 0, f = c.length; d < f; d++) {
            const m = new l(c[d] + "." + Yn[s.path],t.array,h,u);
            i.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(m),
            o.push(m)
        }
        return o
    }
    _getArrayFromAccessor(e) {
        let t = e.array;
        if (e.normalized) {
            const n = Ga(t.constructor)
              , i = new Float32Array(t.length);
            for (let s = 0, o = t.length; s < o; s++)
                i[s] = t[s] * n;
            t = i
        }
        return t
    }
    _createCubicSplineTrackInterpolant(e) {
        e.createInterpolant = function(n) {
            const i = this instanceof Ji ? B0 : rh;
            return new i(this.times,this.values,this.getValueSize() / 3,n)
        }
        ,
        e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0
    }
}
function k0(r, e, t) {
    const n = e.attributes
      , i = new xt;
    if (n.POSITION !== void 0) {
        const a = t.json.accessors[n.POSITION]
          , c = a.min
          , l = a.max;
        if (c !== void 0 && l !== void 0) {
            if (i.set(new D(c[0],c[1],c[2]), new D(l[0],l[1],l[2])),
            a.normalized) {
                const u = Ga(Gi[a.componentType]);
                i.min.multiplyScalar(u),
                i.max.multiplyScalar(u)
            }
        } else {
            console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
            return
        }
    } else
        return;
    const s = e.targets;
    if (s !== void 0) {
        const a = new D
          , c = new D;
        for (let l = 0, u = s.length; l < u; l++) {
            const h = s[l];
            if (h.POSITION !== void 0) {
                const d = t.json.accessors[h.POSITION]
                  , f = d.min
                  , m = d.max;
                if (f !== void 0 && m !== void 0) {
                    if (c.setX(Math.max(Math.abs(f[0]), Math.abs(m[0]))),
                    c.setY(Math.max(Math.abs(f[1]), Math.abs(m[1]))),
                    c.setZ(Math.max(Math.abs(f[2]), Math.abs(m[2]))),
                    d.normalized) {
                        const g = Ga(Gi[d.componentType]);
                        c.multiplyScalar(g)
                    }
                    a.max(c)
                } else
                    console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
            }
        }
        i.expandByVector(a)
    }
    r.boundingBox = i;
    const o = new rn;
    i.getCenter(o.center),
    o.radius = i.min.distanceTo(i.max) / 2,
    r.boundingSphere = o
}
function au(r, e, t) {
    const n = e.attributes
      , i = [];
    function s(o, a) {
        return t.getDependency("accessor", o).then(function(c) {
            r.setAttribute(a, c)
        })
    }
    for (const o in n) {
        const a = Xa[o] || o.toLowerCase();
        a in r.attributes || i.push(s(n[o], a))
    }
    if (e.indices !== void 0 && !r.index) {
        const o = t.getDependency("accessor", e.indices).then(function(a) {
            r.setIndex(a)
        });
        i.push(o)
    }
    return et.workingColorSpace !== Ht && "COLOR_0"in n && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${et.workingColorSpace}" not supported.`),
    On(r, e),
    k0(r, e, t),
    Promise.all(i).then(function() {
        return e.targets !== void 0 ? H0(r, e.targets, t) : r
    })
}
class Y0 {
    constructor(e, t, n) {
        this.camera = e,
        this.domElement = t,
        this.scene = n,
        this.isTwoFingerTouch = !1,
        this.isOneFingerTouch = !1,
        this.initialOneFingerPos = null,
        this.isNavigating = !1,
        this.initialPinchDistance = 0,
        this.initialPinchAngle = 0,
        this.currentPinchDistance = 0,
        this.currentPinchAngle = 0,
        this.touchPoints = [],
        this.initialTouchPoints = [],
        this.touchMidpoint = new Ae,
        this.initialTouchMidpoint = new Ae,
        this.initialPitchPivot = new D,
        this.previousTouchCount = 0,
        this.worldCenterPoint = new D,
        this.currentPitchDeg = 0,
        this.In3DView = !1,
        this.isLeftMouseDown = !1,
        this.isCtrlLeftMouseDown = !1,
        this.initialMousePos = null,
        this.orbitPoint = new D,
        this.MODE_NONE = 0,
        this.MODE_DOLLY = 1,
        this.MODE_TWIST = 2,
        this.MODE_3D = 3,
        this.MODE_PAN = 4,
        this.MODE_ORBIT = 5,
        this.currentMode = this.MODE_NONE,
        this.ANGLE_THRESHOLD = .008,
        this.DISTANCE_THRESHOLD = 5,
        this.PAN_SENSITIVITY = 1,
        this.ORBIT_SENSITIVITY = .005,
        this.raycaster = new Vr,
        this.groundPlane = new xn(new D(0,1,0),0),
        this.isLerping = !1,
        this.lerpStartTime = 0,
        this.lerpDuration = 1e3,
        this.startPosition = new D,
        this.endPosition = new D,
        this.startQuaternion = new sn,
        this.endQuaternion = new sn,
        this.transitionStartTime = 0,
        this.isTransitioning = !1,
        this.initEventListeners(),
        this.updateWorldCenterPoint()
    }
    lerpCameraOrientToNorth(e=0, t=!1, n=1e3) {
        this.stopLerp(),
        this.isLerping = !0,
        this.lerpStartTime = performance.now(),
        this.lerpDuration = n,
        this.startPosition.copy(this.camera.position),
        this.endPosition.copy(this.camera.position),
        this.startQuaternion.copy(this.camera.quaternion);
        const i = Dt.degToRad(e);
        let s;
        if (t) {
            const o = -Math.PI / 2 + .001;
            s = new Ft(o,i,0,"YXZ")
        } else {
            const o = new Ft().setFromQuaternion(this.camera.quaternion, "YXZ");
            s = new Ft(o.x,i,o.z,"YXZ")
        }
        this.endQuaternion.setFromEuler(s)
    }
    lerpCameraToHome(e, t=-Math.PI / 2 + .001, n=0, i=0, s=1e3) {
        this.stopLerp(),
        this.isLerping = !0,
        this.lerpStartTime = performance.now(),
        this.lerpDuration = s,
        this.startPosition.copy(this.camera.position),
        this.startQuaternion.copy(this.camera.quaternion),
        this.endPosition.copy(e);
        const o = new Ft(t,n,i,"YXZ");
        this.endQuaternion.setFromEuler(o)
    }
    updateLerp() {
        if (!this.isLerping)
            return;
        const t = performance.now() - this.lerpStartTime;
        let n = Math.min(1, t / this.lerpDuration);
        n = n * n * (3 - 2 * n),
        this.camera.position.lerpVectors(this.startPosition, this.endPosition, n),
        this.camera.quaternion.slerpQuaternions(this.startQuaternion, this.endQuaternion, n),
        this.camera.zoom != 1 && (this.camera.zoom = (1 - this.camera.zoom) * n,
        this.camera.updateProjectionMatrix()),
        n >= 1 && (this.isLerping = !1,
        this.camera.updateProjectionMatrix(),
        this.updateWorldCenterPoint())
    }
    stopLerp() {
        this.isLerping = !1
    }
    initEventListeners() {
        this.domElement.addEventListener("touchstart", this.onTouchStart.bind(this), !1),
        this.domElement.addEventListener("touchmove", this.onTouchMove.bind(this), !1),
        this.domElement.addEventListener("touchend", this.onTouchEnd.bind(this), !1),
        this.domElement.addEventListener("mousedown", this.onMouseDown.bind(this), !1),
        this.domElement.addEventListener("mousemove", this.onMouseMove.bind(this), !1),
        this.domElement.addEventListener("mouseup", this.onMouseUp.bind(this), !1),
        this.domElement.addEventListener("wheel", this.onMouseWheel.bind(this), !1),
        window.addEventListener("resize", this.onWindowResize.bind(this), !1)
    }
    onWindowResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight,
        this.camera.updateProjectionMatrix()
    }
    getScreenCoordinates(e) {
        return new Ae(e.clientX,e.clientY)
    }
    getAngle(e, t) {
        return Math.atan2(t.y - e.y, t.x - e.x)
    }
    getAngleOnScreen(e) {
        return Math.atan2(e.y, e.x)
    }
    getMidpoint(e, t) {
        return new Ae((e.x + t.x) / 2,(e.y + t.y) / 2)
    }
    screenToWorld(e, t) {
        const n = new D(e / window.innerWidth * 2 - 1,-(t / window.innerHeight) * 2 + 1,.5);
        n.unproject(this.camera);
        const i = n.sub(this.camera.position).normalize();
        if (i.y === 0)
            return new D(0,0,0);
        const s = -this.camera.position.y / i.y;
        return this.camera.position.clone().add(i.multiplyScalar(s))
    }
    handleDolly() {
        const e = this.currentPinchDistance / this.initialPinchDistance
          , t = this.screenToWorld(this.initialTouchMidpoint.x, this.initialTouchMidpoint.y)
          , n = this.screenToWorld(this.touchMidpoint.x, this.touchMidpoint.y)
          , i = t.clone().sub(this.camera.position).normalize()
          , s = this.camera.position.distanceTo(t)
          , o = (e - 1) * s;
        this.camera.position.addScaledVector(i, o);
        const a = n.x - t.x
          , c = n.z - t.z;
        this.camera.position.x -= a,
        this.camera.position.z -= c
    }
    _getPitchAngleRelativeToGround(e) {
        const t = new D;
        return e.getWorldDirection(t),
        Dt.radToDeg(-Math.asin(Dt.clamp(t.y, -1, 1)))
    }
    incrementCameraPitchDown(e, t, n, i=30, s=89) {
        let a = this._getPitchAngleRelativeToGround(e) - n;
        a = Dt.clamp(a, i, s);
        const c = Dt.degToRad(a)
          , l = new D().subVectors(e.position, t)
          , u = l.length()
          , h = l.clone();
        h.y = 0,
        h.lengthSq() < 1e-6 && h.set(1, 0, 0),
        h.normalize();
        const d = new D().crossVectors(h, new D(0,1,0)).normalize()
          , f = h.clone().applyAxisAngle(d, c).normalize().multiplyScalar(u);
        e.position.copy(t.clone().add(f)),
        e.lookAt(t),
        a < 80 ? this.In3DView = !0 : this.In3DView = !1
    }
    enter3DMode(e) {
        if (this.isTransitioning)
            return;
        this.isTransitioning = !0,
        this.transitionStartTime = performance.now(),
        this.updateWorldCenterPoint();
        const t = () => {
            this.incrementCameraPitchDown(this.camera, this.worldCenterPoint, 2),
            this._getPitchAngleRelativeToGround(this.camera) >= e ? requestAnimationFrame(t) : this.isTransitioning = !1
        }
        ;
        t(),
        this.currentMode = this.MODE_ORBIT,
        this.In3DView = !0
    }
    exit3DMode() {
        if (this.isTransitioning)
            return;
        this.isTransitioning = !0,
        this.transitionStartTime = performance.now(),
        this.updateWorldCenterPoint();
        const e = () => {
            this.incrementCameraPitchDown(this.camera, this.worldCenterPoint, -2),
            this._getPitchAngleRelativeToGround(this.camera) <= 89 ? requestAnimationFrame(e) : this.isTransitioning = !1
        }
        ;
        e(),
        this.currentMode = this.MODE_NONE,
        this.In3DView = !1
    }
    handleTwist() {
        const e = this.currentPinchAngle - this.initialPinchAngle
          , t = new lt;
        t.position.copy(this.initialPitchPivot),
        this.scene.add(t),
        t.attach(this.camera),
        t.rotation.y += e,
        this.scene.attach(this.camera),
        this.scene.remove(t)
    }
    updateWorldCenterPoint() {
        const e = new Ae(0,0);
        this.raycaster.setFromCamera(e, this.camera);
        let t = new D;
        return this.raycaster.ray.intersectPlane(this.groundPlane, t) ? this.worldCenterPoint.copy(t) : this.worldCenterPoint.set(0, 0, 0),
        this.worldCenterPoint
    }
    getMidpointInWorld(e, t) {
        const n = (e.clientX + t.clientX) / 2
          , i = (e.clientY + t.clientY) / 2
          , s = n / window.innerWidth * 2 - 1
          , o = -(i / window.innerHeight) * 2 + 1
          , a = new Ae(s,o);
        this.raycaster.setFromCamera(a, this.camera);
        let c = new D;
        return this.raycaster.ray.intersectPlane(this.groundPlane, c),
        c
    }
    handlePan(e, t, n) {
        const i = new Vr
          , s = new xn(new D(0,1,0),0)
          , o = new Ae(n.x / window.innerWidth * 2 - 1,-(n.y / window.innerHeight) * 2 + 1)
          , a = new Ae((n.x + e) / window.innerWidth * 2 - 1,-((n.y + t) / window.innerHeight) * 2 + 1);
        i.setFromCamera(o, this.camera);
        const c = new D;
        i.ray.intersectPlane(s, c),
        i.setFromCamera(a, this.camera);
        const l = new D;
        if (i.ray.intersectPlane(s, l),
        !c || !l)
            return;
        const u = new D().subVectors(c, l);
        this.camera.position.add(u)
    }
    isVectorAlmostVertical(e, t, n=10) {
        const i = new Ae().subVectors(t, e).normalize()
          , s = new Ae(0,1)
          , o = i.angleTo(s)
          , a = Dt.radToDeg(o);
        return a < n || a > 180 - n
    }
    areTouchesMovingParallel(e, t, n, i, s=.7) {
        const o = n.clone().sub(e)
          , a = i.clone().sub(t);
        return o.lengthSq() < 1e-6 || a.lengthSq() < 1e-6 ? !1 : (o.normalize(),
        a.normalize(),
        o.dot(a) > -s)
    }
    onTouchStart(e) {
        this.isNavigating = !1,
        this.stopLerp(),
        this.touchMoveFrameCount = 0,
        this.currentMode = this.MODE_NONE,
        e.touches.length === 1 ? (this.isOneFingerTouch = !0,
        this.initialOneFingerPos = this.getScreenCoordinates(e.touches[0])) : e.touches.length === 2 && (this.isTwoFingerTouch = !0,
        this.isOneFingerTouch = !1,
        this.initialOneFingerPos = null,
        this.touchPoints = [this.getScreenCoordinates(e.touches[0]), this.getScreenCoordinates(e.touches[1])],
        this.initialPinchDistance = this.touchPoints[0].distanceTo(this.touchPoints[1]),
        this.initialPinchAngle = this.getAngle(this.touchPoints[0], this.touchPoints[1]),
        this.initialTouchMidpoint = this.getMidpoint(this.touchPoints[0], this.touchPoints[1]),
        this.initialTouchPoints = [this.touchPoints[0].clone(), this.touchPoints[1].clone()],
        this.initialPitchPivot.copy(this.getMidpointInWorld(e.touches[0], e.touches[1])),
        this.updateWorldCenterPoint())
    }
    onTouchMove(e) {
        if (e.preventDefault(),
        this.isNavigating = !0,
        e.touches.length === 1 && this.isOneFingerTouch && this.initialOneFingerPos) {
            const o = this.getScreenCoordinates(e.touches[0])
              , a = o.x - this.initialOneFingerPos.x
              , c = o.y - this.initialOneFingerPos.y;
            this.handlePan(a, c, this.initialOneFingerPos),
            this.initialOneFingerPos.copy(o);
            return
        }
        if (!this.isTwoFingerTouch || e.touches.length !== 2)
            return;
        const t = this.getScreenCoordinates(e.touches[0])
          , n = this.getScreenCoordinates(e.touches[1]);
        this.currentPinchDistance = t.distanceTo(n),
        this.currentPinchAngle = this.getAngle(t, n),
        this.touchMidpoint = this.getMidpoint(t, n);
        const i = Math.abs(this.currentPinchDistance - this.initialPinchDistance)
          , s = Math.abs(this.currentPinchAngle - this.initialPinchAngle);
        if (this.initialTouchMidpoint.distanceTo(this.touchMidpoint),
        this.currentMode === this.MODE_NONE && (i > this.DISTANCE_THRESHOLD ? this.currentMode = this.MODE_DOLLY : s > this.ANGLE_THRESHOLD && (this.currentMode = this.MODE_TWIST)),
        this.currentMode !== this.MODE_3D && (this.handleDolly(),
        this.handleTwist()),
        this.initialPinchDistance = this.currentPinchDistance,
        this.initialPinchAngle = this.currentPinchAngle,
        this.initialTouchMidpoint.copy(this.touchMidpoint),
        this.initialTouchPoints[0].copy(t),
        this.initialTouchPoints[1].copy(n),
        e.touches.length === 1 && this.previousTouchCount === 2) {
            const o = this.getScreenCoordinates(e.touches[0]);
            this.initialOneFingerPos.copy(o),
            this.isOneFingerTouch = !0
        }
        this.previousTouchCount = e.touches.length
    }
    onTouchEnd(e) {
        e.touches.length === 0 ? (this.isTwoFingerTouch = !1,
        this.isOneFingerTouch = !1,
        this.currentMode = this.MODE_NONE,
        this.touchPoints = [],
        this.initialPinchDistance = 0,
        this.initialPinchAngle = 0,
        this.currentPinchDistance = 0,
        this.currentPinchAngle = 0,
        this.initialTouchMidpoint = new Ae,
        this.initialTouchPoints = [],
        this.initialOneFingerPos = null) : e.touches.length === 1 && (this.isTwoFingerTouch = !1,
        this.isOneFingerTouch = !0,
        this.initialOneFingerPos = this.getScreenCoordinates(e.touches[0]),
        this.currentMode = this.MODE_NONE,
        this.initialPinchDistance = 0,
        this.initialPinchAngle = 0,
        this.currentPinchDistance = 0,
        this.currentPinchAngle = 0,
        this.initialTouchMidpoint = new Ae,
        this.initialTouchPoints = [])
    }
    onMouseDown(e) {
        e.preventDefault(),
        this.isNavigating = !1,
        e.button === 0 && (this.stopLerp(),
        this.initialMousePos = this.getScreenCoordinates(e),
        this.updateWorldCenterPoint(),
        e.ctrlKey ? (this.isCtrlLeftMouseDown = !0,
        this.currentMode = this.MODE_ORBIT,
        this.orbitPoint.copy(this.worldCenterPoint)) : (this.isLeftMouseDown = !0,
        this.currentMode = this.MODE_PAN))
    }
    onMouseMove(e) {
        e.preventDefault();
        const t = 3;
        if (this.isLeftMouseDown && this.currentMode === this.MODE_PAN) {
            const n = this.getScreenCoordinates(e)
              , i = n.x - this.initialMousePos.x
              , s = n.y - this.initialMousePos.y;
            this.handlePan(i, s, this.initialMousePos),
            this.initialMousePos.copy(n);
            const o = Math.sqrt(i * i + s * s);
            if (!this.isNavigating && o < t)
                return;
            this.isNavigating = !0
        } else if (this.isCtrlLeftMouseDown && this.currentMode === this.MODE_ORBIT) {
            const n = this.getScreenCoordinates(e)
              , i = n.x - this.initialMousePos.x
              , s = n.y - this.initialMousePos.y
              , o = -i * this.ORBIT_SENSITIVITY
              , a = new D().subVectors(this.camera.position, this.orbitPoint);
            a.applyAxisAngle(new D(0,1,0), o),
            this.camera.position.copy(this.orbitPoint).add(a);
            const c = -s * this.ORBIT_SENSITIVITY;
            this.incrementCameraPitchDown(this.camera, this.orbitPoint, Dt.radToDeg(c)),
            this.camera.lookAt(this.orbitPoint),
            this.initialMousePos.copy(n);
            const l = Math.sqrt(i * i + s * s);
            if (!this.isNavigating && l < t)
                return;
            this.isNavigating = !0
        }
    }
    onMouseUp(e) {
        e.preventDefault(),
        this.isLeftMouseDown = !1,
        this.isCtrlLeftMouseDown = !1,
        this.currentMode = this.MODE_NONE,
        this.initialMousePos = null
    }
    onMouseWheel(e) {
        e.preventDefault();
        const t = this.domElement.getBoundingClientRect()
          , n = new Ae;
        n.x = (e.clientX - t.left) / t.width * 2 - 1,
        n.y = -((e.clientY - t.top) / t.height) * 2 + 1,
        this.raycaster.setFromCamera(n, this.camera);
        const i = new D;
        if (!this.raycaster.ray.intersectPlane(this.groundPlane, i))
            return;
        const o = i.clone().sub(this.camera.position).normalize()
          , a = e.deltaY * .002;
        this.camera.position.addScaledVector(o, -a * this.camera.position.distanceTo(i))
    }
    getIntersectionWithGroundPlane(e, t) {
        const n = new Ae;
        n.x = e / window.innerWidth * 2 - 1,
        n.y = -(t / window.innerHeight) * 2 + 1,
        this.raycaster.setFromCamera(n, this.camera);
        let i = new D;
        return this.raycaster.ray.intersectPlane(this.groundPlane, i) ? i : null
    }
}
class q0 {
    constructor() {
        this.isTransitioning = !1
    }
    goToPlot(e) {
        if (e) {
            const t = new xt().setFromObject(e)
              , n = t.getCenter(new D)
              , i = t.getSize(new D)
              , s = Math.max(i.x, i.y, i.z)
              , o = this.camera.fov * (Math.PI / 180);
            let a = s / (2 * Math.tan(o / 2));
            a *= 2.5;
            const c = new D;
            this.camera.getWorldDirection(c),
            c.negate();
            const l = new D().addVectors(n, c.multiplyScalar(a));
            this.startTransition(l, 1)
        }
    }
    orientCameraToNorth() {
        var e;
        this.controls.isTransitioning || this.controls.lerpCameraOrientToNorth(((e = Ie.ProjectData) == null ? void 0 : e.northOffset) * -1)
    }
    goToHome(e) {
        this.controls.isTransitioning || (this.controls.lerpCameraToHome(e.position),
        this.controls.exit3DMode())
    }
    startTransition(e, t) {
        const n = performance.now()
          , i = t;
        let s = this.camera.position.clone();
        s.copy(this.camera.position);
        const o = e.clone();
        this.isTransitioning = !0;
        const a = () => {
            if (this.controls.updateLerp(),
            this.isTransitioning) {
                const c = (performance.now() - n) / 1e3
                  , l = Math.min(c / i, 1)
                  , u = l * l * (3 - 2 * l);
                this.camera.position.lerpVectors(s, o, u),
                this.camera.updateProjectionMatrix(),
                l >= 1 ? this.isTransitioning = !1 : requestAnimationFrame(a)
            }
        }
        ;
        a()
    }
    initializeCamera(e, t) {
        this.camera = new Bt(75,e.clientWidth / e.clientHeight,.1,1e3),
        t.add(this.camera)
    }
    updateCameraConfig(e, t=2) {
        const n = new xt().setFromObject(e)
          , i = n.getSize(new D)
          , s = n.getCenter(new D)
          , o = Math.max(i.x, i.y, i.z)
          , a = this.camera.fov * (Math.PI / 180);
        let c = o / 2 / Math.tan(a / 2);
        c *= t,
        this.camera.far = c * 100,
        this.camera.lookAt(s),
        this.camera.updateProjectionMatrix()
    }
    initializeControls(e, t) {
        this.controls = new Y0(this.camera,t.domElement,e)
    }
    setInitialCameraPosition(e) {
        const n = new xt().setFromObject(e).getCenter(new D);
        this.initialCameraPosition = new D(n.x,n.y + 1e3,n.z),
        this.camera.position.set(this.initialCameraPosition.x, this.initialCameraPosition.y, this.initialCameraPosition.z),
        this.camera.lookAt(n),
        this.camera.updateProjectionMatrix()
    }
    renderCamera(e) {
        this.renderer.render(e, this.camera)
    }
}
const _n = ( () => {
    let e = 0;
    function t(s, o) {
        return {
            type: o,
            message: (s == null ? void 0 : s.message) || String(s),
            name: (s == null ? void 0 : s.name) || "Error",
            stack: (s == null ? void 0 : s.stack) || new Error().stack,
            url: window.location.href,
            path: window.location.pathname,
            userAgent: navigator.userAgent,
            timestamp: new Date().toISOString()
        }
    }
    function n(s, o) {
        var c;
        if (e >= 5) {
            e === 5 && (console.warn("Mixpanel error tracking throttled for this session."),
            e++);
            return
        }
        const a = t(o, s);
        console.error(`[${s}]`, a),
        (c = window.mixpanel) == null || c.track("Spacer Error", a),
        e++
    }
    function i() {
        window.addEventListener("unhandledrejection", s => {
            n("unhandledrejection", s.reason)
        }
        ),
        window.addEventListener("error", s => {
            n("error", s.error || s)
        }
        )
    }
    return {
        initGlobalListeners: i,
        trackError: n
    }
}
)();
class Z0 {
    constructor() {
        this.imageUrls = null
    }
    async getProjectData(e) {
        var t;
        try {
            const n = new URL((t = Ie.spacerApp) == null ? void 0 : t.Urls.getProjectData);
            n.searchParams.append("pid", e);
            const i = await fetch(n.toString());
            if (!i.ok)
                throw new Error(`HTTP error! status: ${i.status}`);
            const s = await i.json();
            if (this.statuses = s.value.statuses,
            s.type === "success") {
                const o = {
                    projectName: s.value.projectName,
                    projectDescription: s.value.projectDescription,
                    googleMapLocation: s.value.googleMapLocation,
                    northOffset: parseInt(s.value.northOffset),
                    areaUnit: s.value.areaUnit,
                    cameraHomePosition: {
                        position: new D(s.value.cameraHomePosition.x,s.value.cameraHomePosition.y,s.value.cameraHomePosition.z)
                    },
                    socialMediaLinks: s.value.socialMediaLinks,
                    totalArea: s.value.totalArea,
                    statusKey: s.value.statusKey,
                    boundaryThickness: s.value.boundaryThickness ? s.value.boundaryThickness : .01,
                    plotNumberTextHeight: s.value.plotNumberTextHeight ? s.value.plotNumberTextHeight : .025,
                    latitude: s.value.latitude,
                    longitude: s.value.longitude,
                    mapOverlayBounds: s.value.mapOverlayBounds,
                    mapOverlayZoom: s.value.mapOverlayZoom ? s.value.mapOverlayZoom : 18,
                    links: s.value.links,
                    r2_links: s.value.r2_links,
                    plotsData: s.value.plotsData,
                    showWatermark: s.value.showWatermark,
                    primaryAreaUnits: s.value.primaryAreaUnits,
                    lengthUnits: s.value.lengthUnits
                };
                return o.showGetYourSpacerAd = !1,
                "secondaryAreaUnits"in s.value && (o.secondaryAreaUnits = s.value.secondaryAreaUnits),
                o.socialMediaLinks && o.socialMediaLinks.inquiryNumber && (o.inquiryNumber = o.socialMediaLinks.inquiryNumber),
                o
            } else
                _n.trackError("cloud-function-getProjectData", s.message)
        } catch (n) {
            _n.trackError("getProjectData", n)
        }
    }
    async getPlotsData(e, t) {
        var n;
        try {
            const i = new URL((n = Ie.spacerApp) == null ? void 0 : n.Urls.getPlotData);
            i.searchParams.append("pid", e),
            t && i.searchParams.append("status", t);
            const s = await fetch(i.toString());
            if (!s.ok)
                throw new Error(`HTTP error! status: ${s.status}`);
            const o = await s.json();
            return Object.values(o.value).map(l => ({
                name: l.name,
                sqMeter: this.projectData.areaUnit === "sqMt" ? l.area : Math.round(l.area * .836127 * 100) / 100,
                sqYard: this.projectData.areaUnit === "sqYard" ? l.area : Math.round(l.area * 1.19599 * 100) / 100,
                statusId: l.status ?? -1,
                annotationVisible: !1,
                pos: l.position ? new D(l.position.x,0,l.position.z) : null,
                rotation: l.rotation ? parseFloat(l.rotation) : null,
                scale: l.scale ? new D(l.scale.x,1,l.scale.z) : null,
                label: l.label ? l.label : ""
            }))
        } catch (i) {
            _n.trackError("getPlotsData", i)
        }
    }
}
const K0 = "modulepreload"
  , Q0 = function(r) {
    return "/" + r
}
  , cu = {}
  , J0 = function(e, t, n) {
    let i = Promise.resolve();
    if (t && t.length > 0) {
        let o = function(l) {
            return Promise.all(l.map(u => Promise.resolve(u).then(h => ({
                status: "fulfilled",
                value: h
            }), h => ({
                status: "rejected",
                reason: h
            }))))
        };
        document.getElementsByTagName("link");
        const a = document.querySelector("meta[property=csp-nonce]")
          , c = (a == null ? void 0 : a.nonce) || (a == null ? void 0 : a.getAttribute("nonce"));
        i = o(t.map(l => {
            if (l = Q0(l),
            l in cu)
                return;
            cu[l] = !0;
            const u = l.endsWith(".css")
              , h = u ? '[rel="stylesheet"]' : "";
            if (document.querySelector(`link[href="${l}"]${h}`))
                return;
            const d = document.createElement("link");
            if (d.rel = u ? "stylesheet" : K0,
            u || (d.as = "script"),
            d.crossOrigin = "",
            d.href = l,
            c && d.setAttribute("nonce", c),
            document.head.appendChild(d),
            u)
                return new Promise( (f, m) => {
                    d.addEventListener("load", f),
                    d.addEventListener("error", () => m(new Error(`Unable to preload CSS for ${l}`)))
                }
                )
        }
        ))
    }
    function s(o) {
        const a = new Event("vite:preloadError",{
            cancelable: !0
        });
        if (a.payload = o,
        window.dispatchEvent(a),
        !a.defaultPrevented)
            throw o
    }
    return i.then(o => {
        for (const a of o || [])
            a.status === "rejected" && s(a.reason);
        return e().catch(s)
    }
    )
};
/*!
  * PhotoSwipe Lightbox 5.4.4 - https://photoswipe.com
  * (c) 2024 Dmytro Semenov
  */
function xs(r, e, t) {
    const n = document.createElement(e);
    return r && (n.className = r),
    t && t.appendChild(n),
    n
}
function $0(r, e, t) {
    let n = `translate3d(${r}px,0px,0)`;
    return t !== void 0 && (n += ` scale3d(${t},${t},1)`),
    n
}
function Va(r, e, t) {
    r.style.width = typeof e == "number" ? `${e}px` : e,
    r.style.height = typeof t == "number" ? `${t}px` : t
}
const Qt = {
    IDLE: "idle",
    LOADING: "loading",
    LOADED: "loaded",
    ERROR: "error"
};
function ex(r) {
    return "button"in r && r.button === 1 || r.ctrlKey || r.metaKey || r.altKey || r.shiftKey
}
function ys(r, e, t=document) {
    let n = [];
    if (r instanceof Element)
        n = [r];
    else if (r instanceof NodeList || Array.isArray(r))
        n = Array.from(r);
    else {
        const i = typeof r == "string" ? r : e;
        i && (n = Array.from(t.querySelectorAll(i)))
    }
    return n
}
function tx(r) {
    return typeof r == "function" && r.prototype && r.prototype.goTo
}
function lu() {
    return !!(navigator.vendor && navigator.vendor.match(/apple/i))
}
class nx {
    constructor(e, t) {
        this.type = e,
        this.defaultPrevented = !1,
        t && Object.assign(this, t)
    }
    preventDefault() {
        this.defaultPrevented = !0
    }
}
class ix {
    constructor() {
        this._listeners = {},
        this._filters = {},
        this.pswp = void 0,
        this.options = void 0
    }
    addFilter(e, t, n=100) {
        var i, s, o;
        this._filters[e] || (this._filters[e] = []),
        (i = this._filters[e]) === null || i === void 0 || i.push({
            fn: t,
            priority: n
        }),
        (s = this._filters[e]) === null || s === void 0 || s.sort( (a, c) => a.priority - c.priority),
        (o = this.pswp) === null || o === void 0 || o.addFilter(e, t, n)
    }
    removeFilter(e, t) {
        this._filters[e] && (this._filters[e] = this._filters[e].filter(n => n.fn !== t)),
        this.pswp && this.pswp.removeFilter(e, t)
    }
    applyFilters(e, ...t) {
        var n;
        return (n = this._filters[e]) === null || n === void 0 || n.forEach(i => {
            t[0] = i.fn.apply(this, t)
        }
        ),
        t[0]
    }
    on(e, t) {
        var n, i;
        this._listeners[e] || (this._listeners[e] = []),
        (n = this._listeners[e]) === null || n === void 0 || n.push(t),
        (i = this.pswp) === null || i === void 0 || i.on(e, t)
    }
    off(e, t) {
        var n;
        this._listeners[e] && (this._listeners[e] = this._listeners[e].filter(i => t !== i)),
        (n = this.pswp) === null || n === void 0 || n.off(e, t)
    }
    dispatch(e, t) {
        var n;
        if (this.pswp)
            return this.pswp.dispatch(e, t);
        const i = new nx(e,t);
        return (n = this._listeners[e]) === null || n === void 0 || n.forEach(s => {
            s.call(this, i)
        }
        ),
        i
    }
}
class sx {
    constructor(e, t) {
        if (this.element = xs("pswp__img pswp__img--placeholder", e ? "img" : "div", t),
        e) {
            const n = this.element;
            n.decoding = "async",
            n.alt = "",
            n.src = e,
            n.setAttribute("role", "presentation")
        }
        this.element.setAttribute("aria-hidden", "true")
    }
    setDisplayedSize(e, t) {
        this.element && (this.element.tagName === "IMG" ? (Va(this.element, 250, "auto"),
        this.element.style.transformOrigin = "0 0",
        this.element.style.transform = $0(0, 0, e / 250)) : Va(this.element, e, t))
    }
    destroy() {
        var e;
        (e = this.element) !== null && e !== void 0 && e.parentNode && this.element.remove(),
        this.element = null
    }
}
class rx {
    constructor(e, t, n) {
        this.instance = t,
        this.data = e,
        this.index = n,
        this.element = void 0,
        this.placeholder = void 0,
        this.slide = void 0,
        this.displayedImageWidth = 0,
        this.displayedImageHeight = 0,
        this.width = Number(this.data.w) || Number(this.data.width) || 0,
        this.height = Number(this.data.h) || Number(this.data.height) || 0,
        this.isAttached = !1,
        this.hasSlide = !1,
        this.isDecoding = !1,
        this.state = Qt.IDLE,
        this.data.type ? this.type = this.data.type : this.data.src ? this.type = "image" : this.type = "html",
        this.instance.dispatch("contentInit", {
            content: this
        })
    }
    removePlaceholder() {
        this.placeholder && !this.keepPlaceholder() && setTimeout( () => {
            this.placeholder && (this.placeholder.destroy(),
            this.placeholder = void 0)
        }
        , 1e3)
    }
    load(e, t) {
        if (this.slide && this.usePlaceholder())
            if (this.placeholder) {
                const n = this.placeholder.element;
                n && !n.parentElement && this.slide.container.prepend(n)
            } else {
                const n = this.instance.applyFilters("placeholderSrc", this.data.msrc && this.slide.isFirstSlide ? this.data.msrc : !1, this);
                this.placeholder = new sx(n,this.slide.container)
            }
        this.element && !t || this.instance.dispatch("contentLoad", {
            content: this,
            isLazy: e
        }).defaultPrevented || (this.isImageContent() ? (this.element = xs("pswp__img", "img"),
        this.displayedImageWidth && this.loadImage(e)) : (this.element = xs("pswp__content", "div"),
        this.element.innerHTML = this.data.html || ""),
        t && this.slide && this.slide.updateContentSize(!0))
    }
    loadImage(e) {
        var t, n;
        if (!this.isImageContent() || !this.element || this.instance.dispatch("contentLoadImage", {
            content: this,
            isLazy: e
        }).defaultPrevented)
            return;
        const i = this.element;
        this.updateSrcsetSizes(),
        this.data.srcset && (i.srcset = this.data.srcset),
        i.src = (t = this.data.src) !== null && t !== void 0 ? t : "",
        i.alt = (n = this.data.alt) !== null && n !== void 0 ? n : "",
        this.state = Qt.LOADING,
        i.complete ? this.onLoaded() : (i.onload = () => {
            this.onLoaded()
        }
        ,
        i.onerror = () => {
            this.onError()
        }
        )
    }
    setSlide(e) {
        this.slide = e,
        this.hasSlide = !0,
        this.instance = e.pswp
    }
    onLoaded() {
        this.state = Qt.LOADED,
        this.slide && this.element && (this.instance.dispatch("loadComplete", {
            slide: this.slide,
            content: this
        }),
        this.slide.isActive && this.slide.heavyAppended && !this.element.parentNode && (this.append(),
        this.slide.updateContentSize(!0)),
        (this.state === Qt.LOADED || this.state === Qt.ERROR) && this.removePlaceholder())
    }
    onError() {
        this.state = Qt.ERROR,
        this.slide && (this.displayError(),
        this.instance.dispatch("loadComplete", {
            slide: this.slide,
            isError: !0,
            content: this
        }),
        this.instance.dispatch("loadError", {
            slide: this.slide,
            content: this
        }))
    }
    isLoading() {
        return this.instance.applyFilters("isContentLoading", this.state === Qt.LOADING, this)
    }
    isError() {
        return this.state === Qt.ERROR
    }
    isImageContent() {
        return this.type === "image"
    }
    setDisplayedSize(e, t) {
        if (this.element && (this.placeholder && this.placeholder.setDisplayedSize(e, t),
        !this.instance.dispatch("contentResize", {
            content: this,
            width: e,
            height: t
        }).defaultPrevented && (Va(this.element, e, t),
        this.isImageContent() && !this.isError()))) {
            const n = !this.displayedImageWidth && e;
            this.displayedImageWidth = e,
            this.displayedImageHeight = t,
            n ? this.loadImage(!1) : this.updateSrcsetSizes(),
            this.slide && this.instance.dispatch("imageSizeChange", {
                slide: this.slide,
                width: e,
                height: t,
                content: this
            })
        }
    }
    isZoomable() {
        return this.instance.applyFilters("isContentZoomable", this.isImageContent() && this.state !== Qt.ERROR, this)
    }
    updateSrcsetSizes() {
        if (!this.isImageContent() || !this.element || !this.data.srcset)
            return;
        const e = this.element
          , t = this.instance.applyFilters("srcsetSizesWidth", this.displayedImageWidth, this);
        (!e.dataset.largestUsedSize || t > parseInt(e.dataset.largestUsedSize, 10)) && (e.sizes = t + "px",
        e.dataset.largestUsedSize = String(t))
    }
    usePlaceholder() {
        return this.instance.applyFilters("useContentPlaceholder", this.isImageContent(), this)
    }
    lazyLoad() {
        this.instance.dispatch("contentLazyLoad", {
            content: this
        }).defaultPrevented || this.load(!0)
    }
    keepPlaceholder() {
        return this.instance.applyFilters("isKeepingPlaceholder", this.isLoading(), this)
    }
    destroy() {
        this.hasSlide = !1,
        this.slide = void 0,
        !this.instance.dispatch("contentDestroy", {
            content: this
        }).defaultPrevented && (this.remove(),
        this.placeholder && (this.placeholder.destroy(),
        this.placeholder = void 0),
        this.isImageContent() && this.element && (this.element.onload = null,
        this.element.onerror = null,
        this.element = void 0))
    }
    displayError() {
        if (this.slide) {
            var e, t;
            let n = xs("pswp__error-msg", "div");
            n.innerText = (e = (t = this.instance.options) === null || t === void 0 ? void 0 : t.errorMsg) !== null && e !== void 0 ? e : "",
            n = this.instance.applyFilters("contentErrorElement", n, this),
            this.element = xs("pswp__content pswp__error-msg-container", "div"),
            this.element.appendChild(n),
            this.slide.container.innerText = "",
            this.slide.container.appendChild(this.element),
            this.slide.updateContentSize(!0),
            this.removePlaceholder()
        }
    }
    append() {
        if (this.isAttached || !this.element)
            return;
        if (this.isAttached = !0,
        this.state === Qt.ERROR) {
            this.displayError();
            return
        }
        if (this.instance.dispatch("contentAppend", {
            content: this
        }).defaultPrevented)
            return;
        const e = "decode"in this.element;
        this.isImageContent() ? e && this.slide && (!this.slide.isActive || lu()) ? (this.isDecoding = !0,
        this.element.decode().catch( () => {}
        ).finally( () => {
            this.isDecoding = !1,
            this.appendImage()
        }
        )) : this.appendImage() : this.slide && !this.element.parentNode && this.slide.container.appendChild(this.element)
    }
    activate() {
        this.instance.dispatch("contentActivate", {
            content: this
        }).defaultPrevented || !this.slide || (this.isImageContent() && this.isDecoding && !lu() ? this.appendImage() : this.isError() && this.load(!1, !0),
        this.slide.holderElement && this.slide.holderElement.setAttribute("aria-hidden", "false"))
    }
    deactivate() {
        this.instance.dispatch("contentDeactivate", {
            content: this
        }),
        this.slide && this.slide.holderElement && this.slide.holderElement.setAttribute("aria-hidden", "true")
    }
    remove() {
        this.isAttached = !1,
        !this.instance.dispatch("contentRemove", {
            content: this
        }).defaultPrevented && (this.element && this.element.parentNode && this.element.remove(),
        this.placeholder && this.placeholder.element && this.placeholder.element.remove())
    }
    appendImage() {
        this.isAttached && (this.instance.dispatch("contentAppendImage", {
            content: this
        }).defaultPrevented || (this.slide && this.element && !this.element.parentNode && this.slide.container.appendChild(this.element),
        (this.state === Qt.LOADED || this.state === Qt.ERROR) && this.removePlaceholder()))
    }
}
function ox(r, e) {
    if (r.getViewportSizeFn) {
        const t = r.getViewportSizeFn(r, e);
        if (t)
            return t
    }
    return {
        x: document.documentElement.clientWidth,
        y: window.innerHeight
    }
}
function Lr(r, e, t, n, i) {
    let s = 0;
    if (e.paddingFn)
        s = e.paddingFn(t, n, i)[r];
    else if (e.padding)
        s = e.padding[r];
    else {
        const o = "padding" + r[0].toUpperCase() + r.slice(1);
        e[o] && (s = e[o])
    }
    return Number(s) || 0
}
function ax(r, e, t, n) {
    return {
        x: e.x - Lr("left", r, e, t, n) - Lr("right", r, e, t, n),
        y: e.y - Lr("top", r, e, t, n) - Lr("bottom", r, e, t, n)
    }
}
const uu = 4e3;
class cx {
    constructor(e, t, n, i) {
        this.pswp = i,
        this.options = e,
        this.itemData = t,
        this.index = n,
        this.panAreaSize = null,
        this.elementSize = null,
        this.fit = 1,
        this.fill = 1,
        this.vFill = 1,
        this.initial = 1,
        this.secondary = 1,
        this.max = 1,
        this.min = 1
    }
    update(e, t, n) {
        const i = {
            x: e,
            y: t
        };
        this.elementSize = i,
        this.panAreaSize = n;
        const s = n.x / i.x
          , o = n.y / i.y;
        this.fit = Math.min(1, s < o ? s : o),
        this.fill = Math.min(1, s > o ? s : o),
        this.vFill = Math.min(1, o),
        this.initial = this._getInitial(),
        this.secondary = this._getSecondary(),
        this.max = Math.max(this.initial, this.secondary, this._getMax()),
        this.min = Math.min(this.fit, this.initial, this.secondary),
        this.pswp && this.pswp.dispatch("zoomLevelsUpdate", {
            zoomLevels: this,
            slideData: this.itemData
        })
    }
    _parseZoomLevelOption(e) {
        const t = e + "ZoomLevel"
          , n = this.options[t];
        if (n)
            return typeof n == "function" ? n(this) : n === "fill" ? this.fill : n === "fit" ? this.fit : Number(n)
    }
    _getSecondary() {
        let e = this._parseZoomLevelOption("secondary");
        return e || (e = Math.min(1, this.fit * 3),
        this.elementSize && e * this.elementSize.x > uu && (e = uu / this.elementSize.x),
        e)
    }
    _getInitial() {
        return this._parseZoomLevelOption("initial") || this.fit
    }
    _getMax() {
        return this._parseZoomLevelOption("max") || Math.max(1, this.fit * 4)
    }
}
function oh(r, e, t) {
    const n = e.createContentFromData(r, t);
    let i;
    const {options: s} = e;
    if (s) {
        i = new cx(s,r,-1);
        let o;
        e.pswp ? o = e.pswp.viewportSize : o = ox(s, e);
        const a = ax(s, o, r, t);
        i.update(n.width, n.height, a)
    }
    return n.lazyLoad(),
    i && n.setDisplayedSize(Math.ceil(n.width * i.initial), Math.ceil(n.height * i.initial)),
    n
}
function lx(r, e) {
    const t = e.getItemData(r);
    if (!e.dispatch("lazyLoadSlide", {
        index: r,
        itemData: t
    }).defaultPrevented)
        return oh(t, e, r)
}
class ux extends ix {
    getNumItems() {
        var e;
        let t = 0;
        const n = (e = this.options) === null || e === void 0 ? void 0 : e.dataSource;
        n && "length"in n ? t = n.length : n && "gallery"in n && (n.items || (n.items = this._getGalleryDOMElements(n.gallery)),
        n.items && (t = n.items.length));
        const i = this.dispatch("numItems", {
            dataSource: n,
            numItems: t
        });
        return this.applyFilters("numItems", i.numItems, n)
    }
    createContentFromData(e, t) {
        return new rx(e,this,t)
    }
    getItemData(e) {
        var t;
        const n = (t = this.options) === null || t === void 0 ? void 0 : t.dataSource;
        let i = {};
        Array.isArray(n) ? i = n[e] : n && "gallery"in n && (n.items || (n.items = this._getGalleryDOMElements(n.gallery)),
        i = n.items[e]);
        let s = i;
        s instanceof Element && (s = this._domElementToItemData(s));
        const o = this.dispatch("itemData", {
            itemData: s || {},
            index: e
        });
        return this.applyFilters("itemData", o.itemData, e)
    }
    _getGalleryDOMElements(e) {
        var t, n;
        return (t = this.options) !== null && t !== void 0 && t.children || (n = this.options) !== null && n !== void 0 && n.childSelector ? ys(this.options.children, this.options.childSelector, e) || [] : [e]
    }
    _domElementToItemData(e) {
        const t = {
            element: e
        }
          , n = e.tagName === "A" ? e : e.querySelector("a");
        if (n) {
            t.src = n.dataset.pswpSrc || n.href,
            n.dataset.pswpSrcset && (t.srcset = n.dataset.pswpSrcset),
            t.width = n.dataset.pswpWidth ? parseInt(n.dataset.pswpWidth, 10) : 0,
            t.height = n.dataset.pswpHeight ? parseInt(n.dataset.pswpHeight, 10) : 0,
            t.w = t.width,
            t.h = t.height,
            n.dataset.pswpType && (t.type = n.dataset.pswpType);
            const s = e.querySelector("img");
            if (s) {
                var i;
                t.msrc = s.currentSrc || s.src,
                t.alt = (i = s.getAttribute("alt")) !== null && i !== void 0 ? i : ""
            }
            (n.dataset.pswpCropped || n.dataset.cropped) && (t.thumbCropped = !0)
        }
        return this.applyFilters("domItemData", t, e, n)
    }
    lazyLoadData(e, t) {
        return oh(e, this, t)
    }
}
class hx extends ux {
    constructor(e) {
        super(),
        this.options = e || {},
        this._uid = 0,
        this.shouldOpen = !1,
        this._preloadedContent = void 0,
        this.onThumbnailsClick = this.onThumbnailsClick.bind(this)
    }
    init() {
        ys(this.options.gallery, this.options.gallerySelector).forEach(e => {
            e.addEventListener("click", this.onThumbnailsClick, !1)
        }
        )
    }
    onThumbnailsClick(e) {
        if (ex(e) || window.pswp)
            return;
        let t = {
            x: e.clientX,
            y: e.clientY
        };
        !t.x && !t.y && (t = null);
        let n = this.getClickedIndex(e);
        n = this.applyFilters("clickedIndex", n, e, this);
        const i = {
            gallery: e.currentTarget
        };
        n >= 0 && (e.preventDefault(),
        this.loadAndOpen(n, i, t))
    }
    getClickedIndex(e) {
        if (this.options.getClickedIndexFn)
            return this.options.getClickedIndexFn.call(this, e);
        const t = e.target
          , i = ys(this.options.children, this.options.childSelector, e.currentTarget).findIndex(s => s === t || s.contains(t));
        return i !== -1 ? i : this.options.children || this.options.childSelector ? -1 : 0
    }
    loadAndOpen(e, t, n) {
        if (window.pswp || !this.options)
            return !1;
        if (!t && this.options.gallery && this.options.children) {
            const i = ys(this.options.gallery);
            i[0] && (t = {
                gallery: i[0]
            })
        }
        return this.options.index = e,
        this.options.initialPointerPos = n,
        this.shouldOpen = !0,
        this.preload(e, t),
        !0
    }
    preload(e, t) {
        const {options: n} = this;
        t && (n.dataSource = t);
        const i = []
          , s = typeof n.pswpModule;
        if (tx(n.pswpModule))
            i.push(Promise.resolve(n.pswpModule));
        else {
            if (s === "string")
                throw new Error("pswpModule as string is no longer supported");
            if (s === "function")
                i.push(n.pswpModule());
            else
                throw new Error("pswpModule is not valid")
        }
        typeof n.openPromise == "function" && i.push(n.openPromise()),
        n.preloadFirstSlide !== !1 && e >= 0 && (this._preloadedContent = lx(e, this));
        const o = ++this._uid;
        Promise.all(i).then(a => {
            if (this.shouldOpen) {
                const c = a[0];
                this._openPhotoswipe(c, o)
            }
        }
        )
    }
    _openPhotoswipe(e, t) {
        if (t !== this._uid && this.shouldOpen || (this.shouldOpen = !1,
        window.pswp))
            return;
        const n = typeof e == "object" ? new e.default(this.options) : new e(this.options);
        this.pswp = n,
        window.pswp = n,
        Object.keys(this._listeners).forEach(i => {
            var s;
            (s = this._listeners[i]) === null || s === void 0 || s.forEach(o => {
                n.on(i, o)
            }
            )
        }
        ),
        Object.keys(this._filters).forEach(i => {
            var s;
            (s = this._filters[i]) === null || s === void 0 || s.forEach(o => {
                n.addFilter(i, o.fn, o.priority)
            }
            )
        }
        ),
        this._preloadedContent && (n.contentLoader.addToCache(this._preloadedContent),
        this._preloadedContent = void 0),
        n.on("destroy", () => {
            this.pswp = void 0,
            delete window.pswp
        }
        ),
        n.init()
    }
    destroy() {
        var e;
        (e = this.pswp) === null || e === void 0 || e.destroy(),
        this.shouldOpen = !1,
        this._listeners = {},
        ys(this.options.gallery, this.options.gallerySelector).forEach(t => {
            t.removeEventListener("click", this.onThumbnailsClick, !1)
        }
        )
    }
}
function ah(r) {
    return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r
}
var Ur = {
    exports: {}
}, dx = Ur.exports, hu;
function fx() {
    return hu || (hu = 1,
    function(r, e) {
        (function(t, n) {
            r.exports = n()
        }
        )(dx, () => ( () => {
            var t = {
                873: (o, a) => {
                    var c, l, u = function() {
                        var h = function(U, F) {
                            var O = U
                              , y = p[F]
                              , v = null
                              , L = 0
                              , R = null
                              , C = []
                              , Y = {}
                              , ue = function(G, K) {
                                v = function(x) {
                                    for (var V = new Array(x), W = 0; W < x; W += 1) {
                                        V[W] = new Array(x);
                                        for (var oe = 0; oe < x; oe += 1)
                                            V[W][oe] = null
                                    }
                                    return V
                                }(L = 4 * O + 17),
                                X(0, 0),
                                X(L - 7, 0),
                                X(0, L - 7),
                                ae(),
                                ne(),
                                le(G, K),
                                O >= 7 && ce(G),
                                R == null && (R = ye(O, y, C)),
                                xe(R, K)
                            }
                              , X = function(G, K) {
                                for (var x = -1; x <= 7; x += 1)
                                    if (!(G + x <= -1 || L <= G + x))
                                        for (var V = -1; V <= 7; V += 1)
                                            K + V <= -1 || L <= K + V || (v[G + x][K + V] = 0 <= x && x <= 6 && (V == 0 || V == 6) || 0 <= V && V <= 6 && (x == 0 || x == 6) || 2 <= x && x <= 4 && 2 <= V && V <= 4)
                            }
                              , ne = function() {
                                for (var G = 8; G < L - 8; G += 1)
                                    v[G][6] == null && (v[G][6] = G % 2 == 0);
                                for (var K = 8; K < L - 8; K += 1)
                                    v[6][K] == null && (v[6][K] = K % 2 == 0)
                            }
                              , ae = function() {
                                for (var G = S.getPatternPosition(O), K = 0; K < G.length; K += 1)
                                    for (var x = 0; x < G.length; x += 1) {
                                        var V = G[K]
                                          , W = G[x];
                                        if (v[V][W] == null)
                                            for (var oe = -2; oe <= 2; oe += 1)
                                                for (var $ = -2; $ <= 2; $ += 1)
                                                    v[V + oe][W + $] = oe == -2 || oe == 2 || $ == -2 || $ == 2 || oe == 0 && $ == 0
                                    }
                            }
                              , ce = function(G) {
                                for (var K = S.getBCHTypeNumber(O), x = 0; x < 18; x += 1) {
                                    var V = !G && (K >> x & 1) == 1;
                                    v[Math.floor(x / 3)][x % 3 + L - 8 - 3] = V
                                }
                                for (x = 0; x < 18; x += 1)
                                    V = !G && (K >> x & 1) == 1,
                                    v[x % 3 + L - 8 - 3][Math.floor(x / 3)] = V
                            }
                              , le = function(G, K) {
                                for (var x = y << 3 | K, V = S.getBCHTypeInfo(x), W = 0; W < 15; W += 1) {
                                    var oe = !G && (V >> W & 1) == 1;
                                    W < 6 ? v[W][8] = oe : W < 8 ? v[W + 1][8] = oe : v[L - 15 + W][8] = oe
                                }
                                for (W = 0; W < 15; W += 1)
                                    oe = !G && (V >> W & 1) == 1,
                                    W < 8 ? v[8][L - W - 1] = oe : W < 9 ? v[8][15 - W - 1 + 1] = oe : v[8][15 - W - 1] = oe;
                                v[L - 8][8] = !G
                            }
                              , xe = function(G, K) {
                                for (var x = -1, V = L - 1, W = 7, oe = 0, $ = S.getMaskFunction(K), me = L - 1; me > 0; me -= 2)
                                    for (me == 6 && (me -= 1); ; ) {
                                        for (var he = 0; he < 2; he += 1)
                                            if (v[V][me - he] == null) {
                                                var ge = !1;
                                                oe < G.length && (ge = (G[oe] >>> W & 1) == 1),
                                                $(V, me - he) && (ge = !ge),
                                                v[V][me - he] = ge,
                                                (W -= 1) == -1 && (oe += 1,
                                                W = 7)
                                            }
                                        if ((V += x) < 0 || L <= V) {
                                            V -= x,
                                            x = -x;
                                            break
                                        }
                                    }
                            }
                              , ye = function(G, K, x) {
                                for (var V = B.getRSBlocks(G, K), W = z(), oe = 0; oe < x.length; oe += 1) {
                                    var $ = x[oe];
                                    W.put($.getMode(), 4),
                                    W.put($.getLength(), S.getLengthInBits($.getMode(), G)),
                                    $.write(W)
                                }
                                var me = 0;
                                for (oe = 0; oe < V.length; oe += 1)
                                    me += V[oe].dataCount;
                                if (W.getLengthInBits() > 8 * me)
                                    throw "code length overflow. (" + W.getLengthInBits() + ">" + 8 * me + ")";
                                for (W.getLengthInBits() + 4 <= 8 * me && W.put(0, 4); W.getLengthInBits() % 8 != 0; )
                                    W.putBit(!1);
                                for (; !(W.getLengthInBits() >= 8 * me || (W.put(236, 8),
                                W.getLengthInBits() >= 8 * me)); )
                                    W.put(17, 8);
                                return function(he, ge) {
                                    for (var De = 0, N = 0, M = 0, q = new Array(ge.length), J = new Array(ge.length), ee = 0; ee < ge.length; ee += 1) {
                                        var te = ge[ee].dataCount
                                          , we = ge[ee].totalCount - te;
                                        N = Math.max(N, te),
                                        M = Math.max(M, we),
                                        q[ee] = new Array(te);
                                        for (var de = 0; de < q[ee].length; de += 1)
                                            q[ee][de] = 255 & he.getBuffer()[de + De];
                                        De += te;
                                        var Ee = S.getErrorCorrectPolynomial(we)
                                          , Pe = b(q[ee], Ee.getLength() - 1).mod(Ee);
                                        for (J[ee] = new Array(Ee.getLength() - 1),
                                        de = 0; de < J[ee].length; de += 1) {
                                            var fe = de + Pe.getLength() - J[ee].length;
                                            J[ee][de] = fe >= 0 ? Pe.getAt(fe) : 0
                                        }
                                    }
                                    var Ne = 0;
                                    for (de = 0; de < ge.length; de += 1)
                                        Ne += ge[de].totalCount;
                                    var _e = new Array(Ne)
                                      , Ue = 0;
                                    for (de = 0; de < N; de += 1)
                                        for (ee = 0; ee < ge.length; ee += 1)
                                            de < q[ee].length && (_e[Ue] = q[ee][de],
                                            Ue += 1);
                                    for (de = 0; de < M; de += 1)
                                        for (ee = 0; ee < ge.length; ee += 1)
                                            de < J[ee].length && (_e[Ue] = J[ee][de],
                                            Ue += 1);
                                    return _e
                                }(W, V)
                            };
                            Y.addData = function(G, K) {
                                var x = null;
                                switch (K = K || "Byte") {
                                case "Numeric":
                                    x = I(G);
                                    break;
                                case "Alphanumeric":
                                    x = H(G);
                                    break;
                                case "Byte":
                                    x = P(G);
                                    break;
                                case "Kanji":
                                    x = T(G);
                                    break;
                                default:
                                    throw "mode:" + K
                                }
                                C.push(x),
                                R = null
                            }
                            ,
                            Y.isDark = function(G, K) {
                                if (G < 0 || L <= G || K < 0 || L <= K)
                                    throw G + "," + K;
                                return v[G][K]
                            }
                            ,
                            Y.getModuleCount = function() {
                                return L
                            }
                            ,
                            Y.make = function() {
                                if (O < 1) {
                                    for (var G = 1; G < 40; G++) {
                                        for (var K = B.getRSBlocks(G, y), x = z(), V = 0; V < C.length; V++) {
                                            var W = C[V];
                                            x.put(W.getMode(), 4),
                                            x.put(W.getLength(), S.getLengthInBits(W.getMode(), G)),
                                            W.write(x)
                                        }
                                        var oe = 0;
                                        for (V = 0; V < K.length; V++)
                                            oe += K[V].dataCount;
                                        if (x.getLengthInBits() <= 8 * oe)
                                            break
                                    }
                                    O = G
                                }
                                ue(!1, function() {
                                    for (var $ = 0, me = 0, he = 0; he < 8; he += 1) {
                                        ue(!0, he);
                                        var ge = S.getLostPoint(Y);
                                        (he == 0 || $ > ge) && ($ = ge,
                                        me = he)
                                    }
                                    return me
                                }())
                            }
                            ,
                            Y.createTableTag = function(G, K) {
                                G = G || 2;
                                var x = "";
                                x += '<table style="',
                                x += " border-width: 0px; border-style: none;",
                                x += " border-collapse: collapse;",
                                x += " padding: 0px; margin: " + (K = K === void 0 ? 4 * G : K) + "px;",
                                x += '">',
                                x += "<tbody>";
                                for (var V = 0; V < Y.getModuleCount(); V += 1) {
                                    x += "<tr>";
                                    for (var W = 0; W < Y.getModuleCount(); W += 1)
                                        x += '<td style="',
                                        x += " border-width: 0px; border-style: none;",
                                        x += " border-collapse: collapse;",
                                        x += " padding: 0px; margin: 0px;",
                                        x += " width: " + G + "px;",
                                        x += " height: " + G + "px;",
                                        x += " background-color: ",
                                        x += Y.isDark(V, W) ? "#000000" : "#ffffff",
                                        x += ";",
                                        x += '"/>';
                                    x += "</tr>"
                                }
                                return (x += "</tbody>") + "</table>"
                            }
                            ,
                            Y.createSvgTag = function(G, K, x, V) {
                                var W = {};
                                typeof arguments[0] == "object" && (G = (W = arguments[0]).cellSize,
                                K = W.margin,
                                x = W.alt,
                                V = W.title),
                                G = G || 2,
                                K = K === void 0 ? 4 * G : K,
                                (x = typeof x == "string" ? {
                                    text: x
                                } : x || {}).text = x.text || null,
                                x.id = x.text ? x.id || "qrcode-description" : null,
                                (V = typeof V == "string" ? {
                                    text: V
                                } : V || {}).text = V.text || null,
                                V.id = V.text ? V.id || "qrcode-title" : null;
                                var oe, $, me, he, ge = Y.getModuleCount() * G + 2 * K, De = "";
                                for (he = "l" + G + ",0 0," + G + " -" + G + ",0 0,-" + G + "z ",
                                De += '<svg version="1.1" xmlns="http://www.w3.org/2000/svg"',
                                De += W.scalable ? "" : ' width="' + ge + 'px" height="' + ge + 'px"',
                                De += ' viewBox="0 0 ' + ge + " " + ge + '" ',
                                De += ' preserveAspectRatio="xMinYMin meet"',
                                De += V.text || x.text ? ' role="img" aria-labelledby="' + Te([V.id, x.id].join(" ").trim()) + '"' : "",
                                De += ">",
                                De += V.text ? '<title id="' + Te(V.id) + '">' + Te(V.text) + "</title>" : "",
                                De += x.text ? '<description id="' + Te(x.id) + '">' + Te(x.text) + "</description>" : "",
                                De += '<rect width="100%" height="100%" fill="white" cx="0" cy="0"/>',
                                De += '<path d="',
                                $ = 0; $ < Y.getModuleCount(); $ += 1)
                                    for (me = $ * G + K,
                                    oe = 0; oe < Y.getModuleCount(); oe += 1)
                                        Y.isDark($, oe) && (De += "M" + (oe * G + K) + "," + me + he);
                                return (De += '" stroke="transparent" fill="black"/>') + "</svg>"
                            }
                            ,
                            Y.createDataURL = function(G, K) {
                                G = G || 2,
                                K = K === void 0 ? 4 * G : K;
                                var x = Y.getModuleCount() * G + 2 * K
                                  , V = K
                                  , W = x - K;
                                return k(x, x, function(oe, $) {
                                    if (V <= oe && oe < W && V <= $ && $ < W) {
                                        var me = Math.floor((oe - V) / G)
                                          , he = Math.floor(($ - V) / G);
                                        return Y.isDark(he, me) ? 0 : 1
                                    }
                                    return 1
                                })
                            }
                            ,
                            Y.createImgTag = function(G, K, x) {
                                G = G || 2,
                                K = K === void 0 ? 4 * G : K;
                                var V = Y.getModuleCount() * G + 2 * K
                                  , W = "";
                                return W += "<img",
                                W += ' src="',
                                W += Y.createDataURL(G, K),
                                W += '"',
                                W += ' width="',
                                W += V,
                                W += '"',
                                W += ' height="',
                                W += V,
                                W += '"',
                                x && (W += ' alt="',
                                W += Te(x),
                                W += '"'),
                                W + "/>"
                            }
                            ;
                            var Te = function(G) {
                                for (var K = "", x = 0; x < G.length; x += 1) {
                                    var V = G.charAt(x);
                                    switch (V) {
                                    case "<":
                                        K += "&lt;";
                                        break;
                                    case ">":
                                        K += "&gt;";
                                        break;
                                    case "&":
                                        K += "&amp;";
                                        break;
                                    case '"':
                                        K += "&quot;";
                                        break;
                                    default:
                                        K += V
                                    }
                                }
                                return K
                            };
                            return Y.createASCII = function(G, K) {
                                if ((G = G || 1) < 2)
                                    return function(q) {
                                        q = q === void 0 ? 2 : q;
                                        var J, ee, te, we, de, Ee = 1 * Y.getModuleCount() + 2 * q, Pe = q, fe = Ee - q, Ne = {
                                            "": "",
                                            " ": "",
                                            " ": "",
                                            "  ": " "
                                        }, _e = {
                                            "": "",
                                            " ": "",
                                            " ": " ",
                                            "  ": " "
                                        }, Ue = "";
                                        for (J = 0; J < Ee; J += 2) {
                                            for (te = Math.floor((J - Pe) / 1),
                                            we = Math.floor((J + 1 - Pe) / 1),
                                            ee = 0; ee < Ee; ee += 1)
                                                de = "",
                                                Pe <= ee && ee < fe && Pe <= J && J < fe && Y.isDark(te, Math.floor((ee - Pe) / 1)) && (de = " "),
                                                Pe <= ee && ee < fe && Pe <= J + 1 && J + 1 < fe && Y.isDark(we, Math.floor((ee - Pe) / 1)) ? de += " " : de += "",
                                                Ue += q < 1 && J + 1 >= fe ? _e[de] : Ne[de];
                                            Ue += `
`
                                        }
                                        return Ee % 2 && q > 0 ? Ue.substring(0, Ue.length - Ee - 1) + Array(Ee + 1).join("") : Ue.substring(0, Ue.length - 1)
                                    }(K);
                                G -= 1,
                                K = K === void 0 ? 2 * G : K;
                                var x, V, W, oe, $ = Y.getModuleCount() * G + 2 * K, me = K, he = $ - K, ge = Array(G + 1).join(""), De = Array(G + 1).join("  "), N = "", M = "";
                                for (x = 0; x < $; x += 1) {
                                    for (W = Math.floor((x - me) / G),
                                    M = "",
                                    V = 0; V < $; V += 1)
                                        oe = 1,
                                        me <= V && V < he && me <= x && x < he && Y.isDark(W, Math.floor((V - me) / G)) && (oe = 0),
                                        M += oe ? ge : De;
                                    for (W = 0; W < G; W += 1)
                                        N += M + `
`
                                }
                                return N.substring(0, N.length - 1)
                            }
                            ,
                            Y.renderTo2dContext = function(G, K) {
                                K = K || 2;
                                for (var x = Y.getModuleCount(), V = 0; V < x; V++)
                                    for (var W = 0; W < x; W++)
                                        G.fillStyle = Y.isDark(V, W) ? "black" : "white",
                                        G.fillRect(V * K, W * K, K, K)
                            }
                            ,
                            Y
                        };
                        h.stringToBytes = (h.stringToBytesFuncs = {
                            default: function(U) {
                                for (var F = [], O = 0; O < U.length; O += 1) {
                                    var y = U.charCodeAt(O);
                                    F.push(255 & y)
                                }
                                return F
                            }
                        }).default,
                        h.createStringToBytes = function(U, F) {
                            var O = function() {
                                for (var v = re(U), L = function() {
                                    var ne = v.read();
                                    if (ne == -1)
                                        throw "eof";
                                    return ne
                                }, R = 0, C = {}; ; ) {
                                    var Y = v.read();
                                    if (Y == -1)
                                        break;
                                    var ue = L()
                                      , X = L() << 8 | L();
                                    C[String.fromCharCode(Y << 8 | ue)] = X,
                                    R += 1
                                }
                                if (R != F)
                                    throw R + " != " + F;
                                return C
                            }()
                              , y = 63;
                            return function(v) {
                                for (var L = [], R = 0; R < v.length; R += 1) {
                                    var C = v.charCodeAt(R);
                                    if (C < 128)
                                        L.push(C);
                                    else {
                                        var Y = O[v.charAt(R)];
                                        typeof Y == "number" ? (255 & Y) == Y ? L.push(Y) : (L.push(Y >>> 8),
                                        L.push(255 & Y)) : L.push(y)
                                    }
                                }
                                return L
                            }
                        }
                        ;
                        var d, f, m, g, A, p = {
                            L: 1,
                            M: 0,
                            Q: 3,
                            H: 2
                        }, S = (d = [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]],
                        f = 1335,
                        m = 7973,
                        A = function(U) {
                            for (var F = 0; U != 0; )
                                F += 1,
                                U >>>= 1;
                            return F
                        }
                        ,
                        (g = {}).getBCHTypeInfo = function(U) {
                            for (var F = U << 10; A(F) - A(f) >= 0; )
                                F ^= f << A(F) - A(f);
                            return 21522 ^ (U << 10 | F)
                        }
                        ,
                        g.getBCHTypeNumber = function(U) {
                            for (var F = U << 12; A(F) - A(m) >= 0; )
                                F ^= m << A(F) - A(m);
                            return U << 12 | F
                        }
                        ,
                        g.getPatternPosition = function(U) {
                            return d[U - 1]
                        }
                        ,
                        g.getMaskFunction = function(U) {
                            switch (U) {
                            case 0:
                                return function(F, O) {
                                    return (F + O) % 2 == 0
                                }
                                ;
                            case 1:
                                return function(F, O) {
                                    return F % 2 == 0
                                }
                                ;
                            case 2:
                                return function(F, O) {
                                    return O % 3 == 0
                                }
                                ;
                            case 3:
                                return function(F, O) {
                                    return (F + O) % 3 == 0
                                }
                                ;
                            case 4:
                                return function(F, O) {
                                    return (Math.floor(F / 2) + Math.floor(O / 3)) % 2 == 0
                                }
                                ;
                            case 5:
                                return function(F, O) {
                                    return F * O % 2 + F * O % 3 == 0
                                }
                                ;
                            case 6:
                                return function(F, O) {
                                    return (F * O % 2 + F * O % 3) % 2 == 0
                                }
                                ;
                            case 7:
                                return function(F, O) {
                                    return (F * O % 3 + (F + O) % 2) % 2 == 0
                                }
                                ;
                            default:
                                throw "bad maskPattern:" + U
                            }
                        }
                        ,
                        g.getErrorCorrectPolynomial = function(U) {
                            for (var F = b([1], 0), O = 0; O < U; O += 1)
                                F = F.multiply(b([1, w.gexp(O)], 0));
                            return F
                        }
                        ,
                        g.getLengthInBits = function(U, F) {
                            if (1 <= F && F < 10)
                                switch (U) {
                                case 1:
                                    return 10;
                                case 2:
                                    return 9;
                                case 4:
                                case 8:
                                    return 8;
                                default:
                                    throw "mode:" + U
                                }
                            else if (F < 27)
                                switch (U) {
                                case 1:
                                    return 12;
                                case 2:
                                    return 11;
                                case 4:
                                    return 16;
                                case 8:
                                    return 10;
                                default:
                                    throw "mode:" + U
                                }
                            else {
                                if (!(F < 41))
                                    throw "type:" + F;
                                switch (U) {
                                case 1:
                                    return 14;
                                case 2:
                                    return 13;
                                case 4:
                                    return 16;
                                case 8:
                                    return 12;
                                default:
                                    throw "mode:" + U
                                }
                            }
                        }
                        ,
                        g.getLostPoint = function(U) {
                            for (var F = U.getModuleCount(), O = 0, y = 0; y < F; y += 1)
                                for (var v = 0; v < F; v += 1) {
                                    for (var L = 0, R = U.isDark(y, v), C = -1; C <= 1; C += 1)
                                        if (!(y + C < 0 || F <= y + C))
                                            for (var Y = -1; Y <= 1; Y += 1)
                                                v + Y < 0 || F <= v + Y || C == 0 && Y == 0 || R == U.isDark(y + C, v + Y) && (L += 1);
                                    L > 5 && (O += 3 + L - 5)
                                }
                            for (y = 0; y < F - 1; y += 1)
                                for (v = 0; v < F - 1; v += 1) {
                                    var ue = 0;
                                    U.isDark(y, v) && (ue += 1),
                                    U.isDark(y + 1, v) && (ue += 1),
                                    U.isDark(y, v + 1) && (ue += 1),
                                    U.isDark(y + 1, v + 1) && (ue += 1),
                                    ue != 0 && ue != 4 || (O += 3)
                                }
                            for (y = 0; y < F; y += 1)
                                for (v = 0; v < F - 6; v += 1)
                                    U.isDark(y, v) && !U.isDark(y, v + 1) && U.isDark(y, v + 2) && U.isDark(y, v + 3) && U.isDark(y, v + 4) && !U.isDark(y, v + 5) && U.isDark(y, v + 6) && (O += 40);
                            for (v = 0; v < F; v += 1)
                                for (y = 0; y < F - 6; y += 1)
                                    U.isDark(y, v) && !U.isDark(y + 1, v) && U.isDark(y + 2, v) && U.isDark(y + 3, v) && U.isDark(y + 4, v) && !U.isDark(y + 5, v) && U.isDark(y + 6, v) && (O += 40);
                            var X = 0;
                            for (v = 0; v < F; v += 1)
                                for (y = 0; y < F; y += 1)
                                    U.isDark(y, v) && (X += 1);
                            return O + Math.abs(100 * X / F / F - 50) / 5 * 10
                        }
                        ,
                        g), w = function() {
                            for (var U = new Array(256), F = new Array(256), O = 0; O < 8; O += 1)
                                U[O] = 1 << O;
                            for (O = 8; O < 256; O += 1)
                                U[O] = U[O - 4] ^ U[O - 5] ^ U[O - 6] ^ U[O - 8];
                            for (O = 0; O < 255; O += 1)
                                F[U[O]] = O;
                            return {
                                glog: function(y) {
                                    if (y < 1)
                                        throw "glog(" + y + ")";
                                    return F[y]
                                },
                                gexp: function(y) {
                                    for (; y < 0; )
                                        y += 255;
                                    for (; y >= 256; )
                                        y -= 255;
                                    return U[y]
                                }
                            }
                        }();
                        function b(U, F) {
                            if (U.length === void 0)
                                throw U.length + "/" + F;
                            var O = function() {
                                for (var v = 0; v < U.length && U[v] == 0; )
                                    v += 1;
                                for (var L = new Array(U.length - v + F), R = 0; R < U.length - v; R += 1)
                                    L[R] = U[R + v];
                                return L
                            }()
                              , y = {
                                getAt: function(v) {
                                    return O[v]
                                },
                                getLength: function() {
                                    return O.length
                                },
                                multiply: function(v) {
                                    for (var L = new Array(y.getLength() + v.getLength() - 1), R = 0; R < y.getLength(); R += 1)
                                        for (var C = 0; C < v.getLength(); C += 1)
                                            L[R + C] ^= w.gexp(w.glog(y.getAt(R)) + w.glog(v.getAt(C)));
                                    return b(L, 0)
                                },
                                mod: function(v) {
                                    if (y.getLength() - v.getLength() < 0)
                                        return y;
                                    for (var L = w.glog(y.getAt(0)) - w.glog(v.getAt(0)), R = new Array(y.getLength()), C = 0; C < y.getLength(); C += 1)
                                        R[C] = y.getAt(C);
                                    for (C = 0; C < v.getLength(); C += 1)
                                        R[C] ^= w.gexp(w.glog(v.getAt(C)) + L);
                                    return b(R, 0).mod(v)
                                }
                            };
                            return y
                        }
                        var B = function() {
                            var U = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12, 7, 37, 13], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]]
                              , F = function(y, v) {
                                var L = {};
                                return L.totalCount = y,
                                L.dataCount = v,
                                L
                            }
                              , O = {
                                getRSBlocks: function(y, v) {
                                    var L = function(ce, le) {
                                        switch (le) {
                                        case p.L:
                                            return U[4 * (ce - 1) + 0];
                                        case p.M:
                                            return U[4 * (ce - 1) + 1];
                                        case p.Q:
                                            return U[4 * (ce - 1) + 2];
                                        case p.H:
                                            return U[4 * (ce - 1) + 3];
                                        default:
                                            return
                                        }
                                    }(y, v);
                                    if (L === void 0)
                                        throw "bad rs block @ typeNumber:" + y + "/errorCorrectionLevel:" + v;
                                    for (var R = L.length / 3, C = [], Y = 0; Y < R; Y += 1)
                                        for (var ue = L[3 * Y + 0], X = L[3 * Y + 1], ne = L[3 * Y + 2], ae = 0; ae < ue; ae += 1)
                                            C.push(F(X, ne));
                                    return C
                                }
                            };
                            return O
                        }()
                          , z = function() {
                            var U = []
                              , F = 0
                              , O = {
                                getBuffer: function() {
                                    return U
                                },
                                getAt: function(y) {
                                    var v = Math.floor(y / 8);
                                    return (U[v] >>> 7 - y % 8 & 1) == 1
                                },
                                put: function(y, v) {
                                    for (var L = 0; L < v; L += 1)
                                        O.putBit((y >>> v - L - 1 & 1) == 1)
                                },
                                getLengthInBits: function() {
                                    return F
                                },
                                putBit: function(y) {
                                    var v = Math.floor(F / 8);
                                    U.length <= v && U.push(0),
                                    y && (U[v] |= 128 >>> F % 8),
                                    F += 1
                                }
                            };
                            return O
                        }
                          , I = function(U) {
                            var F = U
                              , O = {
                                getMode: function() {
                                    return 1
                                },
                                getLength: function(L) {
                                    return F.length
                                },
                                write: function(L) {
                                    for (var R = F, C = 0; C + 2 < R.length; )
                                        L.put(y(R.substring(C, C + 3)), 10),
                                        C += 3;
                                    C < R.length && (R.length - C == 1 ? L.put(y(R.substring(C, C + 1)), 4) : R.length - C == 2 && L.put(y(R.substring(C, C + 2)), 7))
                                }
                            }
                              , y = function(L) {
                                for (var R = 0, C = 0; C < L.length; C += 1)
                                    R = 10 * R + v(L.charAt(C));
                                return R
                            }
                              , v = function(L) {
                                if ("0" <= L && L <= "9")
                                    return L.charCodeAt(0) - 48;
                                throw "illegal char :" + L
                            };
                            return O
                        }
                          , H = function(U) {
                            var F = U
                              , O = {
                                getMode: function() {
                                    return 2
                                },
                                getLength: function(v) {
                                    return F.length
                                },
                                write: function(v) {
                                    for (var L = F, R = 0; R + 1 < L.length; )
                                        v.put(45 * y(L.charAt(R)) + y(L.charAt(R + 1)), 11),
                                        R += 2;
                                    R < L.length && v.put(y(L.charAt(R)), 6)
                                }
                            }
                              , y = function(v) {
                                if ("0" <= v && v <= "9")
                                    return v.charCodeAt(0) - 48;
                                if ("A" <= v && v <= "Z")
                                    return v.charCodeAt(0) - 65 + 10;
                                switch (v) {
                                case " ":
                                    return 36;
                                case "$":
                                    return 37;
                                case "%":
                                    return 38;
                                case "*":
                                    return 39;
                                case "+":
                                    return 40;
                                case "-":
                                    return 41;
                                case ".":
                                    return 42;
                                case "/":
                                    return 43;
                                case ":":
                                    return 44;
                                default:
                                    throw "illegal char :" + v
                                }
                            };
                            return O
                        }
                          , P = function(U) {
                            var F = h.stringToBytes(U);
                            return {
                                getMode: function() {
                                    return 4
                                },
                                getLength: function(O) {
                                    return F.length
                                },
                                write: function(O) {
                                    for (var y = 0; y < F.length; y += 1)
                                        O.put(F[y], 8)
                                }
                            }
                        }
                          , T = function(U) {
                            var F = h.stringToBytesFuncs.SJIS;
                            if (!F)
                                throw "sjis not supported.";
                            (function() {
                                var v = F("");
                                if (v.length != 2 || (v[0] << 8 | v[1]) != 38726)
                                    throw "sjis not supported."
                            }
                            )();
                            var O = F(U)
                              , y = {
                                getMode: function() {
                                    return 8
                                },
                                getLength: function(v) {
                                    return ~~(O.length / 2)
                                },
                                write: function(v) {
                                    for (var L = O, R = 0; R + 1 < L.length; ) {
                                        var C = (255 & L[R]) << 8 | 255 & L[R + 1];
                                        if (33088 <= C && C <= 40956)
                                            C -= 33088;
                                        else {
                                            if (!(57408 <= C && C <= 60351))
                                                throw "illegal char at " + (R + 1) + "/" + C;
                                            C -= 49472
                                        }
                                        C = 192 * (C >>> 8 & 255) + (255 & C),
                                        v.put(C, 13),
                                        R += 2
                                    }
                                    if (R < L.length)
                                        throw "illegal char at " + (R + 1)
                                }
                            };
                            return y
                        }
                          , _ = function() {
                            var U = []
                              , F = {
                                writeByte: function(O) {
                                    U.push(255 & O)
                                },
                                writeShort: function(O) {
                                    F.writeByte(O),
                                    F.writeByte(O >>> 8)
                                },
                                writeBytes: function(O, y, v) {
                                    y = y || 0,
                                    v = v || O.length;
                                    for (var L = 0; L < v; L += 1)
                                        F.writeByte(O[L + y])
                                },
                                writeString: function(O) {
                                    for (var y = 0; y < O.length; y += 1)
                                        F.writeByte(O.charCodeAt(y))
                                },
                                toByteArray: function() {
                                    return U
                                },
                                toString: function() {
                                    var O = "";
                                    O += "[";
                                    for (var y = 0; y < U.length; y += 1)
                                        y > 0 && (O += ","),
                                        O += U[y];
                                    return O + "]"
                                }
                            };
                            return F
                        }
                          , re = function(U) {
                            var F = U
                              , O = 0
                              , y = 0
                              , v = 0
                              , L = {
                                read: function() {
                                    for (; v < 8; ) {
                                        if (O >= F.length) {
                                            if (v == 0)
                                                return -1;
                                            throw "unexpected end of file./" + v
                                        }
                                        var C = F.charAt(O);
                                        if (O += 1,
                                        C == "=")
                                            return v = 0,
                                            -1;
                                        C.match(/^\s$/) || (y = y << 6 | R(C.charCodeAt(0)),
                                        v += 6)
                                    }
                                    var Y = y >>> v - 8 & 255;
                                    return v -= 8,
                                    Y
                                }
                            }
                              , R = function(C) {
                                if (65 <= C && C <= 90)
                                    return C - 65;
                                if (97 <= C && C <= 122)
                                    return C - 97 + 26;
                                if (48 <= C && C <= 57)
                                    return C - 48 + 52;
                                if (C == 43)
                                    return 62;
                                if (C == 47)
                                    return 63;
                                throw "c:" + C
                            };
                            return L
                        }
                          , k = function(U, F, O) {
                            for (var y = function(X, ne) {
                                var ae = X
                                  , ce = ne
                                  , le = new Array(X * ne)
                                  , xe = {
                                    setPixel: function(G, K, x) {
                                        le[K * ae + G] = x
                                    },
                                    write: function(G) {
                                        G.writeString("GIF87a"),
                                        G.writeShort(ae),
                                        G.writeShort(ce),
                                        G.writeByte(128),
                                        G.writeByte(0),
                                        G.writeByte(0),
                                        G.writeByte(0),
                                        G.writeByte(0),
                                        G.writeByte(0),
                                        G.writeByte(255),
                                        G.writeByte(255),
                                        G.writeByte(255),
                                        G.writeString(","),
                                        G.writeShort(0),
                                        G.writeShort(0),
                                        G.writeShort(ae),
                                        G.writeShort(ce),
                                        G.writeByte(0);
                                        var K = ye(2);
                                        G.writeByte(2);
                                        for (var x = 0; K.length - x > 255; )
                                            G.writeByte(255),
                                            G.writeBytes(K, x, 255),
                                            x += 255;
                                        G.writeByte(K.length - x),
                                        G.writeBytes(K, x, K.length - x),
                                        G.writeByte(0),
                                        G.writeString(";")
                                    }
                                }
                                  , ye = function(G) {
                                    for (var K = 1 << G, x = 1 + (1 << G), V = G + 1, W = Te(), oe = 0; oe < K; oe += 1)
                                        W.add(String.fromCharCode(oe));
                                    W.add(String.fromCharCode(K)),
                                    W.add(String.fromCharCode(x));
                                    var $, me, he, ge = _(), De = ($ = ge,
                                    me = 0,
                                    he = 0,
                                    {
                                        write: function(J, ee) {
                                            if (J >>> ee)
                                                throw "length over";
                                            for (; me + ee >= 8; )
                                                $.writeByte(255 & (J << me | he)),
                                                ee -= 8 - me,
                                                J >>>= 8 - me,
                                                he = 0,
                                                me = 0;
                                            he |= J << me,
                                            me += ee
                                        },
                                        flush: function() {
                                            me > 0 && $.writeByte(he)
                                        }
                                    });
                                    De.write(K, V);
                                    var N = 0
                                      , M = String.fromCharCode(le[N]);
                                    for (N += 1; N < le.length; ) {
                                        var q = String.fromCharCode(le[N]);
                                        N += 1,
                                        W.contains(M + q) ? M += q : (De.write(W.indexOf(M), V),
                                        W.size() < 4095 && (W.size() == 1 << V && (V += 1),
                                        W.add(M + q)),
                                        M = q)
                                    }
                                    return De.write(W.indexOf(M), V),
                                    De.write(x, V),
                                    De.flush(),
                                    ge.toByteArray()
                                }
                                  , Te = function() {
                                    var G = {}
                                      , K = 0
                                      , x = {
                                        add: function(V) {
                                            if (x.contains(V))
                                                throw "dup key:" + V;
                                            G[V] = K,
                                            K += 1
                                        },
                                        size: function() {
                                            return K
                                        },
                                        indexOf: function(V) {
                                            return G[V]
                                        },
                                        contains: function(V) {
                                            return G[V] !== void 0
                                        }
                                    };
                                    return x
                                };
                                return xe
                            }(U, F), v = 0; v < F; v += 1)
                                for (var L = 0; L < U; L += 1)
                                    y.setPixel(L, v, O(L, v));
                            var R = _();
                            y.write(R);
                            for (var C = function() {
                                var X = 0
                                  , ne = 0
                                  , ae = 0
                                  , ce = ""
                                  , le = {}
                                  , xe = function(Te) {
                                    ce += String.fromCharCode(ye(63 & Te))
                                }
                                  , ye = function(Te) {
                                    if (!(Te < 0)) {
                                        if (Te < 26)
                                            return 65 + Te;
                                        if (Te < 52)
                                            return Te - 26 + 97;
                                        if (Te < 62)
                                            return Te - 52 + 48;
                                        if (Te == 62)
                                            return 43;
                                        if (Te == 63)
                                            return 47
                                    }
                                    throw "n:" + Te
                                };
                                return le.writeByte = function(Te) {
                                    for (X = X << 8 | 255 & Te,
                                    ne += 8,
                                    ae += 1; ne >= 6; )
                                        xe(X >>> ne - 6),
                                        ne -= 6
                                }
                                ,
                                le.flush = function() {
                                    if (ne > 0 && (xe(X << 6 - ne),
                                    X = 0,
                                    ne = 0),
                                    ae % 3 != 0)
                                        for (var Te = 3 - ae % 3, G = 0; G < Te; G += 1)
                                            ce += "="
                                }
                                ,
                                le.toString = function() {
                                    return ce
                                }
                                ,
                                le
                            }(), Y = R.toByteArray(), ue = 0; ue < Y.length; ue += 1)
                                C.writeByte(Y[ue]);
                            return C.flush(),
                            "data:image/gif;base64," + C
                        };
                        return h
                    }();
                    u.stringToBytesFuncs["UTF-8"] = function(h) {
                        return function(d) {
                            for (var f = [], m = 0; m < d.length; m++) {
                                var g = d.charCodeAt(m);
                                g < 128 ? f.push(g) : g < 2048 ? f.push(192 | g >> 6, 128 | 63 & g) : g < 55296 || g >= 57344 ? f.push(224 | g >> 12, 128 | g >> 6 & 63, 128 | 63 & g) : (m++,
                                g = 65536 + ((1023 & g) << 10 | 1023 & d.charCodeAt(m)),
                                f.push(240 | g >> 18, 128 | g >> 12 & 63, 128 | g >> 6 & 63, 128 | 63 & g))
                            }
                            return f
                        }(h)
                    }
                    ,
                    (l = typeof (c = function() {
                        return u
                    }
                    ) == "function" ? c.apply(a, []) : c) === void 0 || (o.exports = l)
                }
            }
              , n = {};
            function i(o) {
                var a = n[o];
                if (a !== void 0)
                    return a.exports;
                var c = n[o] = {
                    exports: {}
                };
                return t[o](c, c.exports, i),
                c.exports
            }
            i.n = o => {
                var a = o && o.__esModule ? () => o.default : () => o;
                return i.d(a, {
                    a
                }),
                a
            }
            ,
            i.d = (o, a) => {
                for (var c in a)
                    i.o(a, c) && !i.o(o, c) && Object.defineProperty(o, c, {
                        enumerable: !0,
                        get: a[c]
                    })
            }
            ,
            i.o = (o, a) => Object.prototype.hasOwnProperty.call(o, a);
            var s = {};
            return ( () => {
                i.d(s, {
                    default: () => F
                });
                const o = O => !!O && typeof O == "object" && !Array.isArray(O);
                function a(O, ...y) {
                    if (!y.length)
                        return O;
                    const v = y.shift();
                    return v !== void 0 && o(O) && o(v) ? (O = Object.assign({}, O),
                    Object.keys(v).forEach(L => {
                        const R = O[L]
                          , C = v[L];
                        Array.isArray(R) && Array.isArray(C) ? O[L] = C : o(R) && o(C) ? O[L] = a(Object.assign({}, R), C) : O[L] = C
                    }
                    ),
                    a(O, ...y)) : O
                }
                function c(O, y) {
                    const v = document.createElement("a");
                    v.download = y,
                    v.href = O,
                    document.body.appendChild(v),
                    v.click(),
                    document.body.removeChild(v)
                }
                const l = {
                    L: .07,
                    M: .15,
                    Q: .25,
                    H: .3
                };
                class u {
                    constructor({svg: y, type: v, window: L}) {
                        this._svg = y,
                        this._type = v,
                        this._window = L
                    }
                    draw(y, v, L, R) {
                        let C;
                        switch (this._type) {
                        case "dots":
                            C = this._drawDot;
                            break;
                        case "classy":
                            C = this._drawClassy;
                            break;
                        case "classy-rounded":
                            C = this._drawClassyRounded;
                            break;
                        case "rounded":
                            C = this._drawRounded;
                            break;
                        case "extra-rounded":
                            C = this._drawExtraRounded;
                            break;
                        default:
                            C = this._drawSquare
                        }
                        C.call(this, {
                            x: y,
                            y: v,
                            size: L,
                            getNeighbor: R
                        })
                    }
                    _rotateFigure({x: y, y: v, size: L, rotation: R=0, draw: C}) {
                        var Y;
                        const ue = y + L / 2
                          , X = v + L / 2;
                        C(),
                        (Y = this._element) === null || Y === void 0 || Y.setAttribute("transform", `rotate(${180 * R / Math.PI},${ue},${X})`)
                    }
                    _basicDot(y) {
                        const {size: v, x: L, y: R} = y;
                        this._rotateFigure(Object.assign(Object.assign({}, y), {
                            draw: () => {
                                this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "circle"),
                                this._element.setAttribute("cx", String(L + v / 2)),
                                this._element.setAttribute("cy", String(R + v / 2)),
                                this._element.setAttribute("r", String(v / 2))
                            }
                        }))
                    }
                    _basicSquare(y) {
                        const {size: v, x: L, y: R} = y;
                        this._rotateFigure(Object.assign(Object.assign({}, y), {
                            draw: () => {
                                this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "rect"),
                                this._element.setAttribute("x", String(L)),
                                this._element.setAttribute("y", String(R)),
                                this._element.setAttribute("width", String(v)),
                                this._element.setAttribute("height", String(v))
                            }
                        }))
                    }
                    _basicSideRounded(y) {
                        const {size: v, x: L, y: R} = y;
                        this._rotateFigure(Object.assign(Object.assign({}, y), {
                            draw: () => {
                                this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"),
                                this._element.setAttribute("d", `M ${L} ${R}v ${v}h ` + v / 2 + `a ${v / 2} ${v / 2}, 0, 0, 0, 0 ${-v}`)
                            }
                        }))
                    }
                    _basicCornerRounded(y) {
                        const {size: v, x: L, y: R} = y;
                        this._rotateFigure(Object.assign(Object.assign({}, y), {
                            draw: () => {
                                this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"),
                                this._element.setAttribute("d", `M ${L} ${R}v ${v}h ${v}v ` + -v / 2 + `a ${v / 2} ${v / 2}, 0, 0, 0, ${-v / 2} ${-v / 2}`)
                            }
                        }))
                    }
                    _basicCornerExtraRounded(y) {
                        const {size: v, x: L, y: R} = y;
                        this._rotateFigure(Object.assign(Object.assign({}, y), {
                            draw: () => {
                                this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"),
                                this._element.setAttribute("d", `M ${L} ${R}v ${v}h ${v}a ${v} ${v}, 0, 0, 0, ${-v} ${-v}`)
                            }
                        }))
                    }
                    _basicCornersRounded(y) {
                        const {size: v, x: L, y: R} = y;
                        this._rotateFigure(Object.assign(Object.assign({}, y), {
                            draw: () => {
                                this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"),
                                this._element.setAttribute("d", `M ${L} ${R}v ` + v / 2 + `a ${v / 2} ${v / 2}, 0, 0, 0, ${v / 2} ${v / 2}h ` + v / 2 + "v " + -v / 2 + `a ${v / 2} ${v / 2}, 0, 0, 0, ${-v / 2} ${-v / 2}`)
                            }
                        }))
                    }
                    _drawDot({x: y, y: v, size: L}) {
                        this._basicDot({
                            x: y,
                            y: v,
                            size: L,
                            rotation: 0
                        })
                    }
                    _drawSquare({x: y, y: v, size: L}) {
                        this._basicSquare({
                            x: y,
                            y: v,
                            size: L,
                            rotation: 0
                        })
                    }
                    _drawRounded({x: y, y: v, size: L, getNeighbor: R}) {
                        const C = R ? +R(-1, 0) : 0
                          , Y = R ? +R(1, 0) : 0
                          , ue = R ? +R(0, -1) : 0
                          , X = R ? +R(0, 1) : 0
                          , ne = C + Y + ue + X;
                        if (ne !== 0)
                            if (ne > 2 || C && Y || ue && X)
                                this._basicSquare({
                                    x: y,
                                    y: v,
                                    size: L,
                                    rotation: 0
                                });
                            else {
                                if (ne === 2) {
                                    let ae = 0;
                                    return C && ue ? ae = Math.PI / 2 : ue && Y ? ae = Math.PI : Y && X && (ae = -Math.PI / 2),
                                    void this._basicCornerRounded({
                                        x: y,
                                        y: v,
                                        size: L,
                                        rotation: ae
                                    })
                                }
                                if (ne === 1) {
                                    let ae = 0;
                                    return ue ? ae = Math.PI / 2 : Y ? ae = Math.PI : X && (ae = -Math.PI / 2),
                                    void this._basicSideRounded({
                                        x: y,
                                        y: v,
                                        size: L,
                                        rotation: ae
                                    })
                                }
                            }
                        else
                            this._basicDot({
                                x: y,
                                y: v,
                                size: L,
                                rotation: 0
                            })
                    }
                    _drawExtraRounded({x: y, y: v, size: L, getNeighbor: R}) {
                        const C = R ? +R(-1, 0) : 0
                          , Y = R ? +R(1, 0) : 0
                          , ue = R ? +R(0, -1) : 0
                          , X = R ? +R(0, 1) : 0
                          , ne = C + Y + ue + X;
                        if (ne !== 0)
                            if (ne > 2 || C && Y || ue && X)
                                this._basicSquare({
                                    x: y,
                                    y: v,
                                    size: L,
                                    rotation: 0
                                });
                            else {
                                if (ne === 2) {
                                    let ae = 0;
                                    return C && ue ? ae = Math.PI / 2 : ue && Y ? ae = Math.PI : Y && X && (ae = -Math.PI / 2),
                                    void this._basicCornerExtraRounded({
                                        x: y,
                                        y: v,
                                        size: L,
                                        rotation: ae
                                    })
                                }
                                if (ne === 1) {
                                    let ae = 0;
                                    return ue ? ae = Math.PI / 2 : Y ? ae = Math.PI : X && (ae = -Math.PI / 2),
                                    void this._basicSideRounded({
                                        x: y,
                                        y: v,
                                        size: L,
                                        rotation: ae
                                    })
                                }
                            }
                        else
                            this._basicDot({
                                x: y,
                                y: v,
                                size: L,
                                rotation: 0
                            })
                    }
                    _drawClassy({x: y, y: v, size: L, getNeighbor: R}) {
                        const C = R ? +R(-1, 0) : 0
                          , Y = R ? +R(1, 0) : 0
                          , ue = R ? +R(0, -1) : 0
                          , X = R ? +R(0, 1) : 0;
                        C + Y + ue + X !== 0 ? C || ue ? Y || X ? this._basicSquare({
                            x: y,
                            y: v,
                            size: L,
                            rotation: 0
                        }) : this._basicCornerRounded({
                            x: y,
                            y: v,
                            size: L,
                            rotation: Math.PI / 2
                        }) : this._basicCornerRounded({
                            x: y,
                            y: v,
                            size: L,
                            rotation: -Math.PI / 2
                        }) : this._basicCornersRounded({
                            x: y,
                            y: v,
                            size: L,
                            rotation: Math.PI / 2
                        })
                    }
                    _drawClassyRounded({x: y, y: v, size: L, getNeighbor: R}) {
                        const C = R ? +R(-1, 0) : 0
                          , Y = R ? +R(1, 0) : 0
                          , ue = R ? +R(0, -1) : 0
                          , X = R ? +R(0, 1) : 0;
                        C + Y + ue + X !== 0 ? C || ue ? Y || X ? this._basicSquare({
                            x: y,
                            y: v,
                            size: L,
                            rotation: 0
                        }) : this._basicCornerExtraRounded({
                            x: y,
                            y: v,
                            size: L,
                            rotation: Math.PI / 2
                        }) : this._basicCornerExtraRounded({
                            x: y,
                            y: v,
                            size: L,
                            rotation: -Math.PI / 2
                        }) : this._basicCornersRounded({
                            x: y,
                            y: v,
                            size: L,
                            rotation: Math.PI / 2
                        })
                    }
                }
                const h = {
                    dot: "dot",
                    square: "square",
                    extraRounded: "extra-rounded"
                }
                  , d = Object.values(h);
                class f {
                    constructor({svg: y, type: v, window: L}) {
                        this._svg = y,
                        this._type = v,
                        this._window = L
                    }
                    draw(y, v, L, R) {
                        let C;
                        switch (this._type) {
                        case h.square:
                            C = this._drawSquare;
                            break;
                        case h.extraRounded:
                            C = this._drawExtraRounded;
                            break;
                        default:
                            C = this._drawDot
                        }
                        C.call(this, {
                            x: y,
                            y: v,
                            size: L,
                            rotation: R
                        })
                    }
                    _rotateFigure({x: y, y: v, size: L, rotation: R=0, draw: C}) {
                        var Y;
                        const ue = y + L / 2
                          , X = v + L / 2;
                        C(),
                        (Y = this._element) === null || Y === void 0 || Y.setAttribute("transform", `rotate(${180 * R / Math.PI},${ue},${X})`)
                    }
                    _basicDot(y) {
                        const {size: v, x: L, y: R} = y
                          , C = v / 7;
                        this._rotateFigure(Object.assign(Object.assign({}, y), {
                            draw: () => {
                                this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"),
                                this._element.setAttribute("clip-rule", "evenodd"),
                                this._element.setAttribute("d", `M ${L + v / 2} ${R}a ${v / 2} ${v / 2} 0 1 0 0.1 0zm 0 ${C}a ${v / 2 - C} ${v / 2 - C} 0 1 1 -0.1 0Z`)
                            }
                        }))
                    }
                    _basicSquare(y) {
                        const {size: v, x: L, y: R} = y
                          , C = v / 7;
                        this._rotateFigure(Object.assign(Object.assign({}, y), {
                            draw: () => {
                                this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"),
                                this._element.setAttribute("clip-rule", "evenodd"),
                                this._element.setAttribute("d", `M ${L} ${R}v ${v}h ${v}v ` + -v + `zM ${L + C} ${R + C}h ` + (v - 2 * C) + "v " + (v - 2 * C) + "h " + (2 * C - v) + "z")
                            }
                        }))
                    }
                    _basicExtraRounded(y) {
                        const {size: v, x: L, y: R} = y
                          , C = v / 7;
                        this._rotateFigure(Object.assign(Object.assign({}, y), {
                            draw: () => {
                                this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"),
                                this._element.setAttribute("clip-rule", "evenodd"),
                                this._element.setAttribute("d", `M ${L} ${R + 2.5 * C}v ` + 2 * C + `a ${2.5 * C} ${2.5 * C}, 0, 0, 0, ${2.5 * C} ${2.5 * C}h ` + 2 * C + `a ${2.5 * C} ${2.5 * C}, 0, 0, 0, ${2.5 * C} ${2.5 * -C}v ` + -2 * C + `a ${2.5 * C} ${2.5 * C}, 0, 0, 0, ${2.5 * -C} ${2.5 * -C}h ` + -2 * C + `a ${2.5 * C} ${2.5 * C}, 0, 0, 0, ${2.5 * -C} ${2.5 * C}M ${L + 2.5 * C} ${R + C}h ` + 2 * C + `a ${1.5 * C} ${1.5 * C}, 0, 0, 1, ${1.5 * C} ${1.5 * C}v ` + 2 * C + `a ${1.5 * C} ${1.5 * C}, 0, 0, 1, ${1.5 * -C} ${1.5 * C}h ` + -2 * C + `a ${1.5 * C} ${1.5 * C}, 0, 0, 1, ${1.5 * -C} ${1.5 * -C}v ` + -2 * C + `a ${1.5 * C} ${1.5 * C}, 0, 0, 1, ${1.5 * C} ${1.5 * -C}`)
                            }
                        }))
                    }
                    _drawDot({x: y, y: v, size: L, rotation: R}) {
                        this._basicDot({
                            x: y,
                            y: v,
                            size: L,
                            rotation: R
                        })
                    }
                    _drawSquare({x: y, y: v, size: L, rotation: R}) {
                        this._basicSquare({
                            x: y,
                            y: v,
                            size: L,
                            rotation: R
                        })
                    }
                    _drawExtraRounded({x: y, y: v, size: L, rotation: R}) {
                        this._basicExtraRounded({
                            x: y,
                            y: v,
                            size: L,
                            rotation: R
                        })
                    }
                }
                const m = {
                    dot: "dot",
                    square: "square"
                }
                  , g = Object.values(m);
                class A {
                    constructor({svg: y, type: v, window: L}) {
                        this._svg = y,
                        this._type = v,
                        this._window = L
                    }
                    draw(y, v, L, R) {
                        let C;
                        C = this._type === m.square ? this._drawSquare : this._drawDot,
                        C.call(this, {
                            x: y,
                            y: v,
                            size: L,
                            rotation: R
                        })
                    }
                    _rotateFigure({x: y, y: v, size: L, rotation: R=0, draw: C}) {
                        var Y;
                        const ue = y + L / 2
                          , X = v + L / 2;
                        C(),
                        (Y = this._element) === null || Y === void 0 || Y.setAttribute("transform", `rotate(${180 * R / Math.PI},${ue},${X})`)
                    }
                    _basicDot(y) {
                        const {size: v, x: L, y: R} = y;
                        this._rotateFigure(Object.assign(Object.assign({}, y), {
                            draw: () => {
                                this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "circle"),
                                this._element.setAttribute("cx", String(L + v / 2)),
                                this._element.setAttribute("cy", String(R + v / 2)),
                                this._element.setAttribute("r", String(v / 2))
                            }
                        }))
                    }
                    _basicSquare(y) {
                        const {size: v, x: L, y: R} = y;
                        this._rotateFigure(Object.assign(Object.assign({}, y), {
                            draw: () => {
                                this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "rect"),
                                this._element.setAttribute("x", String(L)),
                                this._element.setAttribute("y", String(R)),
                                this._element.setAttribute("width", String(v)),
                                this._element.setAttribute("height", String(v))
                            }
                        }))
                    }
                    _drawDot({x: y, y: v, size: L, rotation: R}) {
                        this._basicDot({
                            x: y,
                            y: v,
                            size: L,
                            rotation: R
                        })
                    }
                    _drawSquare({x: y, y: v, size: L, rotation: R}) {
                        this._basicSquare({
                            x: y,
                            y: v,
                            size: L,
                            rotation: R
                        })
                    }
                }
                const p = "circle"
                  , S = [[1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1]]
                  , w = [[0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]];
                class b {
                    constructor(y, v) {
                        this._roundSize = L => this._options.dotsOptions.roundSize ? Math.floor(L) : L,
                        this._window = v,
                        this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "svg"),
                        this._element.setAttribute("width", String(y.width)),
                        this._element.setAttribute("height", String(y.height)),
                        this._element.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink"),
                        y.dotsOptions.roundSize || this._element.setAttribute("shape-rendering", "crispEdges"),
                        this._element.setAttribute("viewBox", `0 0 ${y.width} ${y.height}`),
                        this._defs = this._window.document.createElementNS("http://www.w3.org/2000/svg", "defs"),
                        this._element.appendChild(this._defs),
                        this._imageUri = y.image,
                        this._instanceId = b.instanceCount++,
                        this._options = y
                    }
                    get width() {
                        return this._options.width
                    }
                    get height() {
                        return this._options.height
                    }
                    getElement() {
                        return this._element
                    }
                    async drawQR(y) {
                        const v = y.getModuleCount()
                          , L = Math.min(this._options.width, this._options.height) - 2 * this._options.margin
                          , R = this._options.shape === p ? L / Math.sqrt(2) : L
                          , C = this._roundSize(R / v);
                        let Y = {
                            hideXDots: 0,
                            hideYDots: 0,
                            width: 0,
                            height: 0
                        };
                        if (this._qr = y,
                        this._options.image) {
                            if (await this.loadImage(),
                            !this._image)
                                return;
                            const {imageOptions: ue, qrOptions: X} = this._options
                              , ne = ue.imageSize * l[X.errorCorrectionLevel]
                              , ae = Math.floor(ne * v * v);
                            Y = function({originalHeight: ce, originalWidth: le, maxHiddenDots: xe, maxHiddenAxisDots: ye, dotSize: Te}) {
                                const G = {
                                    x: 0,
                                    y: 0
                                }
                                  , K = {
                                    x: 0,
                                    y: 0
                                };
                                if (ce <= 0 || le <= 0 || xe <= 0 || Te <= 0)
                                    return {
                                        height: 0,
                                        width: 0,
                                        hideYDots: 0,
                                        hideXDots: 0
                                    };
                                const x = ce / le;
                                return G.x = Math.floor(Math.sqrt(xe / x)),
                                G.x <= 0 && (G.x = 1),
                                ye && ye < G.x && (G.x = ye),
                                G.x % 2 == 0 && G.x--,
                                K.x = G.x * Te,
                                G.y = 1 + 2 * Math.ceil((G.x * x - 1) / 2),
                                K.y = Math.round(K.x * x),
                                (G.y * G.x > xe || ye && ye < G.y) && (ye && ye < G.y ? (G.y = ye,
                                G.y % 2 == 0 && G.x--) : G.y -= 2,
                                K.y = G.y * Te,
                                G.x = 1 + 2 * Math.ceil((G.y / x - 1) / 2),
                                K.x = Math.round(K.y / x)),
                                {
                                    height: K.y,
                                    width: K.x,
                                    hideYDots: G.y,
                                    hideXDots: G.x
                                }
                            }({
                                originalWidth: this._image.width,
                                originalHeight: this._image.height,
                                maxHiddenDots: ae,
                                maxHiddenAxisDots: v - 14,
                                dotSize: C
                            })
                        }
                        this.drawBackground(),
                        this.drawDots( (ue, X) => {
                            var ne, ae, ce, le, xe, ye;
                            return !(this._options.imageOptions.hideBackgroundDots && ue >= (v - Y.hideYDots) / 2 && ue < (v + Y.hideYDots) / 2 && X >= (v - Y.hideXDots) / 2 && X < (v + Y.hideXDots) / 2 || !((ne = S[ue]) === null || ne === void 0) && ne[X] || !((ae = S[ue - v + 7]) === null || ae === void 0) && ae[X] || !((ce = S[ue]) === null || ce === void 0) && ce[X - v + 7] || !((le = w[ue]) === null || le === void 0) && le[X] || !((xe = w[ue - v + 7]) === null || xe === void 0) && xe[X] || !((ye = w[ue]) === null || ye === void 0) && ye[X - v + 7])
                        }
                        ),
                        this.drawCorners(),
                        this._options.image && await this.drawImage({
                            width: Y.width,
                            height: Y.height,
                            count: v,
                            dotSize: C
                        })
                    }
                    drawBackground() {
                        var y, v, L;
                        const R = this._element
                          , C = this._options;
                        if (R) {
                            const Y = (y = C.backgroundOptions) === null || y === void 0 ? void 0 : y.gradient
                              , ue = (v = C.backgroundOptions) === null || v === void 0 ? void 0 : v.color;
                            let X = C.height
                              , ne = C.width;
                            if (Y || ue) {
                                const ae = this._window.document.createElementNS("http://www.w3.org/2000/svg", "rect");
                                this._backgroundClipPath = this._window.document.createElementNS("http://www.w3.org/2000/svg", "clipPath"),
                                this._backgroundClipPath.setAttribute("id", `clip-path-background-color-${this._instanceId}`),
                                this._defs.appendChild(this._backgroundClipPath),
                                !((L = C.backgroundOptions) === null || L === void 0) && L.round && (X = ne = Math.min(C.width, C.height),
                                ae.setAttribute("rx", String(X / 2 * C.backgroundOptions.round))),
                                ae.setAttribute("x", String(this._roundSize((C.width - ne) / 2))),
                                ae.setAttribute("y", String(this._roundSize((C.height - X) / 2))),
                                ae.setAttribute("width", String(ne)),
                                ae.setAttribute("height", String(X)),
                                this._backgroundClipPath.appendChild(ae),
                                this._createColor({
                                    options: Y,
                                    color: ue,
                                    additionalRotation: 0,
                                    x: 0,
                                    y: 0,
                                    height: C.height,
                                    width: C.width,
                                    name: `background-color-${this._instanceId}`
                                })
                            }
                        }
                    }
                    drawDots(y) {
                        var v, L;
                        if (!this._qr)
                            throw "QR code is not defined";
                        const R = this._options
                          , C = this._qr.getModuleCount();
                        if (C > R.width || C > R.height)
                            throw "The canvas is too small.";
                        const Y = Math.min(R.width, R.height) - 2 * R.margin
                          , ue = R.shape === p ? Y / Math.sqrt(2) : Y
                          , X = this._roundSize(ue / C)
                          , ne = this._roundSize((R.width - C * X) / 2)
                          , ae = this._roundSize((R.height - C * X) / 2)
                          , ce = new u({
                            svg: this._element,
                            type: R.dotsOptions.type,
                            window: this._window
                        });
                        this._dotsClipPath = this._window.document.createElementNS("http://www.w3.org/2000/svg", "clipPath"),
                        this._dotsClipPath.setAttribute("id", `clip-path-dot-color-${this._instanceId}`),
                        this._defs.appendChild(this._dotsClipPath),
                        this._createColor({
                            options: (v = R.dotsOptions) === null || v === void 0 ? void 0 : v.gradient,
                            color: R.dotsOptions.color,
                            additionalRotation: 0,
                            x: 0,
                            y: 0,
                            height: R.height,
                            width: R.width,
                            name: `dot-color-${this._instanceId}`
                        });
                        for (let le = 0; le < C; le++)
                            for (let xe = 0; xe < C; xe++)
                                y && !y(le, xe) || !((L = this._qr) === null || L === void 0) && L.isDark(le, xe) && (ce.draw(ne + xe * X, ae + le * X, X, (ye, Te) => !(xe + ye < 0 || le + Te < 0 || xe + ye >= C || le + Te >= C) && !(y && !y(le + Te, xe + ye)) && !!this._qr && this._qr.isDark(le + Te, xe + ye)),
                                ce._element && this._dotsClipPath && this._dotsClipPath.appendChild(ce._element));
                        if (R.shape === p) {
                            const le = this._roundSize((Y / X - C) / 2)
                              , xe = C + 2 * le
                              , ye = ne - le * X
                              , Te = ae - le * X
                              , G = []
                              , K = this._roundSize(xe / 2);
                            for (let x = 0; x < xe; x++) {
                                G[x] = [];
                                for (let V = 0; V < xe; V++)
                                    x >= le - 1 && x <= xe - le && V >= le - 1 && V <= xe - le || Math.sqrt((x - K) * (x - K) + (V - K) * (V - K)) > K ? G[x][V] = 0 : G[x][V] = this._qr.isDark(V - 2 * le < 0 ? V : V >= C ? V - 2 * le : V - le, x - 2 * le < 0 ? x : x >= C ? x - 2 * le : x - le) ? 1 : 0
                            }
                            for (let x = 0; x < xe; x++)
                                for (let V = 0; V < xe; V++)
                                    G[x][V] && (ce.draw(ye + V * X, Te + x * X, X, (W, oe) => {
                                        var $;
                                        return !!(!(($ = G[x + oe]) === null || $ === void 0) && $[V + W])
                                    }
                                    ),
                                    ce._element && this._dotsClipPath && this._dotsClipPath.appendChild(ce._element))
                        }
                    }
                    drawCorners() {
                        if (!this._qr)
                            throw "QR code is not defined";
                        const y = this._element
                          , v = this._options;
                        if (!y)
                            throw "Element code is not defined";
                        const L = this._qr.getModuleCount()
                          , R = Math.min(v.width, v.height) - 2 * v.margin
                          , C = v.shape === p ? R / Math.sqrt(2) : R
                          , Y = this._roundSize(C / L)
                          , ue = 7 * Y
                          , X = 3 * Y
                          , ne = this._roundSize((v.width - L * Y) / 2)
                          , ae = this._roundSize((v.height - L * Y) / 2);
                        [[0, 0, 0], [1, 0, Math.PI / 2], [0, 1, -Math.PI / 2]].forEach( ([ce,le,xe]) => {
                            var ye, Te, G, K, x, V, W, oe, $, me, he, ge, De, N;
                            const M = ne + ce * Y * (L - 7)
                              , q = ae + le * Y * (L - 7);
                            let J = this._dotsClipPath
                              , ee = this._dotsClipPath;
                            if ((!((ye = v.cornersSquareOptions) === null || ye === void 0) && ye.gradient || !((Te = v.cornersSquareOptions) === null || Te === void 0) && Te.color) && (J = this._window.document.createElementNS("http://www.w3.org/2000/svg", "clipPath"),
                            J.setAttribute("id", `clip-path-corners-square-color-${ce}-${le}-${this._instanceId}`),
                            this._defs.appendChild(J),
                            this._cornersSquareClipPath = this._cornersDotClipPath = ee = J,
                            this._createColor({
                                options: (G = v.cornersSquareOptions) === null || G === void 0 ? void 0 : G.gradient,
                                color: (K = v.cornersSquareOptions) === null || K === void 0 ? void 0 : K.color,
                                additionalRotation: xe,
                                x: M,
                                y: q,
                                height: ue,
                                width: ue,
                                name: `corners-square-color-${ce}-${le}-${this._instanceId}`
                            })),
                            ((x = v.cornersSquareOptions) === null || x === void 0 ? void 0 : x.type) && d.includes(v.cornersSquareOptions.type)) {
                                const te = new f({
                                    svg: this._element,
                                    type: v.cornersSquareOptions.type,
                                    window: this._window
                                });
                                te.draw(M, q, ue, xe),
                                te._element && J && J.appendChild(te._element)
                            } else {
                                const te = new u({
                                    svg: this._element,
                                    type: ((V = v.cornersSquareOptions) === null || V === void 0 ? void 0 : V.type) || v.dotsOptions.type,
                                    window: this._window
                                });
                                for (let we = 0; we < S.length; we++)
                                    for (let de = 0; de < S[we].length; de++)
                                        !((W = S[we]) === null || W === void 0) && W[de] && (te.draw(M + de * Y, q + we * Y, Y, (Ee, Pe) => {
                                            var fe;
                                            return !!(!((fe = S[we + Pe]) === null || fe === void 0) && fe[de + Ee])
                                        }
                                        ),
                                        te._element && J && J.appendChild(te._element))
                            }
                            if ((!((oe = v.cornersDotOptions) === null || oe === void 0) && oe.gradient || !(($ = v.cornersDotOptions) === null || $ === void 0) && $.color) && (ee = this._window.document.createElementNS("http://www.w3.org/2000/svg", "clipPath"),
                            ee.setAttribute("id", `clip-path-corners-dot-color-${ce}-${le}-${this._instanceId}`),
                            this._defs.appendChild(ee),
                            this._cornersDotClipPath = ee,
                            this._createColor({
                                options: (me = v.cornersDotOptions) === null || me === void 0 ? void 0 : me.gradient,
                                color: (he = v.cornersDotOptions) === null || he === void 0 ? void 0 : he.color,
                                additionalRotation: xe,
                                x: M + 2 * Y,
                                y: q + 2 * Y,
                                height: X,
                                width: X,
                                name: `corners-dot-color-${ce}-${le}-${this._instanceId}`
                            })),
                            ((ge = v.cornersDotOptions) === null || ge === void 0 ? void 0 : ge.type) && g.includes(v.cornersDotOptions.type)) {
                                const te = new A({
                                    svg: this._element,
                                    type: v.cornersDotOptions.type,
                                    window: this._window
                                });
                                te.draw(M + 2 * Y, q + 2 * Y, X, xe),
                                te._element && ee && ee.appendChild(te._element)
                            } else {
                                const te = new u({
                                    svg: this._element,
                                    type: ((De = v.cornersDotOptions) === null || De === void 0 ? void 0 : De.type) || v.dotsOptions.type,
                                    window: this._window
                                });
                                for (let we = 0; we < w.length; we++)
                                    for (let de = 0; de < w[we].length; de++)
                                        !((N = w[we]) === null || N === void 0) && N[de] && (te.draw(M + de * Y, q + we * Y, Y, (Ee, Pe) => {
                                            var fe;
                                            return !!(!((fe = w[we + Pe]) === null || fe === void 0) && fe[de + Ee])
                                        }
                                        ),
                                        te._element && ee && ee.appendChild(te._element))
                            }
                        }
                        )
                    }
                    loadImage() {
                        return new Promise( (y, v) => {
                            var L;
                            const R = this._options;
                            if (!R.image)
                                return v("Image is not defined");
                            if (!((L = R.nodeCanvas) === null || L === void 0) && L.loadImage)
                                R.nodeCanvas.loadImage(R.image).then(C => {
                                    var Y, ue;
                                    if (this._image = C,
                                    this._options.imageOptions.saveAsBlob) {
                                        const X = (Y = R.nodeCanvas) === null || Y === void 0 ? void 0 : Y.createCanvas(this._image.width, this._image.height);
                                        (ue = X == null ? void 0 : X.getContext("2d")) === null || ue === void 0 || ue.drawImage(C, 0, 0),
                                        this._imageUri = X == null ? void 0 : X.toDataURL()
                                    }
                                    y()
                                }
                                ).catch(v);
                            else {
                                const C = new this._window.Image;
                                typeof R.imageOptions.crossOrigin == "string" && (C.crossOrigin = R.imageOptions.crossOrigin),
                                this._image = C,
                                C.onload = async () => {
                                    this._options.imageOptions.saveAsBlob && (this._imageUri = await async function(Y, ue) {
                                        return new Promise(X => {
                                            const ne = new ue.XMLHttpRequest;
                                            ne.onload = function() {
                                                const ae = new ue.FileReader;
                                                ae.onloadend = function() {
                                                    X(ae.result)
                                                }
                                                ,
                                                ae.readAsDataURL(ne.response)
                                            }
                                            ,
                                            ne.open("GET", Y),
                                            ne.responseType = "blob",
                                            ne.send()
                                        }
                                        )
                                    }(R.image || "", this._window)),
                                    y()
                                }
                                ,
                                C.src = R.image
                            }
                        }
                        )
                    }
                    async drawImage({width: y, height: v, count: L, dotSize: R}) {
                        const C = this._options
                          , Y = this._roundSize((C.width - L * R) / 2)
                          , ue = this._roundSize((C.height - L * R) / 2)
                          , X = Y + this._roundSize(C.imageOptions.margin + (L * R - y) / 2)
                          , ne = ue + this._roundSize(C.imageOptions.margin + (L * R - v) / 2)
                          , ae = y - 2 * C.imageOptions.margin
                          , ce = v - 2 * C.imageOptions.margin
                          , le = this._window.document.createElementNS("http://www.w3.org/2000/svg", "image");
                        le.setAttribute("href", this._imageUri || ""),
                        le.setAttribute("xlink:href", this._imageUri || ""),
                        le.setAttribute("x", String(X)),
                        le.setAttribute("y", String(ne)),
                        le.setAttribute("width", `${ae}px`),
                        le.setAttribute("height", `${ce}px`),
                        this._element.appendChild(le)
                    }
                    _createColor({options: y, color: v, additionalRotation: L, x: R, y: C, height: Y, width: ue, name: X}) {
                        const ne = ue > Y ? ue : Y
                          , ae = this._window.document.createElementNS("http://www.w3.org/2000/svg", "rect");
                        if (ae.setAttribute("x", String(R)),
                        ae.setAttribute("y", String(C)),
                        ae.setAttribute("height", String(Y)),
                        ae.setAttribute("width", String(ue)),
                        ae.setAttribute("clip-path", `url('#clip-path-${X}')`),
                        y) {
                            let ce;
                            if (y.type === "radial")
                                ce = this._window.document.createElementNS("http://www.w3.org/2000/svg", "radialGradient"),
                                ce.setAttribute("id", X),
                                ce.setAttribute("gradientUnits", "userSpaceOnUse"),
                                ce.setAttribute("fx", String(R + ue / 2)),
                                ce.setAttribute("fy", String(C + Y / 2)),
                                ce.setAttribute("cx", String(R + ue / 2)),
                                ce.setAttribute("cy", String(C + Y / 2)),
                                ce.setAttribute("r", String(ne / 2));
                            else {
                                const le = ((y.rotation || 0) + L) % (2 * Math.PI)
                                  , xe = (le + 2 * Math.PI) % (2 * Math.PI);
                                let ye = R + ue / 2
                                  , Te = C + Y / 2
                                  , G = R + ue / 2
                                  , K = C + Y / 2;
                                xe >= 0 && xe <= .25 * Math.PI || xe > 1.75 * Math.PI && xe <= 2 * Math.PI ? (ye -= ue / 2,
                                Te -= Y / 2 * Math.tan(le),
                                G += ue / 2,
                                K += Y / 2 * Math.tan(le)) : xe > .25 * Math.PI && xe <= .75 * Math.PI ? (Te -= Y / 2,
                                ye -= ue / 2 / Math.tan(le),
                                K += Y / 2,
                                G += ue / 2 / Math.tan(le)) : xe > .75 * Math.PI && xe <= 1.25 * Math.PI ? (ye += ue / 2,
                                Te += Y / 2 * Math.tan(le),
                                G -= ue / 2,
                                K -= Y / 2 * Math.tan(le)) : xe > 1.25 * Math.PI && xe <= 1.75 * Math.PI && (Te += Y / 2,
                                ye += ue / 2 / Math.tan(le),
                                K -= Y / 2,
                                G -= ue / 2 / Math.tan(le)),
                                ce = this._window.document.createElementNS("http://www.w3.org/2000/svg", "linearGradient"),
                                ce.setAttribute("id", X),
                                ce.setAttribute("gradientUnits", "userSpaceOnUse"),
                                ce.setAttribute("x1", String(Math.round(ye))),
                                ce.setAttribute("y1", String(Math.round(Te))),
                                ce.setAttribute("x2", String(Math.round(G))),
                                ce.setAttribute("y2", String(Math.round(K)))
                            }
                            y.colorStops.forEach( ({offset: le, color: xe}) => {
                                const ye = this._window.document.createElementNS("http://www.w3.org/2000/svg", "stop");
                                ye.setAttribute("offset", 100 * le + "%"),
                                ye.setAttribute("stop-color", xe),
                                ce.appendChild(ye)
                            }
                            ),
                            ae.setAttribute("fill", `url('#${X}')`),
                            this._defs.appendChild(ce)
                        } else
                            v && ae.setAttribute("fill", v);
                        this._element.appendChild(ae)
                    }
                }
                b.instanceCount = 0;
                const B = b
                  , z = "canvas"
                  , I = {};
                for (let O = 0; O <= 40; O++)
                    I[O] = O;
                const H = {
                    type: z,
                    shape: "square",
                    width: 300,
                    height: 300,
                    data: "",
                    margin: 0,
                    qrOptions: {
                        typeNumber: I[0],
                        mode: void 0,
                        errorCorrectionLevel: "Q"
                    },
                    imageOptions: {
                        saveAsBlob: !0,
                        hideBackgroundDots: !0,
                        imageSize: .4,
                        crossOrigin: void 0,
                        margin: 0
                    },
                    dotsOptions: {
                        type: "square",
                        color: "#000",
                        roundSize: !0
                    },
                    backgroundOptions: {
                        round: 0,
                        color: "#fff"
                    }
                };
                function P(O) {
                    const y = Object.assign({}, O);
                    if (!y.colorStops || !y.colorStops.length)
                        throw "Field 'colorStops' is required in gradient";
                    return y.rotation ? y.rotation = Number(y.rotation) : y.rotation = 0,
                    y.colorStops = y.colorStops.map(v => Object.assign(Object.assign({}, v), {
                        offset: Number(v.offset)
                    })),
                    y
                }
                function T(O) {
                    const y = Object.assign({}, O);
                    return y.width = Number(y.width),
                    y.height = Number(y.height),
                    y.margin = Number(y.margin),
                    y.imageOptions = Object.assign(Object.assign({}, y.imageOptions), {
                        hideBackgroundDots: !!y.imageOptions.hideBackgroundDots,
                        imageSize: Number(y.imageOptions.imageSize),
                        margin: Number(y.imageOptions.margin)
                    }),
                    y.margin > Math.min(y.width, y.height) && (y.margin = Math.min(y.width, y.height)),
                    y.dotsOptions = Object.assign({}, y.dotsOptions),
                    y.dotsOptions.gradient && (y.dotsOptions.gradient = P(y.dotsOptions.gradient)),
                    y.cornersSquareOptions && (y.cornersSquareOptions = Object.assign({}, y.cornersSquareOptions),
                    y.cornersSquareOptions.gradient && (y.cornersSquareOptions.gradient = P(y.cornersSquareOptions.gradient))),
                    y.cornersDotOptions && (y.cornersDotOptions = Object.assign({}, y.cornersDotOptions),
                    y.cornersDotOptions.gradient && (y.cornersDotOptions.gradient = P(y.cornersDotOptions.gradient))),
                    y.backgroundOptions && (y.backgroundOptions = Object.assign({}, y.backgroundOptions),
                    y.backgroundOptions.gradient && (y.backgroundOptions.gradient = P(y.backgroundOptions.gradient))),
                    y
                }
                var _ = i(873)
                  , re = i.n(_);
                function k(O) {
                    if (!O)
                        throw new Error("Extension must be defined");
                    O[0] === "." && (O = O.substring(1));
                    const y = {
                        bmp: "image/bmp",
                        gif: "image/gif",
                        ico: "image/vnd.microsoft.icon",
                        jpeg: "image/jpeg",
                        jpg: "image/jpeg",
                        png: "image/png",
                        svg: "image/svg+xml",
                        tif: "image/tiff",
                        tiff: "image/tiff",
                        webp: "image/webp",
                        pdf: "application/pdf"
                    }[O.toLowerCase()];
                    if (!y)
                        throw new Error(`Extension "${O}" is not supported`);
                    return y
                }
                class U {
                    constructor(y) {
                        y != null && y.jsdom ? this._window = new y.jsdom("",{
                            resources: "usable"
                        }).window : this._window = window,
                        this._options = y ? T(a(H, y)) : H,
                        this.update()
                    }
                    static _clearContainer(y) {
                        y && (y.innerHTML = "")
                    }
                    _setupSvg() {
                        if (!this._qr)
                            return;
                        const y = new B(this._options,this._window);
                        this._svg = y.getElement(),
                        this._svgDrawingPromise = y.drawQR(this._qr).then( () => {
                            var v;
                            this._svg && ((v = this._extension) === null || v === void 0 || v.call(this, y.getElement(), this._options))
                        }
                        )
                    }
                    _setupCanvas() {
                        var y, v;
                        this._qr && (!((y = this._options.nodeCanvas) === null || y === void 0) && y.createCanvas ? (this._nodeCanvas = this._options.nodeCanvas.createCanvas(this._options.width, this._options.height),
                        this._nodeCanvas.width = this._options.width,
                        this._nodeCanvas.height = this._options.height) : (this._domCanvas = document.createElement("canvas"),
                        this._domCanvas.width = this._options.width,
                        this._domCanvas.height = this._options.height),
                        this._setupSvg(),
                        this._canvasDrawingPromise = (v = this._svgDrawingPromise) === null || v === void 0 ? void 0 : v.then( () => {
                            var L;
                            if (!this._svg)
                                return;
                            const R = this._svg
                              , C = new this._window.XMLSerializer().serializeToString(R)
                              , Y = btoa(C)
                              , ue = `data:${k("svg")};base64,${Y}`;
                            if (!((L = this._options.nodeCanvas) === null || L === void 0) && L.loadImage)
                                return this._options.nodeCanvas.loadImage(ue).then(X => {
                                    var ne, ae;
                                    X.width = this._options.width,
                                    X.height = this._options.height,
                                    (ae = (ne = this._nodeCanvas) === null || ne === void 0 ? void 0 : ne.getContext("2d")) === null || ae === void 0 || ae.drawImage(X, 0, 0)
                                }
                                );
                            {
                                const X = new this._window.Image;
                                return new Promise(ne => {
                                    X.onload = () => {
                                        var ae, ce;
                                        (ce = (ae = this._domCanvas) === null || ae === void 0 ? void 0 : ae.getContext("2d")) === null || ce === void 0 || ce.drawImage(X, 0, 0),
                                        ne()
                                    }
                                    ,
                                    X.src = ue
                                }
                                )
                            }
                        }
                        ))
                    }
                    async _getElement(y="png") {
                        if (!this._qr)
                            throw "QR code is empty";
                        return y.toLowerCase() === "svg" ? (this._svg && this._svgDrawingPromise || this._setupSvg(),
                        await this._svgDrawingPromise,
                        this._svg) : ((this._domCanvas || this._nodeCanvas) && this._canvasDrawingPromise || this._setupCanvas(),
                        await this._canvasDrawingPromise,
                        this._domCanvas || this._nodeCanvas)
                    }
                    update(y) {
                        U._clearContainer(this._container),
                        this._options = y ? T(a(this._options, y)) : this._options,
                        this._options.data && (this._qr = re()(this._options.qrOptions.typeNumber, this._options.qrOptions.errorCorrectionLevel),
                        this._qr.addData(this._options.data, this._options.qrOptions.mode || function(v) {
                            switch (!0) {
                            case /^[0-9]*$/.test(v):
                                return "Numeric";
                            case /^[0-9A-Z $%*+\-./:]*$/.test(v):
                                return "Alphanumeric";
                            default:
                                return "Byte"
                            }
                        }(this._options.data)),
                        this._qr.make(),
                        this._options.type === z ? this._setupCanvas() : this._setupSvg(),
                        this.append(this._container))
                    }
                    append(y) {
                        if (y) {
                            if (typeof y.appendChild != "function")
                                throw "Container should be a single DOM node";
                            this._options.type === z ? this._domCanvas && y.appendChild(this._domCanvas) : this._svg && y.appendChild(this._svg),
                            this._container = y
                        }
                    }
                    applyExtension(y) {
                        if (!y)
                            throw "Extension function should be defined.";
                        this._extension = y,
                        this.update()
                    }
                    deleteExtension() {
                        this._extension = void 0,
                        this.update()
                    }
                    async getRawData(y="png") {
                        if (!this._qr)
                            throw "QR code is empty";
                        const v = await this._getElement(y)
                          , L = k(y);
                        if (!v)
                            return null;
                        if (y.toLowerCase() === "svg") {
                            const R = `<?xml version="1.0" standalone="no"?>\r
${new this._window.XMLSerializer().serializeToString(v)}`;
                            return typeof Blob > "u" || this._options.jsdom ? Buffer.from(R) : new Blob([R],{
                                type: L
                            })
                        }
                        return new Promise(R => {
                            const C = v;
                            if ("toBuffer"in C)
                                if (L === "image/png")
                                    R(C.toBuffer(L));
                                else if (L === "image/jpeg")
                                    R(C.toBuffer(L));
                                else {
                                    if (L !== "application/pdf")
                                        throw Error("Unsupported extension");
                                    R(C.toBuffer(L))
                                }
                            else
                                "toBlob"in C && C.toBlob(R, L, 1)
                        }
                        )
                    }
                    async download(y) {
                        if (!this._qr)
                            throw "QR code is empty";
                        if (typeof Blob > "u")
                            throw "Cannot download in Node.js, call getRawData instead.";
                        let v = "png"
                          , L = "qr";
                        typeof y == "string" ? (v = y,
                        console.warn("Extension is deprecated as argument for 'download' method, please pass object { name: '...', extension: '...' } as argument")) : typeof y == "object" && y !== null && (y.name && (L = y.name),
                        y.extension && (v = y.extension));
                        const R = await this._getElement(v);
                        if (R)
                            if (v.toLowerCase() === "svg") {
                                let C = new XMLSerializer().serializeToString(R);
                                C = `<?xml version="1.0" standalone="no"?>\r
` + C,
                                c(`data:${k(v)};charset=utf-8,${encodeURIComponent(C)}`, `${L}.svg`)
                            } else
                                c(R.toDataURL(k(v)), `${L}.${v}`)
                    }
                }
                const F = U
            }
            )(),
            s.default
        }
        )())
    }(Ur)),
    Ur.exports
}
var px = fx();
const mx = ah(px)
  , Ax = {
    type: "canvas",
    shape: "square",
    width: 400,
    height: 400,
    data: "https://spacer.land",
    margin: 30,
    qrOptions: {
        typeNumber: 0,
        mode: "Byte",
        errorCorrectionLevel: "H"
    },
    imageOptions: {
        saveAsBlob: !0,
        hideBackgroundDots: !0,
        imageSize: .4,
        margin: 0
    },
    dotsOptions: {
        type: "dots",
        color: "#6a1a4c",
        roundSize: !0,
        gradient: {
            type: "linear",
            rotation: 1.5707963267948966,
            colorStops: [{
                offset: 0,
                color: "#a0c03e"
            }, {
                offset: 1,
                color: "#4d8300"
            }]
        }
    },
    backgroundOptions: {
        round: 0,
        color: "#232323"
    },
    image: "data:image/png;base64,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",
    cornersSquareOptions: {
        type: "extra-rounded",
        color: "#a2be38",
        gradient: void 0
    },
    cornersDotOptions: {
        type: "dot",
        color: "#a4bc31"
    }
};
class gx {
    constructor() {
        this.areaUnitState = "sqYard",
        this.displayStatusBtn = !1,
        this.mapView = !1,
        this.qrCode = new mx(Ax),
        this.includeStatusInSharing = !0
    }
    handleInMapViewMode() {
        Ie.Map.getTilt() == 0 ? Ie.Map.setTilt(60) : Ie.Map.setTilt(0)
    }
    goToMapHome() {
        var e, t, n;
        Ie.Map.setCenter({
            lat: (e = Ie.ProjectData) == null ? void 0 : e.latitude,
            lng: (t = Ie.ProjectData) == null ? void 0 : t.longitude
        }),
        Ie.Map.setZoom((n = Ie.ProjectData) == null ? void 0 : n.mapOverlayZoom)
    }
    handleViewMode(e) {
        e.isLerping || (e.In3DView ? e.exit3DMode() : e.enter3DMode(31))
    }
    setProjectInfo(e, t, n, i, s, o) {
        if (document.getElementById("clientLogo").src = e,
        document.getElementById("projectInfoText").innerText = t,
        n > 0 && (document.getElementById("projectTotalArea").innerHTML = `<span class="areaTitle">Total Area:</span> ${n} <span class="areaUnit">sq.Yard</span>`),
        s) {
            const a = Object.keys(s);
            let c;
            a.forEach(l => {
                switch (l) {
                case "instagram":
                    c = document.getElementById("instagram"),
                    c.classList.add("active"),
                    c.href = s[l];
                    break;
                case "facebook":
                    c = document.getElementById("facebook"),
                    c.classList.add("active"),
                    c.href = s[l];
                    break;
                case "call":
                    c = document.getElementById("call"),
                    c.classList.add("active"),
                    c.href = `tel:${s[l]}`;
                    break;
                case "website":
                    c = document.getElementById("website"),
                    c.classList.add("active"),
                    c.href = s[l];
                    break;
                case "whatsapp":
                    c = document.getElementById("whatsapp"),
                    c.classList.add("active"),
                    c.href = `https://api.whatsapp.com/send?phone=91${s[l]}&text=Hi, I'm interested in *${o}* could you please share the details?`;
                    break;
                case "mail":
                    c = document.getElementById("mail"),
                    c.classList.add("active"),
                    c.href = s[l];
                    break
                }
            }
            )
        }
    }
    updateGoogleMapLocation(e) {
        const t = document.getElementById("locate");
        e && t ? t.href = e : t.classList.add("disable")
    }
    loadImages(e) {
        const t = document.getElementById("imageContainer");
        e.sort( (s, o) => s.toLowerCase().localeCompare(o.toLowerCase())),
        e && e.length > 0 ? e.forEach( (s, o) => {
            const a = document.createElement("a");
            a.classList.add("imgContainer"),
            a.classList.add("shimmer"),
            a.style.overflow = "hidden",
            a.href = s,
            a.target = "blank";
            const c = document.createElement("img");
            c.id = `image${o}`,
            c.src = s,
            c.style.objectFit = "cover",
            c.onload = () => {
                a.dataset.pswpWidth = c.naturalWidth.toString(),
                a.dataset.pswpHeight = c.naturalHeight.toString(),
                a.classList.remove("shimmer")
            }
            ,
            c.src = s,
            c.complete && (a.dataset.pswpWidth = c.naturalWidth.toString(),
            a.dataset.pswpHeight = c.naturalHeight.toString(),
            a.classList.remove("shimmer")),
            a.appendChild(c),
            t.appendChild(a)
        }
        ) : document.getElementById("gallery").classList.add("disable");
        const n = {
            gallery: "#imageContainer",
            children: "a",
            showHideAnimationType: "zoom",
            secondaryZoomLevel: 2,
            pswpModule: () => J0( () => import("../photoswipe.esm-DXWKOczD.js"), [])
        };
        new hx(n).init()
    }
    SetClientLogo(e) {
        const t = document.getElementById("headerIcon");
        t.src = e;
        const n = document.getElementById("clientLogoHeader")
          , i = document.getElementsByClassName("skeleton-container")[0];
        n.style.display = "flex",
        i.style.display = "none"
    }
    normalize(e) {
        return e.replace(/[^a-z0-9]/gi, "")
    }
    handleSearchInput(e, t=new Map, n=new Map) {
        const i = e.target.value.trim()
          , s = document.getElementById("searchTray");
        if (i === "") {
            s == null || s.classList.remove("error");
            return
        }
        let o;
        if (i.toLowerCase()in t)
            o = t[i.toLowerCase()];
        else {
            const a = Object.keys(n)
              , c = a.find(l => l.toLowerCase() === i.toLowerCase()) || a.find(l => l.toLowerCase().includes(i.toLowerCase())) || a.find(l => this.normalize(l.toLowerCase()) === this.normalize(i.toLowerCase())) || a.find(l => this.normalize(l.toLowerCase()).includes(this.normalize(i.toLowerCase())));
            c && (o = n[c])
        }
        o ? s == null || s.classList.remove("error") : s == null || s.classList.add("error")
    }
    handleSearchKeyPress(e, t, n, i, s, o, a, c, l, u) {
        if (e.key !== "Enter")
            return;
        const h = document.getElementById("searchTray")
          , d = e.target.value.trim();
        if (!d || d === "0")
            return;
        let f;
        if (d.toLowerCase()in t)
            f = t[d.toLowerCase()];
        else {
            const g = Object.keys(n)
              , A = g.find(p => p.toLowerCase() === d.toLowerCase()) || g.find(p => p.toLowerCase().includes(d.toLowerCase())) || g.find(p => this.normalize(p.toLowerCase()) === this.normalize(d.toLowerCase())) || g.find(p => this.normalize(p.toLowerCase()).includes(this.normalize(d.toLowerCase())));
            if (A) {
                if (Ie.isProcessing)
                    return;
                Ie.isProcessing = !0,
                f = n[A]
            }
        }
        const m = o.getPlotMesh(f.name);
        m && (s = m),
        o.selectPlot(f.name, a, c, this.displayStatusBtn, l.camera, u),
        s ? (e.target.blur(),
        l.goToPlot(s),
        this.clearInput()) : h == null || h.classList.add("error")
    }
    handleSearchInputBlur(e, t, n, i, s, o, a, c, l, u) {
        const h = e.target.value.trim()
          , d = document.getElementById("searchTray");
        if (!h || h === "0")
            return;
        let f;
        if (h.toLowerCase()in t)
            f = t[h.toLowerCase()];
        else {
            const g = Object.keys(n)
              , A = g.find(p => p.toLowerCase() === h.toLowerCase()) || g.find(p => p.toLowerCase().includes(h.toLowerCase())) || g.find(p => this.normalize(p.toLowerCase()) === this.normalize(h.toLowerCase())) || g.find(p => this.normalize(p.toLowerCase()).includes(this.normalize(h.toLowerCase())));
            if (A) {
                if (Ie.isProcessing)
                    return;
                Ie.isProcessing = !0,
                f = n[A]
            }
        }
        const m = o.getPlotMesh(f.name);
        m && (s = m),
        o.selectPlot(f.name, a, c, this.displayStatusBtn, l.camera, u),
        s ? (l.goToPlot(s),
        this.clearInput()) : d == null || d.classList.add("error")
    }
    async handleShareBtn(e, t, n) {
        var a;
        this.updateQrCode(e, t, n);
        const i = document.getElementById("overlay")
          , s = document.getElementById("shareContainer");
        i.classList.add("active"),
        i.style.display = "flex";
        let o = document.getElementById("qr-code");
        o ? o.innerHTML = "" : (o = document.createElement("div"),
        o.id = "qr-code",
        s.appendChild(o)),
        this.qrCode.append(o),
        this.displayStatusBtn || (a = document.getElementById("include-status-container")) == null || a.remove(),
        s.style.display = "flex",
        requestAnimationFrame( () => {
            s.classList.add("active")
        }
        ),
        this.activeView = s
    }
    async createAndShareImage(e, t) {
        const a = "#232323"
          , c = `SCAN TO KNOW MORE ABOUT ${t.toUpperCase()}`
          , l = "ON SPACER"
          , u = 41
          , h = "#FFFFFF"
          , d = T => new Promise( (_, re) => {
            const k = new Image;
            k.crossOrigin = "anonymous",
            k.onload = () => _(k),
            k.onerror = re,
            T instanceof Blob ? k.src = URL.createObjectURL(T) : k.src = T
        }
        )
          , f = await this.qrCode.getRawData("png")
          , [m,g] = await Promise.all([d(e), d(f)])
          , A = m.height / m.width * 441
          , p = g.height / g.width * 630
          , S = u * 2 + 40
          , w = 200 * 2 + A + p + S + 130 * 2
          , b = 630 + 200 * 2
          , B = document.createElement("canvas");
        B.width = b,
        B.height = w;
        const z = B.getContext("2d");
        z.fillStyle = a,
        z.fillRect(0, 0, B.width, B.height);
        const I = (T, _, re) => {
            const k = (B.width - _) / 2
              , U = T.height / T.width * _;
            return z.drawImage(T, k, re, _, U),
            U
        }
        ;
        let H = 200;
        H += I(m, 441, H),
        H += 130,
        H += I(g, 630, H),
        H += 130,
        z.fillStyle = h,
        z.font = `${u}px 'Inria Sans'`,
        z.textAlign = "center",
        z.textBaseline = "top";
        const P = B.width / 2;
        z.fillText(c, P, H),
        H += u + 20,
        z.fillText(l, P, H),
        B.toBlob(async T => {
            const _ = new File([T],`${t}-qr-code.jpg`,{
                type: "image/jpeg"
            });
            if (navigator.canShare && navigator.canShare({
                files: [_]
            }))
                try {
                    await navigator.share({
                        files: [_],
                        title: t,
                        text: `Step inside ${t} with Spacer  an interactive map that makes choosing your perfect plot effortless.
${this.qrCode._options.data}`
                    })
                } catch (re) {
                    console.log("Share failed, downloading instead:", re);
                    const k = document.createElement("a");
                    k.href = B.toDataURL("image/jpeg"),
                    k.download = `${t}-qr-code.jpg`,
                    k.click()
                }
            else {
                const re = document.createElement("a");
                re.href = B.toDataURL("image/jpeg"),
                re.download = `${t}-qr-code.jpg`,
                re.click()
            }
        }
        , "image/jpeg", 1)
    }
    getShareUrl(e, t, n) {
        let i = "";
        const s = document.getElementById("include-statuses");
        return n && s.checked ? i = `https://spacer.land/${t}?status=${n}` : i = `https://spacer.land/${t}`,
        i
    }
    async shareLink(e, t, n) {
        const i = this.getShareUrl(e, t, n);
        try {
            await navigator.share({
                title: "Check this out!",
                text: `Step inside ${e} with Spacer  an interactive map that makes choosing your perfect plot effortless.
`,
                url: i
            })
        } catch (s) {
            _n.trackError("shareLink", s)
        }
    }
    async updateQrCode(e, t, n) {
        const i = this.getShareUrl(e, t, n);
        this.qrCode._options.data = i,
        this.qrCode.update();
        const s = document.getElementById("include-statuses");
        s && s.checked && (this.includeStatusInSharing = !0),
        (!s || s && !s.checked) && (this.includeStatusInSharing = !1)
    }
    async shareQrCode(e, t, n) {
        const i = document.getElementById("loader");
        i.style.display = "inline-block";
        let s = null;
        if (this.includeStatusInSharing && this.cachedQrWithStatus && (s = this.cachedQrWithStatus),
        !this.includeStatusInSharing && this.cachedQrWithoutStatus && (s = this.cachedQrWithoutStatus),
        !s) {
            const o = await this.qrCode.getRawData("png")
              , a = `${e}-spacer-qr-code.png`;
            s = new File([o],a,{
                type: "image/png"
            }),
            this.includeStatusInSharing ? this.cachedQrWithStatus = s : this.cachedQrWithoutStatus = s
        }
        i.style.display = "none",
        navigator.canShare && navigator.canShare({
            files: [s]
        }) ? await navigator.share({
            title: `${e} Spacer.png`,
            files: [s],
            text: `Step inside ${e} with Spacer  an interactive map that makes choosing your perfect plot effortless.
${this.qrCode._options.data}`
        }) : this.downloadQrCode(e, t, n, "png")
    }
    async downloadQrCode(e, t, n, i) {
        if (i == "png" || i == "jpg") {
            const s = URL.createObjectURL(blob)
              , o = document.createElement("a");
            o.href = s,
            o.download = `${e} Spacer.${i}`,
            o.click(),
            URL.revokeObjectURL(s)
        }
        if (i == "svg") {
            const s = await this.qrCode.getRawData("svg")
              , o = URL.createObjectURL(s)
              , a = document.createElement("a");
            a.href = o,
            a.download = `${e} Spacer.svg`,
            a.click(),
            URL.revokeObjectURL(o)
        }
    }
    setCameraToNorth() {
        console.log("northing")
    }
    handleShowMap() {
        var a, c, l, u, h, d, f, m, g, A, p, S, w, b, B;
        const e = document.getElementById("map-container")
          , t = document.getElementById("map")
          , n = document.getElementById("canvas-container")
          , i = document.getElementById("northIndicator")
          , s = document.getElementById("mapNorthIndicator")
          , o = document.getElementById("mapViewModeBtn");
        this.mapView ? (e.classList.remove("fade-in-up"),
        t.classList.remove("fade-in"),
        e.classList.add("fade-out-down"),
        t.classList.add("fade-out"),
        n.classList.remove("fade-out-down"),
        n.classList.add("fade-in-up"),
        (A = document.getElementById("searchTray")) == null || A.classList.remove("disable"),
        (p = document.getElementById("home")) == null || p.classList.remove("disable"),
        (S = document.getElementById("mapHome")) == null || S.classList.add("disable"),
        (w = document.getElementById("viewMode")) == null || w.classList.remove("disable"),
        (b = document.getElementById("inMapViewMode")) == null || b.classList.add("disable"),
        i.style.display = "block",
        s.style.display = "none",
        o.src = "./assets/Icons/mapView.svg",
        this.mapView = !1,
        (B = Ie.spacerApp) == null || B.startRenderLoop(),
        Ie.Map.removeListener(this.mapNorthIndicatorListener)) : (e == null || e.classList.remove("fade-out-down"),
        t == null || t.classList.add("fade-out"),
        e == null || e.classList.add("fade-in-up"),
        t == null || t.classList.add("fade-in"),
        n.classList.add("fade-out-down"),
        (a = document.getElementById("searchTray")) == null || a.classList.add("disable"),
        (c = document.getElementById("home")) == null || c.classList.add("disable"),
        (l = document.getElementById("mapHome")) == null || l.classList.remove("disable"),
        (u = document.getElementById("viewMode")) == null || u.classList.add("disable"),
        (h = document.getElementById("inMapViewMode")) == null || h.classList.remove("disable"),
        Ie.Map.setCenter({
            lat: (d = Ie.ProjectData) == null ? void 0 : d.latitude,
            lng: (f = Ie.ProjectData) == null ? void 0 : f.longitude
        }),
        Ie.Map.setZoom((m = Ie.ProjectData) == null ? void 0 : m.mapOverlayZoom),
        i.style.display = "none",
        s.style.display = "block",
        o.src = "./assets/Icons/spacerView.svg",
        this.mapView = !0,
        (g = Ie.spacerApp) == null || g.stopRenderLoop(),
        this.mapNorthIndicatorListener = Ie.Map.addListener("heading_changed", () => {
            s.style.transform = `rotate(${-Ie.Map.getHeading()}deg)`
        }
        ),
        this.mapNorthIndicatorClickListener || (this.mapNorthIndicatorClickListener = s.addEventListener("click", () => {
            Ie.Map.setHeading(0)
        }
        )))
    }
    async initializeEventListeners(e, t, n, i, s, o, a, c, l, u, h) {
        return new Promise( (d, f) => {
            var A, p, S, w, b, B, z, I, H, P, T, _, re;
            const m = document.getElementById("status");
            m && m.addEventListener("change", k => n.toggleStatusView(k, i, this.displayStatusBtn)),
            (A = document.getElementById("home")) == null || A.addEventListener("click", k => {
                e.goToHome(t)
            }
            ),
            (p = document.getElementById("mapHome")) == null || p.addEventListener("click", k => {
                this.goToMapHome()
            }
            ),
            document.getElementById("viewMode").addEventListener("click", () => this.handleViewMode(e.controls)),
            document.getElementById("inMapViewMode").addEventListener("click", () => this.handleInMapViewMode());
            const g = document.getElementById("plotSearch");
            if (g.addEventListener("input", k => this.handleSearchInput(k, n.numericPlots, n.nonNumericPlots)),
            g.addEventListener("blur", k => this.handleSearchInputBlur(k, n.numericPlots, n.nonNumericPlots, n.activePlotData, n.activePlotMesh, n, s, i, e, h)),
            g.addEventListener("keypress", k => this.handleSearchKeyPress(k, n.numericPlots, n.nonNumericPlots, n.activePlotData, n.activePlotMesh, n, s, i, e, h)),
            (S = document.getElementById("share")) == null || S.addEventListener("click", () => this.handleShareBtn(o, a, c)),
            (w = document.getElementById("share-link")) == null || w.addEventListener("click", () => this.shareLink(o, a, c)),
            (b = document.getElementById("share-qr")) == null || b.addEventListener("click", () => this.shareQrCode(o, a, c)),
            (B = document.getElementById("include-statuses")) == null || B.addEventListener("change", k => this.updateQrCode(o, a, c)),
            (z = document.getElementById("share-qr")) == null || z.addEventListener("click", () => this.shareQrCode(o, a, c)),
            document.getElementById("cross4").addEventListener("click", () => this.closeView()),
            document.getElementById("overlay").addEventListener("click", k => {
                k.target === k.currentTarget && this.closeView()
            }
            ),
            (I = document.getElementById("showMap")) == null || I.addEventListener("click", () => this.handleShowMap()),
            window.addEventListener("resize", () => this.onWindowResize(e.camera, u)),
            (H = document.getElementById("northIndicator")) == null || H.addEventListener("click", () => {
                var k;
                (k = Ie.spacerApp) == null || k.cameraManager.orientCameraToNorth()
            }
            ),
            Ie.IsDebugMode) {
                const k = document.getElementById("plot-color-value")
                  , U = document.getElementById("road-color-value")
                  , F = document.getElementById("grass-color-value")
                  , O = document.getElementById("text-color-value")
                  , y = document.getElementById("boundary-color-value");
                k.value = "#4F99B1",
                U.value = "#494949",
                F.value = "#5F7651",
                O.value = "#FFFFFF",
                (P = St.plot) == null || P.color.set(k.value),
                (T = St.road) == null || T.color.set(U.value),
                (_ = St.grass) == null || _.color.set(F.value),
                (re = St.plot_text) == null || re.color.set(O.value),
                k.addEventListener("input", v => {
                    var R;
                    const L = k.value;
                    (R = St.plot) == null || R.color.set(L)
                }
                ),
                U.addEventListener("input", v => {
                    var R;
                    const L = U.value;
                    (R = St.road) == null || R.color.set(L)
                }
                ),
                F.addEventListener("input", v => {
                    var R;
                    const L = F.value;
                    (R = St.grass) == null || R.color.set(L)
                }
                ),
                O.addEventListener("input", v => {
                    var R;
                    const L = O.value;
                    (R = St.plot_text) == null || R.color.set(L)
                }
                ),
                y.addEventListener("input", v => {
                    var R;
                    const L = y.value;
                    (R = St.boundaries) == null || R.color.set(L)
                }
                )
            }
            d()
        }
        )
    }
    setStatusVisibility(e, t) {
        e === t ? (this.displayStatusBtn = !0,
        document.getElementById("statusContainer").classList.add("show")) : this.displayStatusBtn = !1
    }
    setGetYourSpacerAdVisibility(e) {
        const t = document.getElementById("get-your-spacer-ad");
        e ? t.style.display = "block" : t.style.display = "none"
    }
    closeView() {
        this.activeView && (this.activeView.classList.remove("active"),
        document.getElementById("overlay").classList.remove("active"),
        this.activeView = null)
    }
    clearInput() {
        const e = document.getElementById("plotSearch");
        e.value && (e.value = "")
    }
    onWindowResize(e, t) {
        e.aspect = window.innerWidth / window.innerHeight,
        e.updateProjectionMatrix(),
        t.setSize(window.innerWidth, window.innerHeight)
    }
}
var Br = {
    exports: {}
}, vx = Br.exports, du;
function xx() {
    return du || (du = 1,
    function(r, e) {
        (function(t, n) {
            r.exports = n()
        }
        )(vx, function() {
            var t = function() {
                function n(f) {
                    return o.appendChild(f.dom),
                    f
                }
                function i(f) {
                    for (var m = 0; m < o.children.length; m++)
                        o.children[m].style.display = m === f ? "block" : "none";
                    s = f
                }
                var s = 0
                  , o = document.createElement("div");
                o.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",
                o.addEventListener("click", function(f) {
                    f.preventDefault(),
                    i(++s % o.children.length)
                }, !1);
                var a = (performance || Date).now()
                  , c = a
                  , l = 0
                  , u = n(new t.Panel("FPS","#0ff","#002"))
                  , h = n(new t.Panel("MS","#0f0","#020"));
                if (self.performance && self.performance.memory)
                    var d = n(new t.Panel("MB","#f08","#201"));
                return i(0),
                {
                    REVISION: 16,
                    dom: o,
                    addPanel: n,
                    showPanel: i,
                    begin: function() {
                        a = (performance || Date).now()
                    },
                    end: function() {
                        l++;
                        var f = (performance || Date).now();
                        if (h.update(f - a, 200),
                        f > c + 1e3 && (u.update(1e3 * l / (f - c), 100),
                        c = f,
                        l = 0,
                        d)) {
                            var m = performance.memory;
                            d.update(m.usedJSHeapSize / 1048576, m.jsHeapSizeLimit / 1048576)
                        }
                        return f
                    },
                    update: function() {
                        a = this.end()
                    },
                    domElement: o,
                    setMode: i
                }
            };
            return t.Panel = function(n, i, s) {
                var o = 1 / 0
                  , a = 0
                  , c = Math.round
                  , l = c(window.devicePixelRatio || 1)
                  , u = 80 * l
                  , h = 48 * l
                  , d = 3 * l
                  , f = 2 * l
                  , m = 3 * l
                  , g = 15 * l
                  , A = 74 * l
                  , p = 30 * l
                  , S = document.createElement("canvas");
                S.width = u,
                S.height = h,
                S.style.cssText = "width:80px;height:48px";
                var w = S.getContext("2d");
                return w.font = "bold " + 9 * l + "px Helvetica,Arial,sans-serif",
                w.textBaseline = "top",
                w.fillStyle = s,
                w.fillRect(0, 0, u, h),
                w.fillStyle = i,
                w.fillText(n, d, f),
                w.fillRect(m, g, A, p),
                w.fillStyle = s,
                w.globalAlpha = .9,
                w.fillRect(m, g, A, p),
                {
                    dom: S,
                    update: function(b, B) {
                        o = Math.min(o, b),
                        a = Math.max(a, b),
                        w.fillStyle = s,
                        w.globalAlpha = 1,
                        w.fillRect(0, 0, u, g),
                        w.fillStyle = i,
                        w.fillText(c(b) + " " + n + " (" + c(o) + "-" + c(a) + ")", d, f),
                        w.drawImage(S, m + l, g, A - l, p, m, g, A - l, p),
                        w.fillRect(m + A - l, g, l, p),
                        w.fillStyle = s,
                        w.globalAlpha = .9,
                        w.fillRect(m + A - l, g, l, c((1 - b / B) * p))
                    }
                }
            }
            ,
            t
        })
    }(Br)),
    Br.exports
}
var yx = xx();
const bx = ah(yx);
class Mx {
    constructor() {
        this.mouse = new Ae
    }
    SetInitialCameraPosition(e, t) {
        const i = new xt().setFromObject(t).getCenter(new D)
          , s = new D(i.x,i.y + 1e3,i.z);
        e.position.set(s.x, s.y, s.z),
        e.lookAt(i)
    }
    initializeRenderer(e) {
        return this.renderer = new s0({
            canvas: e,
            antialias: !0,
            alpha: !0,
            preserveDrawingBuffer: !0
        }),
        this.renderer.setSize(window.innerWidth, window.innerHeight),
        this.renderer.setPixelRatio(window.devicePixelRatio),
        this.renderer.shadowMap.enabled = !0,
        this.renderer.shadowMap.type = ja,
        this.renderer
    }
    initializeRaycaster() {
        this.raycaster = new Vr
    }
    setupLighting(e) {
        const t = new tp(16777215,16777215,1);
        t.position.set(0, 20, 0),
        t.intensity = 2,
        e.add(t);
        const n = new Qu(16777215,1);
        n.position.set(-100, 43.5, 165.6),
        n.castShadow = !0,
        n.shadow.radius = 1,
        n.intensity = 1,
        n.shadow.bias = -.003,
        n.shadow.radius = 1,
        n.shadow.mapSize.width = 1024,
        n.shadow.mapSize.height = 1024,
        n.shadow.camera.near = 57.4,
        n.shadow.camera.far = 377.1,
        n.shadow.camera.left = -159.8,
        n.shadow.camera.right = 180.4,
        n.shadow.camera.top = 39,
        n.shadow.camera.bottom = -50,
        n.target.position.set(100, 0, 50),
        e.add(n)
    }
    renderCamera(e, t) {
        this.renderer.render(t, e)
    }
    handleCanvasClick(e, t, n, i, s, o, a, c) {
        var f, m, g, A;
        if ((f = Ie.spacerApp) != null && f.cameraManager.controls.isNavigating)
            return;
        const l = t.getBoundingClientRect();
        let u, h;
        if (e instanceof MouseEvent)
            u = e.clientX,
            h = e.clientY;
        else if (e instanceof TouchEvent && e.touches.length > 0)
            u = e.touches[0].clientX,
            h = e.touches[0].clientY;
        else
            return;
        this.mouse.x = (u - l.left) / l.width * 2 - 1,
        this.mouse.y = -((h - l.top) / l.height) * 2 + 1,
        this.raycaster.setFromCamera(this.mouse, n);
        const d = this.raycaster.intersectObjects(i.plotMeshes);
        if (d.length > 0) {
            const S = d[0]
              , w = (g = (m = S.object.name) == null ? void 0 : m.toLowerCase) == null ? void 0 : g.call(m);
            if (((A = i.activePlotData) == null ? void 0 : A.name.toLowerCase()) === w.toLowerCase()) {
                i.activePlotData && (c.add(i.activePlotData.textMesh),
                i.activePlotData.annotationVisible = !1,
                i.showStatus && i.activePlotData ? i.updateToPlotStatusMaterial(i.activePlotData, a, o.displayStatusBtn) : i.activePlotMesh && (i.activePlotMesh.material = i.initialPlotMaterial),
                i.activePlotData = null),
                i.dimension.Remove();
                return
            }
            if (S) {
                if (Ie.isProcessing)
                    return;
                Ie.isProcessing = !0,
                s.goToPlot(S.object),
                i.selectPlot(w, o, a, o.displayStatusBtn, n, c)
            }
            o.clearInput()
        } else
            i.activePlotData && (c.add(i.activePlotData.textMesh),
            i.activePlotData.annotationVisible = !1,
            i.showStatus && i.activePlotData ? i.updateToPlotStatusMaterial(i.activePlotData, a, o.displayStatusBtn) : i.activePlotMesh && (i.activePlotMesh.material = i.initialPlotMaterial),
            i.activePlotData = null),
            i.dimension.Remove()
    }
    debuggerMode(e, t, n, i) {
        this.stats = new bx;
        let s, o;
        const a = () => {
            requestAnimationFrame(a),
            this.stats.update(),
            s.innerText = `x:${i.position.x.toFixed(3)} y:${i.position.y.toFixed(3)} z:${i.position.z.toFixed(3)}`,
            o.innerText = `x:${Dt.radToDeg(i.rotation.x).toFixed(2)} y:${Dt.radToDeg(i.rotation.y).toFixed(2)} z:${Dt.radToDeg(i.rotation.z).toFixed(2)}`
        }
        ;
        if (e.isDebug == 1) {
            this.stats.dom.style.position = "fixed",
            this.stats.dom.style.top = "auto",
            this.stats.dom.style.bottom = "0px",
            this.stats.dom.style.left = "0px",
            document.body.appendChild(this.stats.dom);
            const c = new yp;
            t.add(c);
            const l = document.createElement("div");
            l.id = "btn-capture";
            const u = document.getElementsByClassName("interactionContainer")[0];
            l.innerText = "Capture Screenshot",
            u.appendChild(l),
            l.addEventListener("click", d => {
                this.captureOrthoScreenshot(8e3, t, n, i),
                this.capturePerspectiveScreenshot(8e3, t, n, i)
            }
            );
            const h = document.getElementById("debug-scene-info");
            h.style.display = "flex",
            s = document.getElementById("position-value"),
            s.addEventListener("click", d => {
                navigator.clipboard.writeText(s.innerText)
            }
            ),
            o = document.getElementById("rotation-value"),
            o.addEventListener("click", d => {
                navigator.clipboard.writeText(o.innerText)
            }
            ),
            a()
        }
    }
    captureOrthoScreenshot(e, t, n, i) {
        const s = document.getElementById("threeCanvas");
        if (!s) {
            console.error("Could not find a canvas element on the page.");
            return
        }
        const o = new Ae;
        n.getSize(o);
        const a = i
          , c = e
          , l = Math.floor(c / a.aspect)
          , u = new Vr
          , h = new xn(new D(0,1,0),0)
          , d = new D;
        a.getWorldDirection(d),
        u.set(a.position, d);
        let f = new D;
        u.ray.intersectPlane(h, f),
        f || (console.warn("Camera is below the ground plane, defaulting lookAt to origin (0, 0, 0)."),
        f = new D(0,0,0));
        const m = a.position.distanceTo(f)
          , g = a.fov * Math.PI / 180
          , A = 2 * Math.tan(g / 2) * m
          , p = A * a.aspect
          , S = new Yr(p / -2,p / 2,A / 2,A / -2,a.near,a.far);
        S.position.copy(a.position),
        S.lookAt(f),
        i = S,
        n.setSize(c, l, !1),
        i.updateProjectionMatrix(),
        n.render(t, i);
        const w = s.toDataURL("image/png");
        i = a,
        n.setSize(o.x, o.y, !1),
        i.updateProjectionMatrix();
        const b = document.createElement("a");
        b.href = w,
        b.download = `threejs-ortho-screenshot-${c}x${l}.png`,
        document.body.appendChild(b),
        b.click(),
        document.body.removeChild(b),
        console.log(`Screenshot captured at ${c}x${l} and downloaded!`)
    }
    capturePerspectiveScreenshot(e, t, n, i) {
        const s = "image/png"
          , a = new Ae;
        n.getSize(a);
        const c = a.x / a.y
          , l = Math.round(e / c)
          , u = a.clone()
          , h = n.getPixelRatio()
          , d = i.aspect;
        n.setSize(e, l, !1),
        n.setPixelRatio(1),
        i.aspect = e / l,
        i.updateProjectionMatrix(),
        n.render(t, i);
        const f = n.domElement.toDataURL(s, 1);
        n.setSize(u.x, u.y, !1),
        n.setPixelRatio(h),
        i.aspect = d,
        i.updateProjectionMatrix();
        const m = document.createElement("a");
        return m.href = f,
        m.download = `threejs-perspective-screenshot-${e}x${l}.png`,
        document.body.appendChild(m),
        m.click(),
        document.body.removeChild(m),
        f
    }
    initializeHandlers(e, t, n, i, s, o, a) {
        document.getElementById("threeCanvas").addEventListener("mouseup", c => {
            c.button == 0 && this.handleCanvasClick(c, e, t, i, s, n, o, a)
        }
        ),
        document.getElementById("threeCanvas").addEventListener("touchstart", c => {
            document.getElementById("swipe").classList.add("hide")
        }
        ),
        document.getElementById("threeCanvas").addEventListener("mousedown", c => {
            document.getElementById("swipe").classList.add("hide")
        }
        )
    }
}
class wx extends xi {
    constructor(e) {
        super(e)
    }
    load(e, t, n, i) {
        const s = this
          , o = new hc(this.manager);
        o.setPath(this.path),
        o.setRequestHeader(this.requestHeader),
        o.setWithCredentials(this.withCredentials),
        o.load(e, function(a) {
            const c = s.parse(JSON.parse(a));
            t && t(c)
        }, n, i)
    }
    parse(e) {
        return new Sx(e)
    }
}
class Sx {
    constructor(e) {
        this.isFont = !0,
        this.type = "Font",
        this.data = e
    }
    generateShapes(e, t=100) {
        const n = []
          , i = Tx(e, t, this.data);
        for (let s = 0, o = i.length; s < o; s++)
            n.push(...i[s].toShapes());
        return n
    }
}
function Tx(r, e, t) {
    const n = Array.from(r)
      , i = e / t.resolution
      , s = (t.boundingBox.yMax - t.boundingBox.yMin + t.underlineThickness) * i
      , o = [];
    let a = 0
      , c = 0;
    for (let l = 0; l < n.length; l++) {
        const u = n[l];
        if (u === `
`)
            a = 0,
            c -= s;
        else {
            const h = Ex(u, i, a, c, t);
            a += h.offsetX,
            o.push(h.path)
        }
    }
    return o
}
function Ex(r, e, t, n, i) {
    const s = i.glyphs[r] || i.glyphs["?"];
    if (!s) {
        console.error('THREE.Font: character "' + r + '" does not exists in font family ' + i.familyName + ".");
        return
    }
    const o = new bp;
    let a, c, l, u, h, d, f, m;
    if (s.o) {
        const g = s._cachedOutline || (s._cachedOutline = s.o.split(" "));
        for (let A = 0, p = g.length; A < p; )
            switch (g[A++]) {
            case "m":
                a = g[A++] * e + t,
                c = g[A++] * e + n,
                o.moveTo(a, c);
                break;
            case "l":
                a = g[A++] * e + t,
                c = g[A++] * e + n,
                o.lineTo(a, c);
                break;
            case "q":
                l = g[A++] * e + t,
                u = g[A++] * e + n,
                h = g[A++] * e + t,
                d = g[A++] * e + n,
                o.quadraticCurveTo(h, d, l, u);
                break;
            case "b":
                l = g[A++] * e + t,
                u = g[A++] * e + n,
                h = g[A++] * e + t,
                d = g[A++] * e + n,
                f = g[A++] * e + t,
                m = g[A++] * e + n,
                o.bezierCurveTo(h, d, f, m, l, u);
                break
            }
    }
    return {
        offsetX: s.ha * e,
        path: o
    }
}
class Px {
    constructor(e, t) {
        this.canvas = e,
        this.urlParams = t,
        this.btn_3dIcon = document.getElementById("viewModeBtn"),
        this.BoundaryMaterials = [],
        this.DrawBoundaryMeshes = [],
        this.instanceMeshes = {},
        this.Urls = {
            getProjectData: "https://common-getprojectdata-6nald5rpxa-el.a.run.app",
            getPlotData: "https://common-getplotsdata-6nald5rpxa-el.a.run.app",
            getAppConfig: "https://common-getappconfig-6nald5rpxa-el.a.run.app",
            getInstanceMeshes: "https://spacerapp-getinstancemeshes-6nald5rpxa-el.a.run.app"
        }
    }
    loadGoogleMaps() {
        return new Promise( (e, t) => {
            var i;
            if (typeof google < "u" && ((i = google.maps) != null && i.importLibrary)) {
                e();
                return
            }
            const n = document.createElement("script");
            n.id = "gmap-script",
            n.src = "https://maps.googleapis.com/maps/api/js?key=AIzaSyD5Jtra30gvz8EBPuGD8kNqISDhGERWVHo&v=weekly&loading=async",
            n.async = !0,
            n.defer = !0,
            n.onload = () => {
                const s = () => {
                    var o;
                    (o = google.maps) != null && o.importLibrary ? e() : setTimeout(s, 50)
                }
                ;
                s()
            }
            ,
            n.onerror = () => t(new Error("Google Maps failed to load")),
            document.head.appendChild(n)
        }
        )
    }
    async initMap(e, t, n, i, s) {
        var m;
        const o = this.dataService.projectData.r2_links["map_overlay.webp"];
        if (!o)
            return;
        (m = document.getElementById("showMap")) == null || m.classList.remove("disable"),
        await this.loadGoogleMaps();
        const {Map: a, MapTypeId: c, GroundOverlay: l, RenderingType: u} = await google.maps.importLibrary("maps")
          , h = new a(document.getElementById("map"),{
            zoom: s,
            center: {
                lat: e,
                lng: t
            },
            mapTypeId: c.HYBRID,
            disableDefaultUI: !0,
            streetViewControl: !1,
            headingInteractionEnabled: !0,
            mapId: "275ef5682750a4efb34b2cc8"
        })
          , d = {
            north: i.north,
            south: i.south,
            east: i.east,
            west: i.west
        }
          , f = new l(o,d);
        f.setMap(h),
        f.setOpacity(.85),
        Ie.Map = h
    }
    async initialize() {
        try {
            if (new wx().load("./Fonts/Inria Sans_Bold.json", t => {
                Ie.Fonts = t
            }
            ),
            this.initializeScene(),
            this.dataService = new Z0,
            this.plotManager = new Ha,
            this.cameraManager = new q0,
            this.uiInteraction = new gx,
            this.sceneInteraction = new Mx,
            await this.loadData(this.dataService, this.uiInteraction, this.plotManager, this.urlParams),
            this.dataService.projectData.mapOverlayBounds && this.initMap(this.dataService.projectData.latitude, this.dataService.projectData.longitude, this.urlParams.pId, this.dataService.projectData.mapOverlayBounds, this.dataService.projectData.mapOverlayZoom),
            this.initializeRenderer(),
            this.cameraManager.initializeCamera(this.canvas, this.scene),
            this.plotManager.initializeDimension(this.scene, this.cameraManager.camera),
            this.cameraManager.initializeControls(this.scene, this.sceneInteraction.renderer),
            this.initializeLoadingManager(),
            this.BoundaryMaterials = await this.getBoundaryMaterialsNames(),
            this.model = await this.loadBaseModel(this.loadingManager),
            this.model && (this.loadModelStreams(),
            this.cameraManager.setInitialCameraPosition(this.model),
            this.cameraManager.updateCameraConfig(this.model),
            this.cameraManager.startTransition(this.dataService.projectData.cameraHomePosition.position, 3),
            this.plotManager.DrawPlotNumbers(this.scene).then( () => {
                this.DrawBoundaries(this.plotManager.avgPlotSize)
            }
            )),
            this.cameraManager.controls.lerpCameraToHome(this.dataService.projectData.cameraHomePosition),
            this.uiInteraction.initializeEventListeners(this.cameraManager, this.dataService.projectData.cameraHomePosition, this.plotManager, this.dataService.statuses, this.uiInteraction, this.dataService.projectData.projectName, this.urlParams.pId, this.urlParams.status, this.dataService.imageUrls, this.sceneInteraction.renderer, this.scene),
            this.uiInteraction.updateGoogleMapLocation(this.dataService.projectData.googleMapLocation),
            this.sceneInteraction.setupLighting(this.scene),
            this.sceneInteraction.initializeRaycaster(),
            this.sceneInteraction.initializeHandlers(this.canvas, this.cameraManager.camera, this.uiInteraction, this.plotManager, this.cameraManager, this.dataService.statuses, this.scene),
            this.sceneInteraction.debuggerMode(this.urlParams, this.scene, this.sceneInteraction.renderer, this.cameraManager.camera),
            this.runRenderLoop(this.cameraManager, this.sceneInteraction, this.scene, this.dataService.projectData.northOffset),
            this.loadClientImages(),
            this.loadGalleryImages(),
            this.dataService.projectData.showWatermark) {
                const t = document.getElementById("mark");
                t.style.display = "flex"
            }
        } catch (e) {
            _n.trackError("manual", e)
        }
    }
    initializeScene() {
        this.scene = new Qc
    }
    initializeRenderer() {
        this.sceneInteraction.initializeRenderer(this.canvas)
    }
    async loadData(e, t, n, i) {
        const s = await e.getProjectData(i.pId);
        s && (e.projectData = s,
        Ie.ProjectData = s,
        t.setGetYourSpacerAdVisibility(s == null ? void 0 : s.showGetYourSpacerAd));
        const o = await e.getPlotsData(i.pId, i.status);
        o && (e.plotsDataArray = o),
        n.StorePlotsData(e.plotsDataArray),
        t.setStatusVisibility(i.status, e.projectData.statusKey),
        t.displayStatusBtn && (this.defaultStatus = await this.getDefaultStatus())
    }
    async loadModelStreams() {
        var i;
        const e = []
          , t = new Xo;
        Object.keys((i = Ie.ProjectData) == null ? void 0 : i.r2_links).filter(s => s.toLowerCase().includes("models/") && s.toLowerCase().endsWith(".glb") && s.toLowerCase() !== "models/SM_Base_Model.glb".toLowerCase()).forEach(s => {
            var c;
            const o = (c = Ie.ProjectData) == null ? void 0 : c.r2_links[s]
              , a = new Promise( (l, u) => {
                t.load(o, h => l(h), void 0, h => u(h))
            }
            );
            e.push(a)
        }
        ),
        await Promise.allSettled(e).then(s => {
            s.forEach(async o => {
                if (o.status == "fulfilled") {
                    const a = o.value
                      , c = a.scene;
                    a.scene.traverse(l => {
                        l instanceof ct && (Array.isArray(l.material) ? l.material : [l.material]).forEach(async h => {
                            const d = h;
                            d.transparent = !0,
                            d.name.toLowerCase().startsWith("mg_") ? l.renderOrder = 0 : (d.depthTest = !0,
                            d.depthWrite = !0,
                            l.renderOrder = 3)
                        }
                        )
                    }
                    ),
                    this.scene.add(c)
                } else
                    console.log(o.reason)
            }
            )
        }
        )
    }
    async getBoundaryMaterialsNames() {
        var e;
        try {
            const t = new URL((e = Ie.spacerApp) == null ? void 0 : e.Urls.getAppConfig);
            t.searchParams.append("config", "boundaryMaterials");
            const n = await fetch(t.toString());
            if (!n.ok)
                throw new Error(`HTTP error! status: ${n.status}`);
            return (await n.json()).value
        } catch (t) {
            _n.trackError("manual", t)
        }
    }
    async getDefaultStatus() {
        var e;
        try {
            const t = new URL((e = Ie.spacerApp) == null ? void 0 : e.Urls.getAppConfig);
            t.searchParams.append("config", "defaultStatus");
            const n = await fetch(t.toString());
            if (!n.ok)
                throw new Error(`HTTP error! status: ${n.status}`);
            return (await n.json()).value
        } catch (t) {
            _n.trackError("manual", t)
        }
    }
    async loadClientImages() {
        this.dataService.clientLogo = this.dataService.projectData.r2_links["logo.svg"],
        this.uiInteraction.SetClientLogo(this.dataService.clientLogo),
        this.uiInteraction.setProjectInfo(this.dataService.clientLogo, this.dataService.projectData.projectDescription, this.dataService.projectData.totalArea, this.dataService.projectData.areaUnit, this.dataService.projectData.socialMediaLinks, this.dataService.projectData.projectName)
    }
    initializeLoadingManager() {
        this.loadingManager = new Ku,
        this.loadingManager.onStart = async () => {
            this.canvas.style.visibility = "hidden"
        }
        ;
        const e = document.getElementById("progressFill");
        this.loadingManager.onProgress = (t, n, i) => {
            const s = Math.round(n / i * 100);
            e.style.width = `${s}%`
        }
        ,
        this.loadingManager.onLoad = () => {
            this.canvas.style.visibility = "visible",
            document.getElementsByClassName("loading-animation")[0].remove();
            const t = document.getElementById("loadingScreen");
            t.classList.add("loaded"),
            setTimeout( () => {
                t.remove()
            }
            , 1e3),
            setTimeout( () => {
                document.getElementById("swipe").style.visibility = "visible"
            }
            , 3e3),
            setTimeout( () => {
                document.getElementById("swipe").style.visibility = "hidden"
            }
            , 1e4)
        }
    }
    StoreMeshIfISM(e) {
        if (e.name.startsWith("ISM__")) {
            const t = e.name.match(/^ISM__.+__/);
            t && (t[0]in this.instanceMeshes || (this.instanceMeshes[t[0]] = []),
            this.instanceMeshes[t[0]].push(e))
        }
    }
    async loadBaseModel(e) {
        const t = Object.keys(this.dataService.projectData.r2_links).find(s => s.toLowerCase() == "models/sm_base_model.glb")
          , n = t ? this.dataService.projectData.r2_links[t] : null;
        if (!n)
            return null;
        const i = new Xo(e);
        return new Promise( (s, o) => {
            i.load(n, a => {
                const c = a.scene;
                c.castShadow = !0,
                c.receiveShadow = !0;
                const u = `^(?:${this.BoundaryMaterials.map(f => f.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")).join("|")})(?:\\.\\d+)?$`
                  , h = new RegExp(u,"i")
                  , d = new RegExp("^(?:mg_plot)(?:\\.\\d+)?$","i");
                c.traverse(f => {
                    if (f.isMesh) {
                        const m = f;
                        m.castShadow = !0,
                        m.receiveShadow = !0,
                        m.material.transparent = !1;
                        const g = Array.isArray(m.material) ? m.material : [m.material];
                        let A = !1;
                        g.forEach(p => {
                            const S = p;
                            S.transparent = !0,
                            S.name.startsWith("MG_") ? f.renderOrder = 0 : (S.depthTest = !0,
                            S.depthWrite = !0,
                            f.renderOrder = 3),
                            h.test(S.name.toLowerCase()) && (A = !0),
                            d.test(S.name) && (m.name = m.name.replaceAll("__", "/").replaceAll("To", "-"),
                            this.plotManager.initialPlotMaterial = S,
                            this.plotManager.plotMeshes.push(m),
                            this.plotManager.initialPlotMaterial = S),
                            d.test(S.name) && (St.plot || (St.plot = S)),
                            new RegExp("^(?:mg_road)(?:\\.\\d+)?$","i").test(S.name) && (St.road || (St.road = S)),
                            new RegExp("^(?:mg_green)(?:\\.\\d+)?$","i").test(S.name) && (St.grass || (St.grass = S))
                        }
                        ),
                        A && this.DrawBoundaryMeshes.push(m)
                    }
                }
                ),
                this.scene.add(c),
                s(c)
            }
            , void 0, a => {
                console.error("Error loading model:", a),
                o(null)
            }
            )
        }
        )
    }
    createInstancedGroup(e, t) {
        const n = [];
        return e.traverse(i => {
            if (i.isMesh) {
                i.updateMatrix();
                const s = i.matrix.clone()
                  , o = new Uu(i.geometry,i.material.clone(),t);
                o.castShadow = i.castShadow,
                o.receiveShadow = i.receiveShadow,
                n.push({
                    instancedMesh: o,
                    localMatrix: s
                })
            }
        }
        ),
        {
            meshes: n.map(i => i.instancedMesh),
            setMatrixAt(i, s) {
                n.forEach( ({instancedMesh: o, localMatrix: a}) => {
                    const c = new We().multiplyMatrices(s, a);
                    o.setMatrixAt(i, c),
                    o.instanceMatrix.needsUpdate = !0
                }
                )
            },
            addToScene(i, s) {
                n.forEach( ({instancedMesh: o}) => {
                    o.renderOrder = s,
                    i.add(o)
                }
                )
            }
        }
    }
    getFirstParentInScene(e) {
        let t = e.parent;
        for (; t && !(t instanceof Qc) && t.parent; )
            t = t.parent;
        return t
    }
    removeMesh(e) {
        e.parent && e.parent.remove(e),
        e.geometry && e.geometry.dispose(),
        e.material && (Array.isArray(e.material) ? e.material.forEach(t => t.dispose()) : e.material.dispose())
    }
    async replaceWithInstanced(e, t, n, i) {
        if (e.length === 0)
            return console.warn("No meshes to replace."),
            null;
        i.updateMatrixWorld(!0);
        const s = await new Promise( (u, h) => {
            n.load(t, d => u(d), void 0, d => h(d))
        }
        );
        let o;
        s.scene.traverse(u => {
            u.isMesh && !o && (o = u)
        }
        );
        const a = Array.isArray(o.material) ? o.material : [o.material];
        let c = 3;
        for (const u of a) {
            const h = u;
            if (h.transparent = !0,
            h.name.startsWith("MG_")) {
                c = 0;
                break
            } else {
                c = 3;
                break
            }
        }
        const l = this.getFirstParentInScene(o);
        if (!l)
            return console.error("No mesh found in GLB file."),
            null;
        if (l instanceof Jn) {
            const u = this.createInstancedGroup(l, e.length);
            e.forEach( (h, d) => {
                var g, A;
                h.geometry.computeBoundingBox();
                const f = new D;
                (g = h.geometry.boundingBox) == null || g.getCenter(f);
                const m = new D(-f.x,-((A = h.geometry.boundingBox) == null ? void 0 : A.min.y),-f.z);
                h.geometry.translate(m.x, m.y, m.z),
                h.position.add(m.multiplyScalar(-1)),
                h.updateMatrixWorld(!0),
                u.setMatrixAt(d, h.matrixWorld),
                this.removeMesh(h)
            }
            ),
            u.addToScene(i, c)
        }
    }
    async loadInstanceMeshes() {
        const e = await fetch(this.Urls.getInstanceMeshes, {
            method: "PUT",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify({
                ids: Object.keys(this.instanceMeshes)
            })
        })
          , t = await e.json();
        if (!e.ok)
            return;
        const n = new Xo;
        for (const i in this.instanceMeshes) {
            const s = this.instanceMeshes[i];
            this.replaceWithInstanced(s, t.value[i], n, this.scene)
        }
    }
    DrawBoundaries(e) {
        return new Promise( () => {
            St.boundaries = new Us({
                color: "black",
                linewidth: e * this.dataService.projectData.boundaryThickness,
                worldUnits: !0,
                depthWrite: !1,
                depthTest: !1,
                transparent: !0,
                resolution: new Ae(window.innerWidth,window.innerHeight)
            }),
            this.DrawBoundaryMeshes.forEach(t => {
                const n = this.GetEdgePoints(t.geometry);
                for (let i = 0; i < n.length; i++) {
                    const s = n[i];
                    this.ShowOutLine(s[0], s[1], St.boundaries)
                }
            }
            )
        }
        )
    }
    ShowOutLine(e, t, n) {
        const i = new qn().setFromPoints([e, t])
          , s = new di(i,n);
        s.renderOrder = 2,
        this.scene.add(s)
    }
    GetEdgePoints(e) {
        const n = new Na(e,180).attributes.position
          , i = [];
        for (let s = 0; s < n.count - 1; s += 2) {
            const o = new D(n.getX(s),n.getY(s),n.getZ(s))
              , a = new D(n.getX(s + 1),n.getY(s + 1),n.getZ(s + 1));
            i.push([o, a])
        }
        return i
    }
    async loadGalleryImages() {
        const e = Object.keys(this.dataService.projectData.r2_links).filter(t => t.includes("gallery_images/")).map(t => this.dataService.projectData.r2_links[t]);
        (e == null ? void 0 : e.length) > 0 ? (this.dataService.imageUrls = e,
        this.uiInteraction.loadImages(this.dataService.imageUrls)) : document.getElementById("gallery").classList.add("disable")
    }
    updateNorthIndicator(e) {
        const t = new D(0,0,-1).normalize();
        if (!this.cameraManager || !this.cameraManager.camera) {
            console.warn("CameraManager or camera is not initialized.");
            return
        }
        const n = new D;
        this.cameraManager.camera.getWorldDirection(n),
        n.y = 0,
        n.normalize();
        const i = t.clone();
        i.y = 0,
        i.normalize();
        const s = Math.atan2(i.x * n.z - i.z * n.x, i.x * n.x + i.z * n.z)
          , o = Dt.radToDeg(s)
          , a = document.getElementById("northIndicator");
        if (a) {
            const c = -o + e;
            a.style.transform = `rotate(${c}deg)`
        }
    }
    stopRenderLoop() {
        Ie.StopRenderLoop = !0
    }
    startRenderLoop() {
        Ie.StopRenderLoop = !1,
        this.runRenderLoop(this.cameraManager, this.sceneInteraction, this.scene, this.dataService.projectData.northOffset)
    }
    runRenderLoop(e, t, n, i) {
        const s = () => {
            Ie.StopRenderLoop || requestAnimationFrame(s),
            e.controls.updateLerp(),
            t.renderer.autoClear = !0,
            t.renderCamera(e.camera, n),
            e.controls.In3DView && !this.btn_3dIcon.src.endsWith("2dMode.svg") ? this.btn_3dIcon.src = "./assets/Icons/2dMode.svg" : !this.btn_3dIcon.src.endsWith("3dMode.svg") && !e.controls.In3DView && (this.btn_3dIcon.src = "./assets/Icons/3dMode.svg"),
            this.updateNorthIndicator(i)
        }
        ;
        s()
    }
}
_n.initGlobalListeners();
async function Lx() {
    const r = document.getElementById("threeCanvas")
      , e = Cx()
      , t = new Px(r,e);
    Ie.spacerApp = t,
    await t.initialize()
}
function Cx() {
    const r = new URLSearchParams(window.location.search);
    let e;
    e = r.get("id"),
    r.get("status"),
    r.delete("id");
    const t = r.toString();
    window.history.replaceState({}, "", `/${e}${t ? `?${t}` : ""}`);
    const n = {
        pId: e,
        status: r.get("status") || "",
        isDebug: parseInt(r.get("isDebug") || "0")
    };
    return n.isDebug && (Ie.IsDebugMode = !0),
    n
}
Lx().catch(r => {
    _n.trackError("Initialization", r)
}
);
let fu = null;
const Bs = document.getElementById("overlay");
let vn = null;
gallery;
const Rx = () => {
    Bs.classList.add("active"),
    fu = document.getElementById("spacerInfo"),
    fu.classList.add("active")
}
  , Dx = () => {
    document.getElementById("infoView").classList.remove("active"),
    Rx()
}
;
window.openCard = r => {
    vn = document.getElementById(r),
    Bs.classList.add("active"),
    Bs.style.display = "flex",
    vn.style.display = "flex",
    requestAnimationFrame( () => {
        vn.classList.add("active")
    }
    )
}
;
function Zr() {
    Bs.classList.remove("active"),
    vn && (vn.classList.remove("active"),
    vn.addEventListener("transitionend", function r(e) {
        vn.removeEventListener("transitionend", r),
        e.propertyName === "opacity" && window.getComputedStyle(vn).opacity == 0 && (vn.style.display = "none",
        vn = null)
    }))
}
Bs.addEventListener("click", r => {
    r.target.classList.contains("overlay") && Zr()
}
);
document.getElementById("gallery");
document.getElementById("cardFooterText").addEventListener("click", Dx);
document.getElementById("cross1").addEventListener("click", Zr);
document.getElementById("cross2").addEventListener("click", Zr);
document.getElementById("cross3").addEventListener("click", Zr);
const ch = document.getElementById("threeCanvas");
ch.addEventListener("mousedown", lh);
ch.addEventListener("touchstart", lh, {
    passive: !0
});
function lh() {
    const r = document.activeElement;
    r && r.tagName === "INPUT" && r.blur()
}
